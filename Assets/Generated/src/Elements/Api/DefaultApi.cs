/*
 * ECI Elements
 *
 * ECI Elements Core APIs
 *
 * The version of the OpenAPI document: 3.3.10 - 9026b5d99b4ec92e367b100402af1adca227de0c - 2025-08-19 05:36:54
 * Contact: info@namazustudios.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using Elements.Client;
using Elements.Model;

namespace Elements.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IDefaultApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Adjust the quantity of the inventory item for the specified item.
        /// </summary>
        /// <remarks>
        /// Adjust the quantity of the first (primary) inventory item for the specified item.  This implicitly will create the InventoryItem if it does not exist.  The inventory item value
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="advancedInventoryItemQuantityAdjustment"> (optional)</param>
        /// <returns>InventoryItem</returns>
        InventoryItem AdjustAdvancedInventoryItemQuantity(string inventoryItemId, AdvancedInventoryItemQuantityAdjustment advancedInventoryItemQuantityAdjustment = default(AdvancedInventoryItemQuantityAdjustment));

        /// <summary>
        /// Adjust the quantity of the inventory item for the specified item.
        /// </summary>
        /// <remarks>
        /// Adjust the quantity of the first (primary) inventory item for the specified item.  This implicitly will create the InventoryItem if it does not exist.  The inventory item value
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="advancedInventoryItemQuantityAdjustment"> (optional)</param>
        /// <returns>ApiResponse of InventoryItem</returns>
        ApiResponse<InventoryItem> AdjustAdvancedInventoryItemQuantityWithHttpInfo(string inventoryItemId, AdvancedInventoryItemQuantityAdjustment advancedInventoryItemQuantityAdjustment = default(AdvancedInventoryItemQuantityAdjustment));
        /// <summary>
        /// Adjust the quantity of the inventory item for the specified item.
        /// </summary>
        /// <remarks>
        /// Adjust the quantity of the first (primary) inventory item for the specified item.  This implicitly will create the InventoryItem if it does not exist.  The inventory item value
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="simpleInventoryItemQuantityAdjustment"> (optional)</param>
        /// <returns>InventoryItem</returns>
        InventoryItem AdjustSimpleInventoryItemQuantity(string inventoryItemId, SimpleInventoryItemQuantityAdjustment simpleInventoryItemQuantityAdjustment = default(SimpleInventoryItemQuantityAdjustment));

        /// <summary>
        /// Adjust the quantity of the inventory item for the specified item.
        /// </summary>
        /// <remarks>
        /// Adjust the quantity of the first (primary) inventory item for the specified item.  This implicitly will create the InventoryItem if it does not exist.  The inventory item value
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="simpleInventoryItemQuantityAdjustment"> (optional)</param>
        /// <returns>ApiResponse of InventoryItem</returns>
        ApiResponse<InventoryItem> AdjustSimpleInventoryItemQuantityWithHttpInfo(string inventoryItemId, SimpleInventoryItemQuantityAdjustment simpleInventoryItemQuantityAdjustment = default(SimpleInventoryItemQuantityAdjustment));
        /// <summary>
        /// Destroys the Session
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionSecret"></param>
        /// <returns></returns>
        void BlacklistSession(string sessionSecret);

        /// <summary>
        /// Destroys the Session
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionSecret"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> BlacklistSessionWithHttpInfo(string sessionSecret);
        /// <summary>
        /// Builds all indexes.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="buildIndexRequest"> (optional)</param>
        /// <returns></returns>
        void BuildIndexes(BuildIndexRequest buildIndexRequest = default(BuildIndexRequest));

        /// <summary>
        /// Builds all indexes.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="buildIndexRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> BuildIndexesWithHttpInfo(BuildIndexRequest buildIndexRequest = default(BuildIndexRequest));
        /// <summary>
        /// Create an inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Create an inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAdvancedInventoryItemRequest"> (optional)</param>
        /// <returns>InventoryItem</returns>
        InventoryItem CreateAdvancedInventoryItem(CreateAdvancedInventoryItemRequest createAdvancedInventoryItemRequest = default(CreateAdvancedInventoryItemRequest));

        /// <summary>
        /// Create an inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Create an inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAdvancedInventoryItemRequest"> (optional)</param>
        /// <returns>ApiResponse of InventoryItem</returns>
        ApiResponse<InventoryItem> CreateAdvancedInventoryItemWithHttpInfo(CreateAdvancedInventoryItemRequest createAdvancedInventoryItemRequest = default(CreateAdvancedInventoryItemRequest));
        /// <summary>
        /// Creates a New Application
        /// </summary>
        /// <remarks>
        /// Gets the metadata for a single application.  This may include more specific details not available in the bulk-get or fetch operation.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createApplicationRequest"> (optional)</param>
        /// <returns>Application</returns>
        Application CreateApplication(CreateApplicationRequest createApplicationRequest = default(CreateApplicationRequest));

        /// <summary>
        /// Creates a New Application
        /// </summary>
        /// <remarks>
        /// Gets the metadata for a single application.  This may include more specific details not available in the bulk-get or fetch operation.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createApplicationRequest"> (optional)</param>
        /// <returns>ApiResponse of Application</returns>
        ApiResponse<Application> CreateApplicationWithHttpInfo(CreateApplicationRequest createApplicationRequest = default(CreateApplicationRequest));
        /// <summary>
        /// Creates a new Auth Scheme
        /// </summary>
        /// <remarks>
        /// Creates a new Auth Scheme, from the data in the given auth scheme request
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAuthSchemeRequest"> (optional)</param>
        /// <returns>CreateAuthSchemeResponse</returns>
        CreateAuthSchemeResponse CreateAuthScheme(CreateAuthSchemeRequest createAuthSchemeRequest = default(CreateAuthSchemeRequest));

        /// <summary>
        /// Creates a new Auth Scheme
        /// </summary>
        /// <remarks>
        /// Creates a new Auth Scheme, from the data in the given auth scheme request
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAuthSchemeRequest"> (optional)</param>
        /// <returns>ApiResponse of CreateAuthSchemeResponse</returns>
        ApiResponse<CreateAuthSchemeResponse> CreateAuthSchemeWithHttpInfo(CreateAuthSchemeRequest createAuthSchemeRequest = default(CreateAuthSchemeRequest));
        /// <summary>
        /// Creates a new Auth Scheme
        /// </summary>
        /// <remarks>
        /// Creates a new Auth Scheme, from the data in the given auth scheme request
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createOrUpdateOAuth2AuthSchemeRequest"> (optional)</param>
        /// <returns>CreateOrUpdateOAuth2AuthSchemeResponse</returns>
        CreateOrUpdateOAuth2AuthSchemeResponse CreateAuthScheme1(CreateOrUpdateOAuth2AuthSchemeRequest createOrUpdateOAuth2AuthSchemeRequest = default(CreateOrUpdateOAuth2AuthSchemeRequest));

        /// <summary>
        /// Creates a new Auth Scheme
        /// </summary>
        /// <remarks>
        /// Creates a new Auth Scheme, from the data in the given auth scheme request
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createOrUpdateOAuth2AuthSchemeRequest"> (optional)</param>
        /// <returns>ApiResponse of CreateOrUpdateOAuth2AuthSchemeResponse</returns>
        ApiResponse<CreateOrUpdateOAuth2AuthSchemeResponse> CreateAuthScheme1WithHttpInfo(CreateOrUpdateOAuth2AuthSchemeRequest createOrUpdateOAuth2AuthSchemeRequest = default(CreateOrUpdateOAuth2AuthSchemeRequest));
        /// <summary>
        /// Creates a new Auth Scheme
        /// </summary>
        /// <remarks>
        /// Creates a new Auth Scheme, from the data in the given auth scheme request
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createOrUpdateOidcAuthSchemeRequest"> (optional)</param>
        /// <returns>CreateOrUpdateOidcAuthSchemeResponse</returns>
        CreateOrUpdateOidcAuthSchemeResponse CreateAuthScheme2(CreateOrUpdateOidcAuthSchemeRequest createOrUpdateOidcAuthSchemeRequest = default(CreateOrUpdateOidcAuthSchemeRequest));

        /// <summary>
        /// Creates a new Auth Scheme
        /// </summary>
        /// <remarks>
        /// Creates a new Auth Scheme, from the data in the given auth scheme request
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createOrUpdateOidcAuthSchemeRequest"> (optional)</param>
        /// <returns>ApiResponse of CreateOrUpdateOidcAuthSchemeResponse</returns>
        ApiResponse<CreateOrUpdateOidcAuthSchemeResponse> CreateAuthScheme2WithHttpInfo(CreateOrUpdateOidcAuthSchemeRequest createOrUpdateOidcAuthSchemeRequest = default(CreateOrUpdateOidcAuthSchemeRequest));
        /// <summary>
        /// Create an inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Create an inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createDistinctInventoryItemRequest"> (optional)</param>
        /// <returns>DistinctInventoryItem</returns>
        DistinctInventoryItem CreateDistinctInventoryItem(CreateDistinctInventoryItemRequest createDistinctInventoryItemRequest = default(CreateDistinctInventoryItemRequest));

        /// <summary>
        /// Create an inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Create an inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createDistinctInventoryItemRequest"> (optional)</param>
        /// <returns>ApiResponse of DistinctInventoryItem</returns>
        ApiResponse<DistinctInventoryItem> CreateDistinctInventoryItemWithHttpInfo(CreateDistinctInventoryItemRequest createDistinctInventoryItemRequest = default(CreateDistinctInventoryItemRequest));
        /// <summary>
        /// Creates an FCM Registration Token
        /// </summary>
        /// <remarks>
        /// Supplying FCM registration token, this will create a new token based on the information supplied to the endpoint.  The response will contain the token as it was written to the database.  Clients may subsequently update the token string with new values as they are issued by Firebase.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fCMRegistration"> (optional)</param>
        /// <returns>FCMRegistration</returns>
        FCMRegistration CreateFCMRegistration(FCMRegistration fCMRegistration = default(FCMRegistration));

        /// <summary>
        /// Creates an FCM Registration Token
        /// </summary>
        /// <remarks>
        /// Supplying FCM registration token, this will create a new token based on the information supplied to the endpoint.  The response will contain the token as it was written to the database.  Clients may subsequently update the token string with new values as they are issued by Firebase.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fCMRegistration"> (optional)</param>
        /// <returns>ApiResponse of FCMRegistration</returns>
        ApiResponse<FCMRegistration> CreateFCMRegistrationWithHttpInfo(FCMRegistration fCMRegistration = default(FCMRegistration));
        /// <summary>
        /// Creates a new Facebook ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Creates a new Facebook ApplicationConfiguration with the specific ID or application.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="facebookApplicationConfiguration"> (optional)</param>
        /// <returns>FacebookApplicationConfiguration</returns>
        FacebookApplicationConfiguration CreateFacebookApplicationConfiguration(string applicationNameOrId, FacebookApplicationConfiguration facebookApplicationConfiguration = default(FacebookApplicationConfiguration));

        /// <summary>
        /// Creates a new Facebook ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Creates a new Facebook ApplicationConfiguration with the specific ID or application.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="facebookApplicationConfiguration"> (optional)</param>
        /// <returns>ApiResponse of FacebookApplicationConfiguration</returns>
        ApiResponse<FacebookApplicationConfiguration> CreateFacebookApplicationConfigurationWithHttpInfo(string applicationNameOrId, FacebookApplicationConfiguration facebookApplicationConfiguration = default(FacebookApplicationConfiguration));
        /// <summary>
        /// Creates a new Firebase ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Creates a new Firebase ApplicationConfiguration with the specific ID or application.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="firebaseApplicationConfiguration"> (optional)</param>
        /// <returns>FirebaseApplicationConfiguration</returns>
        FirebaseApplicationConfiguration CreateFirebaseApplicationConfiguration(string applicationNameOrId, FirebaseApplicationConfiguration firebaseApplicationConfiguration = default(FirebaseApplicationConfiguration));

        /// <summary>
        /// Creates a new Firebase ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Creates a new Firebase ApplicationConfiguration with the specific ID or application.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="firebaseApplicationConfiguration"> (optional)</param>
        /// <returns>ApiResponse of FirebaseApplicationConfiguration</returns>
        ApiResponse<FirebaseApplicationConfiguration> CreateFirebaseApplicationConfigurationWithHttpInfo(string applicationNameOrId, FirebaseApplicationConfiguration firebaseApplicationConfiguration = default(FirebaseApplicationConfiguration));
        /// <summary>
        /// Creates a Follower relationship between two profiles.
        /// </summary>
        /// <remarks>
        /// Supplying the follower object, this will store the information supplied in the body of the request.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="createFollowerRequest"> (optional)</param>
        /// <returns></returns>
        void CreateFollower(string profileId, CreateFollowerRequest createFollowerRequest = default(CreateFollowerRequest));

        /// <summary>
        /// Creates a Follower relationship between two profiles.
        /// </summary>
        /// <remarks>
        /// Supplying the follower object, this will store the information supplied in the body of the request.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="createFollowerRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> CreateFollowerWithHttpInfo(string profileId, CreateFollowerRequest createFollowerRequest = default(CreateFollowerRequest));
        /// <summary>
        /// Creates a new Google Play ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Creates a new GooglePlay ApplicationConfiguration with the specific ID or application.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="googlePlayApplicationConfiguration"> (optional)</param>
        /// <returns>GooglePlayApplicationConfiguration</returns>
        GooglePlayApplicationConfiguration CreateGooglePlayApplicationConfiguration(string applicationNameOrId, GooglePlayApplicationConfiguration googlePlayApplicationConfiguration = default(GooglePlayApplicationConfiguration));

        /// <summary>
        /// Creates a new Google Play ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Creates a new GooglePlay ApplicationConfiguration with the specific ID or application.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="googlePlayApplicationConfiguration"> (optional)</param>
        /// <returns>ApiResponse of GooglePlayApplicationConfiguration</returns>
        ApiResponse<GooglePlayApplicationConfiguration> CreateGooglePlayApplicationConfigurationWithHttpInfo(string applicationNameOrId, GooglePlayApplicationConfiguration googlePlayApplicationConfiguration = default(GooglePlayApplicationConfiguration));
        /// <summary>
        /// Creates a new iOS ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Creates a new iOS ApplicationConfiguration with the specific ID or application.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="iosApplicationConfiguration"> (optional)</param>
        /// <returns>IosApplicationConfiguration</returns>
        IosApplicationConfiguration CreateIosApplicationConfiguration(string applicationNameOrId, IosApplicationConfiguration iosApplicationConfiguration = default(IosApplicationConfiguration));

        /// <summary>
        /// Creates a new iOS ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Creates a new iOS ApplicationConfiguration with the specific ID or application.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="iosApplicationConfiguration"> (optional)</param>
        /// <returns>ApiResponse of IosApplicationConfiguration</returns>
        ApiResponse<IosApplicationConfiguration> CreateIosApplicationConfigurationWithHttpInfo(string applicationNameOrId, IosApplicationConfiguration iosApplicationConfiguration = default(IosApplicationConfiguration));
        /// <summary>
        /// Creates a new digital Item
        /// </summary>
        /// <remarks>
        /// Supplying an item object, this will create a new item with a newly assigned unique id.  The Item representation returned in the response body is a representation of the Item as persisted with a unique identifier signed and with its fields properly normalized.  The supplied item object submitted with the request must have a name property that is unique across all items.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createItemRequest"> (optional)</param>
        /// <returns>Item</returns>
        Item CreateItem(CreateItemRequest createItemRequest = default(CreateItemRequest));

        /// <summary>
        /// Creates a new digital Item
        /// </summary>
        /// <remarks>
        /// Supplying an item object, this will create a new item with a newly assigned unique id.  The Item representation returned in the response body is a representation of the Item as persisted with a unique identifier signed and with its fields properly normalized.  The supplied item object submitted with the request must have a name property that is unique across all items.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createItemRequest"> (optional)</param>
        /// <returns>ApiResponse of Item</returns>
        ApiResponse<Item> CreateItemWithHttpInfo(CreateItemRequest createItemRequest = default(CreateItemRequest));
        /// <summary>
        /// Creates a LargeObject with content
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="varObject"> (optional)</param>
        /// <param name="metadata"> (optional)</param>
        /// <returns>LargeObject</returns>
        LargeObject CreateLargeObject(FormDataBodyPart varObject = default(FormDataBodyPart), CreateLargeObjectRequest metadata = default(CreateLargeObjectRequest));

        /// <summary>
        /// Creates a LargeObject with content
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="varObject"> (optional)</param>
        /// <param name="metadata"> (optional)</param>
        /// <returns>ApiResponse of LargeObject</returns>
        ApiResponse<LargeObject> CreateLargeObjectWithHttpInfo(FormDataBodyPart varObject = default(FormDataBodyPart), CreateLargeObjectRequest metadata = default(CreateLargeObjectRequest));
        /// <summary>
        /// Creates a LargeObject
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createLargeObjectRequest"> (optional)</param>
        /// <returns>LargeObject</returns>
        LargeObject CreateLargeObject1(CreateLargeObjectRequest createLargeObjectRequest = default(CreateLargeObjectRequest));

        /// <summary>
        /// Creates a LargeObject
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createLargeObjectRequest"> (optional)</param>
        /// <returns>ApiResponse of LargeObject</returns>
        ApiResponse<LargeObject> CreateLargeObject1WithHttpInfo(CreateLargeObjectRequest createLargeObjectRequest = default(CreateLargeObjectRequest));
        /// <summary>
        /// Creates a LargeObject from provided URL
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createLargeObjectFromUrlRequest"> (optional)</param>
        /// <returns>LargeObject</returns>
        LargeObject CreateLargeObjectFromUrl(CreateLargeObjectFromUrlRequest createLargeObjectFromUrlRequest = default(CreateLargeObjectFromUrlRequest));

        /// <summary>
        /// Creates a LargeObject from provided URL
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createLargeObjectFromUrlRequest"> (optional)</param>
        /// <returns>ApiResponse of LargeObject</returns>
        ApiResponse<LargeObject> CreateLargeObjectFromUrlWithHttpInfo(CreateLargeObjectFromUrlRequest createLargeObjectFromUrlRequest = default(CreateLargeObjectFromUrlRequest));
        /// <summary>
        /// Creates a New Leaderboard
        /// </summary>
        /// <remarks>
        /// Gets the metadata for a single leaderboard.  This may include more specific details not available in the bulk-get or fetch operation.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboard"> (optional)</param>
        /// <returns>Leaderboard</returns>
        Leaderboard CreateLeaderboard(Leaderboard leaderboard = default(Leaderboard));

        /// <summary>
        /// Creates a New Leaderboard
        /// </summary>
        /// <remarks>
        /// Gets the metadata for a single leaderboard.  This may include more specific details not available in the bulk-get or fetch operation.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboard"> (optional)</param>
        /// <returns>ApiResponse of Leaderboard</returns>
        ApiResponse<Leaderboard> CreateLeaderboardWithHttpInfo(Leaderboard leaderboard = default(Leaderboard));
        /// <summary>
        /// Creates a Match
        /// </summary>
        /// <remarks>
        /// This method accepts an instance of Match, effectively requesting that the server find a suitable opponent for a game.  As other suitable players create matches the created match object may be updated as a suitable opponent is found.  The client must poll matches for updates and react accordingly.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="match"> (optional)</param>
        /// <returns>Match</returns>
        Match CreateMatch(Match match = default(Match));

        /// <summary>
        /// Creates a Match
        /// </summary>
        /// <remarks>
        /// This method accepts an instance of Match, effectively requesting that the server find a suitable opponent for a game.  As other suitable players create matches the created match object may be updated as a suitable opponent is found.  The client must poll matches for updates and react accordingly.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="match"> (optional)</param>
        /// <returns>ApiResponse of Match</returns>
        ApiResponse<Match> CreateMatchWithHttpInfo(Match match = default(Match));
        /// <summary>
        /// Creates a new iOS ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Creates a new iOS ApplicationConfiguration with the specific ID or application.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="matchmakingApplicationConfiguration"> (optional)</param>
        /// <returns>MatchmakingApplicationConfiguration</returns>
        MatchmakingApplicationConfiguration CreateMatchmakingApplicationConfiguration(string applicationNameOrId, MatchmakingApplicationConfiguration matchmakingApplicationConfiguration = default(MatchmakingApplicationConfiguration));

        /// <summary>
        /// Creates a new iOS ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Creates a new iOS ApplicationConfiguration with the specific ID or application.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="matchmakingApplicationConfiguration"> (optional)</param>
        /// <returns>ApiResponse of MatchmakingApplicationConfiguration</returns>
        ApiResponse<MatchmakingApplicationConfiguration> CreateMatchmakingApplicationConfigurationWithHttpInfo(string applicationNameOrId, MatchmakingApplicationConfiguration matchmakingApplicationConfiguration = default(MatchmakingApplicationConfiguration));
        /// <summary>
        /// Creates a new Metadata object
        /// </summary>
        /// <remarks>
        /// Creates a new Metadata object with the provided details.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createMetadataRequest"> (optional)</param>
        /// <returns>Metadata</returns>
        Metadata CreateMetadata(CreateMetadataRequest createMetadataRequest = default(CreateMetadataRequest));

        /// <summary>
        /// Creates a new Metadata object
        /// </summary>
        /// <remarks>
        /// Creates a new Metadata object with the provided details.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createMetadataRequest"> (optional)</param>
        /// <returns>ApiResponse of Metadata</returns>
        ApiResponse<Metadata> CreateMetadataWithHttpInfo(CreateMetadataRequest createMetadataRequest = default(CreateMetadataRequest));
        /// <summary>
        /// Creates a new Metadata Spec definition
        /// </summary>
        /// <remarks>
        /// Creates a new Metadata Spec definition.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createMetadataSpecRequest"> (optional)</param>
        /// <returns>MetadataSpec</returns>
        MetadataSpec CreateMetadataSpec(CreateMetadataSpecRequest createMetadataSpecRequest = default(CreateMetadataSpecRequest));

        /// <summary>
        /// Creates a new Metadata Spec definition
        /// </summary>
        /// <remarks>
        /// Creates a new Metadata Spec definition.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createMetadataSpecRequest"> (optional)</param>
        /// <returns>ApiResponse of MetadataSpec</returns>
        ApiResponse<MetadataSpec> CreateMetadataSpecWithHttpInfo(CreateMetadataSpecRequest createMetadataSpecRequest = default(CreateMetadataSpecRequest));
        /// <summary>
        /// Creates a new mission
        /// </summary>
        /// <remarks>
        /// Supplying a mission object, this will create a new mission with a newly assigned unique id.  The Mission representation returned in the response body is a representation of the Mission as persisted with a unique identifier assigned and with its fields properly normalized.  The supplied mission object submitted with the request must have a name property that is unique across all items.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mission"> (optional)</param>
        /// <returns>Mission</returns>
        Mission CreateMission(Mission mission = default(Mission));

        /// <summary>
        /// Creates a new mission
        /// </summary>
        /// <remarks>
        /// Supplying a mission object, this will create a new mission with a newly assigned unique id.  The Mission representation returned in the response body is a representation of the Mission as persisted with a unique identifier assigned and with its fields properly normalized.  The supplied mission object submitted with the request must have a name property that is unique across all items.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mission"> (optional)</param>
        /// <returns>ApiResponse of Mission</returns>
        ApiResponse<Mission> CreateMissionWithHttpInfo(Mission mission = default(Mission));
        /// <summary>
        /// Creates a Mock Session
        /// </summary>
        /// <remarks>
        /// Begins a session by accepting a mock session request.  The request must be made with an authenticated super-user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mockSessionRequest"> (optional)</param>
        /// <returns>MockSessionCreation</returns>
        MockSessionCreation CreateMockSession(MockSessionRequest mockSessionRequest = default(MockSessionRequest));

        /// <summary>
        /// Creates a Mock Session
        /// </summary>
        /// <remarks>
        /// Begins a session by accepting a mock session request.  The request must be made with an authenticated super-user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mockSessionRequest"> (optional)</param>
        /// <returns>ApiResponse of MockSessionCreation</returns>
        ApiResponse<MockSessionCreation> CreateMockSessionWithHttpInfo(MockSessionRequest mockSessionRequest = default(MockSessionRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="createDeploymentRequest"> (optional)</param>
        /// <returns>Deployment</returns>
        Deployment CreateNewDeployment(string applicationId, CreateDeploymentRequest createDeploymentRequest = default(CreateDeploymentRequest));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="createDeploymentRequest"> (optional)</param>
        /// <returns>ApiResponse of Deployment</returns>
        ApiResponse<Deployment> CreateNewDeploymentWithHttpInfo(string applicationId, CreateDeploymentRequest createDeploymentRequest = default(CreateDeploymentRequest));
        /// <summary>
        /// Creates a Session using OAuth2
        /// </summary>
        /// <remarks>
        /// Begins a session by accepting a session request with parameters matching the specified OAuth2 Scheme. Upon successful validation against the scheme provided in the path, this will return a Session which can be used for authentication. If there is no User associated with the supplied credentials, this will implicitly create a new account and will include that account information in the response. If there is an account, or this method receives an existing session key, this will link to the existing scheme if the account was not previously linked.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2SessionRequest"> (optional)</param>
        /// <returns>SessionCreation</returns>
        SessionCreation CreateOAuth2Session(OAuth2SessionRequest oAuth2SessionRequest = default(OAuth2SessionRequest));

        /// <summary>
        /// Creates a Session using OAuth2
        /// </summary>
        /// <remarks>
        /// Begins a session by accepting a session request with parameters matching the specified OAuth2 Scheme. Upon successful validation against the scheme provided in the path, this will return a Session which can be used for authentication. If there is no User associated with the supplied credentials, this will implicitly create a new account and will include that account information in the response. If there is an account, or this method receives an existing session key, this will link to the existing scheme if the account was not previously linked.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2SessionRequest"> (optional)</param>
        /// <returns>ApiResponse of SessionCreation</returns>
        ApiResponse<SessionCreation> CreateOAuth2SessionWithHttpInfo(OAuth2SessionRequest oAuth2SessionRequest = default(OAuth2SessionRequest));
        /// <summary>
        /// Creates a Session using OIDC
        /// </summary>
        /// <remarks>
        /// Begins a session by accepting a JWT. Upon successful validation against the scheme provided in the path, this will return a Session which can be used for authentication. If there is no User associated with the supplied credentials, this will implicitly create a new account and will include that account information in the response. If there is an account, or this method receives an existing session key, this will link to the existing scheme if the account was not previously linked.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcSessionRequest"> (optional)</param>
        /// <returns>SessionCreation</returns>
        SessionCreation CreateOidcSession(OidcSessionRequest oidcSessionRequest = default(OidcSessionRequest));

        /// <summary>
        /// Creates a Session using OIDC
        /// </summary>
        /// <remarks>
        /// Begins a session by accepting a JWT. Upon successful validation against the scheme provided in the path, this will return a Session which can be used for authentication. If there is no User associated with the supplied credentials, this will implicitly create a new account and will include that account information in the response. If there is an account, or this method receives an existing session key, this will link to the existing scheme if the account was not previously linked.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcSessionRequest"> (optional)</param>
        /// <returns>ApiResponse of SessionCreation</returns>
        ApiResponse<SessionCreation> CreateOidcSessionWithHttpInfo(OidcSessionRequest oidcSessionRequest = default(OidcSessionRequest));
        /// <summary>
        /// Creates a new PSN ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Creates a new PSN ApplicationConfiguration with the specific ID or application.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="pSNApplicationConfiguration"> (optional)</param>
        /// <returns>PSNApplicationConfiguration</returns>
        PSNApplicationConfiguration CreatePSNApplicationConfiguration(string applicationNameOrId, PSNApplicationConfiguration pSNApplicationConfiguration = default(PSNApplicationConfiguration));

        /// <summary>
        /// Creates a new PSN ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Creates a new PSN ApplicationConfiguration with the specific ID or application.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="pSNApplicationConfiguration"> (optional)</param>
        /// <returns>ApiResponse of PSNApplicationConfiguration</returns>
        ApiResponse<PSNApplicationConfiguration> CreatePSNApplicationConfigurationWithHttpInfo(string applicationNameOrId, PSNApplicationConfiguration pSNApplicationConfiguration = default(PSNApplicationConfiguration));
        /// <summary>
        /// Creates a Profile
        /// </summary>
        /// <remarks>
        /// Supplying the create profile request, this will update the profile with the new information supplied in the body of the request. This will fire an event, dev.getelements.elements.service.profile.created, from the event manifest.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createProfileRequest"> (optional)</param>
        /// <returns>Profile</returns>
        Profile CreateProfile(CreateProfileRequest createProfileRequest = default(CreateProfileRequest));

        /// <summary>
        /// Creates a Profile
        /// </summary>
        /// <remarks>
        /// Supplying the create profile request, this will update the profile with the new information supplied in the body of the request. This will fire an event, dev.getelements.elements.service.profile.created, from the event manifest.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createProfileRequest"> (optional)</param>
        /// <returns>ApiResponse of Profile</returns>
        ApiResponse<Profile> CreateProfileWithHttpInfo(CreateProfileRequest createProfileRequest = default(CreateProfileRequest));
        /// <summary>
        /// Creates a new progress
        /// </summary>
        /// <remarks>
        /// Supplying a progress object, this will create a new progress with a newly assigned unique id.  The Progress representation returned in the response body is a representation of the Progress as persisted with a unique identifier assigned and with its fields properly normalized.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progress"> (optional)</param>
        /// <returns>Progress</returns>
        Progress CreateProgress(Progress progress = default(Progress));

        /// <summary>
        /// Creates a new progress
        /// </summary>
        /// <remarks>
        /// Supplying a progress object, this will create a new progress with a newly assigned unique id.  The Progress representation returned in the response body is a representation of the Progress as persisted with a unique identifier assigned and with its fields properly normalized.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progress"> (optional)</param>
        /// <returns>ApiResponse of Progress</returns>
        ApiResponse<Progress> CreateProgressWithHttpInfo(Progress progress = default(Progress));
        /// <summary>
        /// Creates a save data document.
        /// </summary>
        /// <remarks>
        /// Gets a single save data document.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createSaveDataDocumentRequest"> (optional)</param>
        /// <returns>SaveDataDocument</returns>
        SaveDataDocument CreateSaveDocument(CreateSaveDataDocumentRequest createSaveDataDocumentRequest = default(CreateSaveDataDocumentRequest));

        /// <summary>
        /// Creates a save data document.
        /// </summary>
        /// <remarks>
        /// Gets a single save data document.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createSaveDataDocumentRequest"> (optional)</param>
        /// <returns>ApiResponse of SaveDataDocument</returns>
        ApiResponse<SaveDataDocument> CreateSaveDocumentWithHttpInfo(CreateSaveDataDocumentRequest createSaveDataDocumentRequest = default(CreateSaveDataDocumentRequest));
        /// <summary>
        /// Creates a new schedule
        /// </summary>
        /// <remarks>
        /// Supplying a schedule object, this will create a new schedule with a newly assigned unique id.  The Schedule representation returned in the response body is a representation of the Schedule as persisted with a unique identifier assigned and with its fields properly normalized.  The supplied schedule object submitted with the request must have a name property that is unique across all items.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createScheduleRequest"> (optional)</param>
        /// <returns>Schedule</returns>
        Schedule CreateSchedule(CreateScheduleRequest createScheduleRequest = default(CreateScheduleRequest));

        /// <summary>
        /// Creates a new schedule
        /// </summary>
        /// <remarks>
        /// Supplying a schedule object, this will create a new schedule with a newly assigned unique id.  The Schedule representation returned in the response body is a representation of the Schedule as persisted with a unique identifier assigned and with its fields properly normalized.  The supplied schedule object submitted with the request must have a name property that is unique across all items.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createScheduleRequest"> (optional)</param>
        /// <returns>ApiResponse of Schedule</returns>
        ApiResponse<Schedule> CreateScheduleWithHttpInfo(CreateScheduleRequest createScheduleRequest = default(CreateScheduleRequest));
        /// <summary>
        /// Creates a new schedule
        /// </summary>
        /// <remarks>
        /// Supplying a schedule object, this will create a new schedule with a newly assigned unique id.  The ScheduleEvent representation returned in the response body is a representation of the ScheduleEvent as persisted with a unique identifier assigned and with its fields properly normalized.  The supplied schedule object submitted with the request must have a name property that is unique across all items.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="createScheduleEventRequest"> (optional)</param>
        /// <returns>ScheduleEvent</returns>
        ScheduleEvent CreateScheduleEvent(string scheduleNameOrId, CreateScheduleEventRequest createScheduleEventRequest = default(CreateScheduleEventRequest));

        /// <summary>
        /// Creates a new schedule
        /// </summary>
        /// <remarks>
        /// Supplying a schedule object, this will create a new schedule with a newly assigned unique id.  The ScheduleEvent representation returned in the response body is a representation of the ScheduleEvent as persisted with a unique identifier assigned and with its fields properly normalized.  The supplied schedule object submitted with the request must have a name property that is unique across all items.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="createScheduleEventRequest"> (optional)</param>
        /// <returns>ApiResponse of ScheduleEvent</returns>
        ApiResponse<ScheduleEvent> CreateScheduleEventWithHttpInfo(string scheduleNameOrId, CreateScheduleEventRequest createScheduleEventRequest = default(CreateScheduleEventRequest));
        /// <summary>
        /// Creates a New Score
        /// </summary>
        /// <remarks>
        /// Posts a single score for the currently logged-in profile. Conceptually, this is creationg a new resource, however the server may opt to overwrite the existing identifier if it sees fit.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">The name or id of the leaderboard.</param>
        /// <param name="score"> (optional)</param>
        /// <returns>Score</returns>
        Score CreateScore(string leaderboardNameOrId, Score score = default(Score));

        /// <summary>
        /// Creates a New Score
        /// </summary>
        /// <remarks>
        /// Posts a single score for the currently logged-in profile. Conceptually, this is creationg a new resource, however the server may opt to overwrite the existing identifier if it sees fit.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">The name or id of the leaderboard.</param>
        /// <param name="score"> (optional)</param>
        /// <returns>ApiResponse of Score</returns>
        ApiResponse<Score> CreateScoreWithHttpInfo(string leaderboardNameOrId, Score score = default(Score));
        /// <summary>
        /// Create an inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Create an inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createSimpleInventoryItemRequest"> (optional)</param>
        /// <returns>InventoryItem</returns>
        InventoryItem CreateSimpleInventoryItem(CreateSimpleInventoryItemRequest createSimpleInventoryItemRequest = default(CreateSimpleInventoryItemRequest));

        /// <summary>
        /// Create an inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Create an inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createSimpleInventoryItemRequest"> (optional)</param>
        /// <returns>ApiResponse of InventoryItem</returns>
        ApiResponse<InventoryItem> CreateSimpleInventoryItemWithHttpInfo(CreateSimpleInventoryItemRequest createSimpleInventoryItemRequest = default(CreateSimpleInventoryItemRequest));
        /// <summary>
        /// Patches a  Smart Contract
        /// </summary>
        /// <remarks>
        /// Patches a  Smart Contract entry, associated with the specified deployed script hash.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createSmartContractRequest"> (optional)</param>
        /// <returns>SmartContract</returns>
        SmartContract CreateSmartContract(CreateSmartContractRequest createSmartContractRequest = default(CreateSmartContractRequest));

        /// <summary>
        /// Patches a  Smart Contract
        /// </summary>
        /// <remarks>
        /// Patches a  Smart Contract entry, associated with the specified deployed script hash.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createSmartContractRequest"> (optional)</param>
        /// <returns>ApiResponse of SmartContract</returns>
        ApiResponse<SmartContract> CreateSmartContractWithHttpInfo(CreateSmartContractRequest createSmartContractRequest = default(CreateSmartContractRequest));
        /// <summary>
        /// Creates a User
        /// </summary>
        /// <remarks>
        /// Supplying the user object, this will update the user with the new information supplied in the body of the request.  Optionally, the user&#39;s password may be provided in the User object.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userCreateRequest"> (optional)</param>
        /// <returns>UserCreateResponse</returns>
        UserCreateResponse CreateUser(UserCreateRequest userCreateRequest = default(UserCreateRequest));

        /// <summary>
        /// Creates a User
        /// </summary>
        /// <remarks>
        /// Supplying the user object, this will update the user with the new information supplied in the body of the request.  Optionally, the user&#39;s password may be provided in the User object.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userCreateRequest"> (optional)</param>
        /// <returns>ApiResponse of UserCreateResponse</returns>
        ApiResponse<UserCreateResponse> CreateUserWithHttpInfo(UserCreateRequest userCreateRequest = default(UserCreateRequest));
        /// <summary>
        /// Creates a Session
        /// </summary>
        /// <remarks>
        /// Begins a session by accepting both the UserID and the Passoword.  Upon successful completion of this call, the user will be added to the current HTTP session.  If the session expires, the user will have to reestablish the session by supplying credentials again.  This is most useful for applications delivered in a web page.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="usernamePasswordSessionRequest"> (optional)</param>
        /// <returns>SessionCreation</returns>
        SessionCreation CreateUsernamePasswordSession(UsernamePasswordSessionRequest usernamePasswordSessionRequest = default(UsernamePasswordSessionRequest));

        /// <summary>
        /// Creates a Session
        /// </summary>
        /// <remarks>
        /// Begins a session by accepting both the UserID and the Passoword.  Upon successful completion of this call, the user will be added to the current HTTP session.  If the session expires, the user will have to reestablish the session by supplying credentials again.  This is most useful for applications delivered in a web page.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="usernamePasswordSessionRequest"> (optional)</param>
        /// <returns>ApiResponse of SessionCreation</returns>
        ApiResponse<SessionCreation> CreateUsernamePasswordSessionWithHttpInfo(UsernamePasswordSessionRequest usernamePasswordSessionRequest = default(UsernamePasswordSessionRequest));
        /// <summary>
        /// Creates a new  Vault
        /// </summary>
        /// <remarks>
        /// Creates a new  Vault, associated with the given user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createVaultRequest"> (optional)</param>
        /// <returns>Vault</returns>
        Vault CreateVault(CreateVaultRequest createVaultRequest = default(CreateVaultRequest));

        /// <summary>
        /// Creates a new  Vault
        /// </summary>
        /// <remarks>
        /// Creates a new  Vault, associated with the given user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createVaultRequest"> (optional)</param>
        /// <returns>ApiResponse of Vault</returns>
        ApiResponse<Vault> CreateVaultWithHttpInfo(CreateVaultRequest createVaultRequest = default(CreateVaultRequest));
        /// <summary>
        /// Creates a new  Wallet
        /// </summary>
        /// <remarks>
        /// Creates a new  Wallet, associated with the given user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="createWalletRequest"> (optional)</param>
        /// <returns>Wallet</returns>
        Wallet CreateWallet(string vaultId, CreateWalletRequest createWalletRequest = default(CreateWalletRequest));

        /// <summary>
        /// Creates a new  Wallet
        /// </summary>
        /// <remarks>
        /// Creates a new  Wallet, associated with the given user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="createWalletRequest"> (optional)</param>
        /// <returns>ApiResponse of Wallet</returns>
        ApiResponse<Wallet> CreateWalletWithHttpInfo(string vaultId, CreateWalletRequest createWalletRequest = default(CreateWalletRequest));
        /// <summary>
        /// Deletes a Profile
        /// </summary>
        /// <remarks>
        /// Deletes and permanently removes the Profile from the server.  The server maykeep some record around to preserve relationships and references, but this profile will not be accessible again until it is recreated.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <returns></returns>
        void DeactivateProfile(string profileId);

        /// <summary>
        /// Deletes a Profile
        /// </summary>
        /// <remarks>
        /// Deletes and permanently removes the Profile from the server.  The server maykeep some record around to preserve relationships and references, but this profile will not be accessible again until it is recreated.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeactivateProfileWithHttpInfo(string profileId);
        /// <summary>
        /// Deletes a User
        /// </summary>
        /// <remarks>
        /// Deletes and permanently removes the user from the server.  The server may keep some metadata as necessary to avoid data inconsistency.  However, the user has been deleted from the client standpoint and will not be accessible through any of the existing APIs.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <returns></returns>
        void DeactivateUser(string name);

        /// <summary>
        /// Deletes a User
        /// </summary>
        /// <remarks>
        /// Deletes and permanently removes the user from the server.  The server may keep some metadata as necessary to avoid data inconsistency.  However, the user has been deleted from the client standpoint and will not be accessible through any of the existing APIs.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeactivateUserWithHttpInfo(string name);
        /// <summary>
        /// Delete the inventory item as identified by the given item name/id
        /// </summary>
        /// <remarks>
        /// Delete the inventory item as identified by the given item name/id
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <returns></returns>
        void DeleteAdvancedInventoryItem(string inventoryItemId);

        /// <summary>
        /// Delete the inventory item as identified by the given item name/id
        /// </summary>
        /// <remarks>
        /// Delete the inventory item as identified by the given item name/id
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteAdvancedInventoryItemWithHttpInfo(string inventoryItemId);
        /// <summary>
        /// Deletes an Application
        /// </summary>
        /// <remarks>
        /// Deletes a specific application known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <returns></returns>
        void DeleteApplication(string nameOrId);

        /// <summary>
        /// Deletes an Application
        /// </summary>
        /// <remarks>
        /// Deletes a specific application known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteApplicationWithHttpInfo(string nameOrId);
        /// <summary>
        /// Deletes an Auth Scheme
        /// </summary>
        /// <remarks>
        /// Deletes an Auth Scheme with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSchemeId"></param>
        /// <returns></returns>
        void DeleteAuthScheme(string authSchemeId);

        /// <summary>
        /// Deletes an Auth Scheme
        /// </summary>
        /// <remarks>
        /// Deletes an Auth Scheme with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSchemeId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteAuthSchemeWithHttpInfo(string authSchemeId);
        /// <summary>
        /// Deletes an Auth Scheme
        /// </summary>
        /// <remarks>
        /// Deletes an Auth Scheme with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2AuthSchemeId"></param>
        /// <returns></returns>
        void DeleteAuthScheme1(string oAuth2AuthSchemeId);

        /// <summary>
        /// Deletes an Auth Scheme
        /// </summary>
        /// <remarks>
        /// Deletes an Auth Scheme with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2AuthSchemeId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteAuthScheme1WithHttpInfo(string oAuth2AuthSchemeId);
        /// <summary>
        /// Deletes an Auth Scheme
        /// </summary>
        /// <remarks>
        /// Deletes an Auth Scheme with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcAuthSchemeId"></param>
        /// <returns></returns>
        void DeleteAuthScheme2(string oidcAuthSchemeId);

        /// <summary>
        /// Deletes an Auth Scheme
        /// </summary>
        /// <remarks>
        /// Deletes an Auth Scheme with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcAuthSchemeId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteAuthScheme2WithHttpInfo(string oidcAuthSchemeId);
        /// <summary>
        /// Deletes a  Smart Contract
        /// </summary>
        /// <remarks>
        /// Deletes a  Smart Contract with the specified contractId.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractId"></param>
        /// <returns></returns>
        void DeleteContract(string contractId);

        /// <summary>
        /// Deletes a  Smart Contract
        /// </summary>
        /// <remarks>
        /// Deletes a  Smart Contract with the specified contractId.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteContractWithHttpInfo(string contractId);
        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="deploymentId"></param>
        /// <returns></returns>
        void DeleteDeployment(string applicationId, string deploymentId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="deploymentId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteDeploymentWithHttpInfo(string applicationId, string deploymentId);
        /// <summary>
        /// Delete the inventory item as identified by the given item name/id
        /// </summary>
        /// <remarks>
        /// Delete the inventory item as identified by the given item name/id
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="distinctInventoryItemId"></param>
        /// <returns></returns>
        void DeleteDistinctInventoryItem(string distinctInventoryItemId);

        /// <summary>
        /// Delete the inventory item as identified by the given item name/id
        /// </summary>
        /// <remarks>
        /// Delete the inventory item as identified by the given item name/id
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="distinctInventoryItemId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteDistinctInventoryItemWithHttpInfo(string distinctInventoryItemId);
        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fcmRegistrationId"></param>
        /// <returns></returns>
        void DeleteFCMRegistration(string fcmRegistrationId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fcmRegistrationId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteFCMRegistrationWithHttpInfo(string fcmRegistrationId);
        /// <summary>
        /// Deletes a Facebook ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Deletes an existing Facebook Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns></returns>
        void DeleteFacebookApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId);

        /// <summary>
        /// Deletes a Facebook ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Deletes an existing Facebook Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteFacebookApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId);
        /// <summary>
        /// Deletes a Firebase ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Deletes an existing Firebase Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns></returns>
        void DeleteFirebaseApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId);

        /// <summary>
        /// Deletes a Firebase ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Deletes an existing Firebase Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteFirebaseApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId);
        /// <summary>
        /// Deletes a Follower relationship
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="profileToUnfollowId"></param>
        /// <returns></returns>
        void DeleteFollower(string profileId, string profileToUnfollowId);

        /// <summary>
        /// Deletes a Follower relationship
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="profileToUnfollowId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteFollowerWithHttpInfo(string profileId, string profileToUnfollowId);
        /// <summary>
        /// Deletes a Friend
        /// </summary>
        /// <remarks>
        /// Once a friend is deleted, re-creating a friend will set the friendship status to outgoing.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="friendId"></param>
        /// <returns></returns>
        void DeleteFriendRegistration(string friendId);

        /// <summary>
        /// Deletes a Friend
        /// </summary>
        /// <remarks>
        /// Once a friend is deleted, re-creating a friend will set the friendship status to outgoing.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="friendId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteFriendRegistrationWithHttpInfo(string friendId);
        /// <summary>
        /// Deletes a Google Play ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Deletes an existing Google Play Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns></returns>
        void DeleteGooglePlayApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId);

        /// <summary>
        /// Deletes a Google Play ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Deletes an existing Google Play Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteGooglePlayApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId);
        /// <summary>
        /// Deletes a iOS ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Deletes an existing iOS Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns></returns>
        void DeleteIosApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId);

        /// <summary>
        /// Deletes a iOS ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Deletes an existing iOS Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteIosApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId);
        /// <summary>
        /// Deletes a LargeObject
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <returns></returns>
        void DeleteLargeObject(string largeObjectId);

        /// <summary>
        /// Deletes a LargeObject
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteLargeObjectWithHttpInfo(string largeObjectId);
        /// <summary>
        /// Deletes an Leaderboard
        /// </summary>
        /// <remarks>
        /// Deletes a specific leaderboard known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <returns></returns>
        void DeleteLeaderboard(string nameOrId);

        /// <summary>
        /// Deletes an Leaderboard
        /// </summary>
        /// <remarks>
        /// Deletes a specific leaderboard known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteLeaderboardWithHttpInfo(string nameOrId);
        /// <summary>
        /// Deletes a Match
        /// </summary>
        /// <remarks>
        /// Deletes and permanently removes the Match fromt he server.  This effectively will cancel any pending request for a match.  If a game is currently being played agaist the match, the server may reject the request to delete the match until the game concludes.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchId"></param>
        /// <returns></returns>
        void DeleteMatch(string matchId);

        /// <summary>
        /// Deletes a Match
        /// </summary>
        /// <remarks>
        /// Deletes and permanently removes the Match fromt he server.  This effectively will cancel any pending request for a match.  If a game is currently being played agaist the match, the server may reject the request to delete the match until the game concludes.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteMatchWithHttpInfo(string matchId);
        /// <summary>
        /// Deletes a iOS ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Deletes an existing iOS Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns></returns>
        void DeleteMatchmakingApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId);

        /// <summary>
        /// Deletes a iOS ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Deletes an existing iOS Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteMatchmakingApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId);
        /// <summary>
        /// Deletes a specific Metadata object
        /// </summary>
        /// <remarks>
        /// Deletes a specific metadata object by name or id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns></returns>
        void DeleteMetadata(string id);

        /// <summary>
        /// Deletes a specific Metadata object
        /// </summary>
        /// <remarks>
        /// Deletes a specific metadata object by name or id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteMetadataWithHttpInfo(string id);
        /// <summary>
        /// Deletes a MetadataSpec
        /// </summary>
        /// <remarks>
        /// Deletes a MetadataSpec with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecId"></param>
        /// <returns></returns>
        void DeleteMetadataSpec(string metadataSpecId);

        /// <summary>
        /// Deletes a MetadataSpec
        /// </summary>
        /// <remarks>
        /// Deletes a MetadataSpec with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteMetadataSpecWithHttpInfo(string metadataSpecId);
        /// <summary>
        /// Deletes the Mission identified by id or by name
        /// </summary>
        /// <remarks>
        /// Deletes a mission by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="missionNameOrId"></param>
        /// <returns></returns>
        void DeleteMission(string missionNameOrId);

        /// <summary>
        /// Deletes the Mission identified by id or by name
        /// </summary>
        /// <remarks>
        /// Deletes a mission by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="missionNameOrId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteMissionWithHttpInfo(string missionNameOrId);
        /// <summary>
        /// Deletes a PSN ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Deletes an existing PSN Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns></returns>
        void DeletePSNApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId);

        /// <summary>
        /// Deletes a PSN ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Deletes an existing PSN Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeletePSNApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId);
        /// <summary>
        /// Deletes the Progress identified by id
        /// </summary>
        /// <remarks>
        /// Deletes a progress by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progressId"></param>
        /// <returns></returns>
        void DeleteProgress(string progressId);

        /// <summary>
        /// Deletes the Progress identified by id
        /// </summary>
        /// <remarks>
        /// Deletes a progress by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progressId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteProgressWithHttpInfo(string progressId);
        /// <summary>
        /// Deletes a save data document
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="saveDataDocumentId"></param>
        /// <returns></returns>
        void DeleteSaveDocument(string saveDataDocumentId);

        /// <summary>
        /// Deletes a save data document
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="saveDataDocumentId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteSaveDocumentWithHttpInfo(string saveDataDocumentId);
        /// <summary>
        /// Deletes the Schedule identified by id or by name
        /// </summary>
        /// <remarks>
        /// Deletes a schedule by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <returns></returns>
        void DeleteSchedule(string scheduleNameOrId);

        /// <summary>
        /// Deletes the Schedule identified by id or by name
        /// </summary>
        /// <remarks>
        /// Deletes a schedule by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteScheduleWithHttpInfo(string scheduleNameOrId);
        /// <summary>
        /// Deletes the ScheduleEvent identified by id or by name
        /// </summary>
        /// <remarks>
        /// Deletes a schedule by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="scheduleEventId"></param>
        /// <returns></returns>
        void DeleteScheduleEvent(string scheduleNameOrId, string scheduleEventId);

        /// <summary>
        /// Deletes the ScheduleEvent identified by id or by name
        /// </summary>
        /// <remarks>
        /// Deletes a schedule by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="scheduleEventId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteScheduleEventWithHttpInfo(string scheduleNameOrId, string scheduleEventId);
        /// <summary>
        /// Delete the inventory item as identified by the given item name/id
        /// </summary>
        /// <remarks>
        /// Delete the inventory item as identified by the given item name/id
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <returns></returns>
        void DeleteSimpleInventoryItem(string inventoryItemId);

        /// <summary>
        /// Delete the inventory item as identified by the given item name/id
        /// </summary>
        /// <remarks>
        /// Delete the inventory item as identified by the given item name/id
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteSimpleInventoryItemWithHttpInfo(string inventoryItemId);
        /// <summary>
        /// Deletes a  Vault
        /// </summary>
        /// <remarks>
        /// Deletes a  Vault with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <returns></returns>
        void DeleteVault(string vaultId);

        /// <summary>
        /// Deletes a  Vault
        /// </summary>
        /// <remarks>
        /// Deletes a  Vault with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteVaultWithHttpInfo(string vaultId);
        /// <summary>
        /// Deletes a  Wallet
        /// </summary>
        /// <remarks>
        /// Deletes a  Wallet with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="walletId"></param>
        /// <returns></returns>
        void DeleteWallet(string vaultId, string walletId);

        /// <summary>
        /// Deletes a  Wallet
        /// </summary>
        /// <remarks>
        /// Deletes a  Wallet with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="walletId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteWalletWithHttpInfo(string vaultId, string walletId);
        /// <summary>
        /// Generate Client API Code
        /// </summary>
        /// <remarks>
        /// Generates API code for use on the client. Will generate Elements core if no application is specified in the request body.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="codegenRequest"> (optional)</param>
        /// <returns></returns>
        void GenerateCode(CodegenRequest codegenRequest = default(CodegenRequest));

        /// <summary>
        /// Generate Client API Code
        /// </summary>
        /// <remarks>
        /// Generates API code for use on the client. Will generate Elements core if no application is specified in the request body.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="codegenRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> GenerateCodeWithHttpInfo(CodegenRequest codegenRequest = default(CodegenRequest));
        /// <summary>
        /// Gets inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Gets the first (primary) inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <returns>InventoryItem</returns>
        InventoryItem GetAdvancedInventoryItem(string inventoryItemId);

        /// <summary>
        /// Gets inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Gets the first (primary) inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <returns>ApiResponse of InventoryItem</returns>
        ApiResponse<InventoryItem> GetAdvancedInventoryItemWithHttpInfo(string inventoryItemId);
        /// <summary>
        /// Search inventory items
        /// </summary>
        /// <remarks>
        /// Searches all inventory items in the system and returns the metadata for all matches against the given search filter.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationInventoryItem</returns>
        PaginationInventoryItem GetAdvancedInventoryItems(int? offset = default(int?), int? count = default(int?), string userId = default(string), string search = default(string));

        /// <summary>
        /// Search inventory items
        /// </summary>
        /// <remarks>
        /// Searches all inventory items in the system and returns the metadata for all matches against the given search filter.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationInventoryItem</returns>
        ApiResponse<PaginationInventoryItem> GetAdvancedInventoryItemsWithHttpInfo(int? offset = default(int?), int? count = default(int?), string userId = default(string), string search = default(string));
        /// <summary>
        /// Get an Application
        /// </summary>
        /// <remarks>
        /// Gets the metadata for a single application.  This may include more specific details not available in the bulk-get or fetch operation.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <returns>Application</returns>
        Application GetApplication(string nameOrId);

        /// <summary>
        /// Get an Application
        /// </summary>
        /// <remarks>
        /// Gets the metadata for a single application.  This may include more specific details not available in the bulk-get or fetch operation.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <returns>ApiResponse of Application</returns>
        ApiResponse<Application> GetApplicationWithHttpInfo(string nameOrId);
        /// <summary>
        /// Searches application profiles
        /// </summary>
        /// <remarks>
        /// Searches all instances of ApplicationProfiles associated with  the application.  The search query may be a full text search.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationApplicationConfiguration</returns>
        PaginationApplicationConfiguration GetApplicationProfiles(string applicationNameOrId, int? offset = default(int?), int? count = default(int?), string search = default(string));

        /// <summary>
        /// Searches application profiles
        /// </summary>
        /// <remarks>
        /// Searches all instances of ApplicationProfiles associated with  the application.  The search query may be a full text search.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationApplicationConfiguration</returns>
        ApiResponse<PaginationApplicationConfiguration> GetApplicationProfilesWithHttpInfo(string applicationNameOrId, int? offset = default(int?), int? count = default(int?), string search = default(string));
        /// <summary>
        /// Search Applications
        /// </summary>
        /// <remarks>
        /// Performs a full-text search of all applications known to the server.  As with other full-text endpoints this allows for pagination and offset.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationApplication</returns>
        PaginationApplication GetApplications(int? offset = default(int?), int? count = default(int?), string search = default(string));

        /// <summary>
        /// Search Applications
        /// </summary>
        /// <remarks>
        /// Performs a full-text search of all applications known to the server.  As with other full-text endpoints this allows for pagination and offset.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationApplication</returns>
        ApiResponse<PaginationApplication> GetApplicationsWithHttpInfo(int? offset = default(int?), int? count = default(int?), string search = default(string));
        /// <summary>
        /// Gets a specific Auth Scheme
        /// </summary>
        /// <remarks>
        /// Gets a specific Auth Scheme by the authSchemeId.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSchemeId"></param>
        /// <returns>AuthScheme</returns>
        AuthScheme GetAuthScheme(string authSchemeId);

        /// <summary>
        /// Gets a specific Auth Scheme
        /// </summary>
        /// <remarks>
        /// Gets a specific Auth Scheme by the authSchemeId.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSchemeId"></param>
        /// <returns>ApiResponse of AuthScheme</returns>
        ApiResponse<AuthScheme> GetAuthSchemeWithHttpInfo(string authSchemeId);
        /// <summary>
        /// Gets a specific Auth Scheme
        /// </summary>
        /// <remarks>
        /// Gets a specific Auth Scheme by the oAuth2AuthSchemeId.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2AuthSchemeId"></param>
        /// <returns>OAuth2AuthScheme</returns>
        OAuth2AuthScheme GetAuthScheme1(string oAuth2AuthSchemeId);

        /// <summary>
        /// Gets a specific Auth Scheme
        /// </summary>
        /// <remarks>
        /// Gets a specific Auth Scheme by the oAuth2AuthSchemeId.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2AuthSchemeId"></param>
        /// <returns>ApiResponse of OAuth2AuthScheme</returns>
        ApiResponse<OAuth2AuthScheme> GetAuthScheme1WithHttpInfo(string oAuth2AuthSchemeId);
        /// <summary>
        /// Gets a specific Auth Scheme
        /// </summary>
        /// <remarks>
        /// Gets a specific Auth Scheme by the oidcAuthSchemeId.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcAuthSchemeId"></param>
        /// <returns>OidcAuthScheme</returns>
        OidcAuthScheme GetAuthScheme2(string oidcAuthSchemeId);

        /// <summary>
        /// Gets a specific Auth Scheme
        /// </summary>
        /// <remarks>
        /// Gets a specific Auth Scheme by the oidcAuthSchemeId.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcAuthSchemeId"></param>
        /// <returns>ApiResponse of OidcAuthScheme</returns>
        ApiResponse<OidcAuthScheme> GetAuthScheme2WithHttpInfo(string oidcAuthSchemeId);
        /// <summary>
        /// Lists all auth schemes in the system
        /// </summary>
        /// <remarks>
        /// Requires SUPERUSER access. Gets a pagination of Auth Schemes for the given query.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <returns>PaginationAuthScheme</returns>
        PaginationAuthScheme GetAuthSchemes(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>));

        /// <summary>
        /// Lists all auth schemes in the system
        /// </summary>
        /// <remarks>
        /// Requires SUPERUSER access. Gets a pagination of Auth Schemes for the given query.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <returns>ApiResponse of PaginationAuthScheme</returns>
        ApiResponse<PaginationAuthScheme> GetAuthSchemesWithHttpInfo(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>));
        /// <summary>
        /// Lists all auth schemes in the system
        /// </summary>
        /// <remarks>
        /// Requires SUPERUSER access. Gets a pagination of Auth Schemes for the given query.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <returns>PaginationOAuth2AuthScheme</returns>
        PaginationOAuth2AuthScheme GetAuthSchemes1(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>));

        /// <summary>
        /// Lists all auth schemes in the system
        /// </summary>
        /// <remarks>
        /// Requires SUPERUSER access. Gets a pagination of Auth Schemes for the given query.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <returns>ApiResponse of PaginationOAuth2AuthScheme</returns>
        ApiResponse<PaginationOAuth2AuthScheme> GetAuthSchemes1WithHttpInfo(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>));
        /// <summary>
        /// Lists all auth schemes in the system
        /// </summary>
        /// <remarks>
        /// Requires SUPERUSER access. Gets a pagination of Auth Schemes for the given query.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <returns>PaginationOidcAuthScheme</returns>
        PaginationOidcAuthScheme GetAuthSchemes2(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>));

        /// <summary>
        /// Lists all auth schemes in the system
        /// </summary>
        /// <remarks>
        /// Requires SUPERUSER access. Gets a pagination of Auth Schemes for the given query.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <returns>ApiResponse of PaginationOidcAuthScheme</returns>
        ApiResponse<PaginationOidcAuthScheme> GetAuthSchemes2WithHttpInfo(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>));
        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <returns>Deployment</returns>
        Deployment GetCurrentDeployment(string applicationId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <returns>ApiResponse of Deployment</returns>
        ApiResponse<Deployment> GetCurrentDeploymentWithHttpInfo(string applicationId);
        /// <summary>
        /// Gets the current Profile
        /// </summary>
        /// <remarks>
        /// This is a special endpoing which fetches the current Profile based on current auth credentials.  This considers the currently loggged-in Dser as well as the Application or Application Configuration against which the User is operating.  This may not be availble, in which case the appopraite error is rasied.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Profile</returns>
        Profile GetCurrentProfile();

        /// <summary>
        /// Gets the current Profile
        /// </summary>
        /// <remarks>
        /// This is a special endpoing which fetches the current Profile based on current auth credentials.  This considers the currently loggged-in Dser as well as the Application or Application Configuration against which the User is operating.  This may not be availble, in which case the appopraite error is rasied.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of Profile</returns>
        ApiResponse<Profile> GetCurrentProfileWithHttpInfo();
        /// <summary>
        /// Gets the current User
        /// </summary>
        /// <remarks>
        /// A special endpoint used to get the current user for the request.  The current user is typically associated with the session but may be derived any other way.  This is essentially an alias for using GET /user/myUserId
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>User</returns>
        User GetCurrentUser();

        /// <summary>
        /// Gets the current User
        /// </summary>
        /// <remarks>
        /// A special endpoint used to get the current user for the request.  The current user is typically associated with the session but may be derived any other way.  This is essentially an alias for using GET /user/myUserId
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of User</returns>
        ApiResponse<User> GetCurrentUserWithHttpInfo();
        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="deploymentId"></param>
        /// <returns>Deployment</returns>
        Deployment GetDeployment(string applicationId, string deploymentId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="deploymentId"></param>
        /// <returns>ApiResponse of Deployment</returns>
        ApiResponse<Deployment> GetDeploymentWithHttpInfo(string applicationId, string deploymentId);
        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <returns>PaginationDeployment</returns>
        PaginationDeployment GetDeployments(string applicationId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <returns>ApiResponse of PaginationDeployment</returns>
        ApiResponse<PaginationDeployment> GetDeploymentsWithHttpInfo(string applicationId);
        /// <summary>
        /// Gets inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Gets the first (primary) inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <returns>DistinctInventoryItem</returns>
        DistinctInventoryItem GetDistinctInventoryItem(string inventoryItemId);

        /// <summary>
        /// Gets inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Gets the first (primary) inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <returns>ApiResponse of DistinctInventoryItem</returns>
        ApiResponse<DistinctInventoryItem> GetDistinctInventoryItemWithHttpInfo(string inventoryItemId);
        /// <summary>
        /// Search inventory items
        /// </summary>
        /// <remarks>
        /// Searches all inventory items in the system and returns the metadata for all matches against the given search filter.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="profileId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationDistinctInventoryItem</returns>
        PaginationDistinctInventoryItem GetDistinctInventoryItems(int? offset = default(int?), int? count = default(int?), string userId = default(string), string profileId = default(string), string search = default(string));

        /// <summary>
        /// Search inventory items
        /// </summary>
        /// <remarks>
        /// Searches all inventory items in the system and returns the metadata for all matches against the given search filter.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="profileId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationDistinctInventoryItem</returns>
        ApiResponse<PaginationDistinctInventoryItem> GetDistinctInventoryItemsWithHttpInfo(int? offset = default(int?), int? count = default(int?), string userId = default(string), string profileId = default(string), string search = default(string));
        /// <summary>
        /// Gets a specific Metadata Editor Schema
        /// </summary>
        /// <remarks>
        /// Gets a specific Metadata Editor Schema backed by the supplied MetadataSpec by name.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecName"></param>
        /// <returns>EditorSchema</returns>
        EditorSchema GetEditorSchema(string metadataSpecName);

        /// <summary>
        /// Gets a specific Metadata Editor Schema
        /// </summary>
        /// <remarks>
        /// Gets a specific Metadata Editor Schema backed by the supplied MetadataSpec by name.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecName"></param>
        /// <returns>ApiResponse of EditorSchema</returns>
        ApiResponse<EditorSchema> GetEditorSchemaWithHttpInfo(string metadataSpecName);
        /// <summary>
        /// Gets a Facebook Application Configuration
        /// </summary>
        /// <remarks>
        /// Gets a single Facebook application based on unique name or ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>FacebookApplicationConfiguration</returns>
        FacebookApplicationConfiguration GetFacebookApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId);

        /// <summary>
        /// Gets a Facebook Application Configuration
        /// </summary>
        /// <remarks>
        /// Gets a single Facebook application based on unique name or ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>ApiResponse of FacebookApplicationConfiguration</returns>
        ApiResponse<FacebookApplicationConfiguration> GetFacebookApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId);
        /// <summary>
        /// Gets a Firebase Application Configuration
        /// </summary>
        /// <remarks>
        /// Gets a single Firebase application based on unique name or ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>FirebaseApplicationConfiguration</returns>
        FirebaseApplicationConfiguration GetFirebaseApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId);

        /// <summary>
        /// Gets a Firebase Application Configuration
        /// </summary>
        /// <remarks>
        /// Gets a single Firebase application based on unique name or ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>ApiResponse of FirebaseApplicationConfiguration</returns>
        ApiResponse<FirebaseApplicationConfiguration> GetFirebaseApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId);
        /// <summary>
        /// Gets a specific profile using the ID of the profile and followed id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="followedId"></param>
        /// <returns>Profile</returns>
        Profile GetFollower(string profileId, string followedId);

        /// <summary>
        /// Gets a specific profile using the ID of the profile and followed id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="followedId"></param>
        /// <returns>ApiResponse of Profile</returns>
        ApiResponse<Profile> GetFollowerWithHttpInfo(string profileId, string followedId);
        /// <summary>
        /// Search Followers
        /// </summary>
        /// <remarks>
        /// Searches all followers in the system and returning the metadata for all matches against the given profile id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <returns>PaginationProfile</returns>
        PaginationProfile GetFollowers(string profileId, int? offset = default(int?), int? count = default(int?));

        /// <summary>
        /// Search Followers
        /// </summary>
        /// <remarks>
        /// Searches all followers in the system and returning the metadata for all matches against the given profile id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <returns>ApiResponse of PaginationProfile</returns>
        ApiResponse<PaginationProfile> GetFollowersWithHttpInfo(string profileId, int? offset = default(int?), int? count = default(int?));
        /// <summary>
        /// Search Followers
        /// </summary>
        /// <remarks>
        /// Searches all followers in the system and returning the metadata for all matches against the given profile id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <returns>PaginationProfile</returns>
        PaginationProfile GetFollowers1(string profileId, int? offset = default(int?), int? count = default(int?));

        /// <summary>
        /// Search Followers
        /// </summary>
        /// <remarks>
        /// Searches all followers in the system and returning the metadata for all matches against the given profile id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <returns>ApiResponse of PaginationProfile</returns>
        ApiResponse<PaginationProfile> GetFollowers1WithHttpInfo(string profileId, int? offset = default(int?), int? count = default(int?));
        /// <summary>
        /// Gets a Specific Friend
        /// </summary>
        /// <remarks>
        /// Gets a specific friend using the ID of the friend.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="friendId"></param>
        /// <returns>Friend</returns>
        Friend GetFriend(string friendId);

        /// <summary>
        /// Gets a Specific Friend
        /// </summary>
        /// <remarks>
        /// Gets a specific friend using the ID of the friend.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="friendId"></param>
        /// <returns>ApiResponse of Friend</returns>
        ApiResponse<Friend> GetFriendWithHttpInfo(string friendId);
        /// <summary>
        /// Search Friends
        /// </summary>
        /// <remarks>
        /// Searches all friends in the system and returning the metadata for all matches against the given search filter.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationFriend</returns>
        PaginationFriend GetFriends(int? offset = default(int?), int? count = default(int?), string search = default(string));

        /// <summary>
        /// Search Friends
        /// </summary>
        /// <remarks>
        /// Searches all friends in the system and returning the metadata for all matches against the given search filter.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationFriend</returns>
        ApiResponse<PaginationFriend> GetFriendsWithHttpInfo(int? offset = default(int?), int? count = default(int?), string search = default(string));
        /// <summary>
        /// Gets Rank Among all Players
        /// </summary>
        /// <remarks>
        /// Gets the current Profile&#39;s rank among all players for the particular leaderboard.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">Specifies the leaderboard name or ID.</param>
        /// <param name="leaderboardEpoch">Specifies the epoch for the leaderboard. If not provided, the current epoch will be used by default for epochal leaderboards. This value will be ignored for all-time leaderboards. Set this value to 0 to explicitly reference the current epoch (when applicable). (optional)</param>
        /// <returns>TabulationRankRow</returns>
        TabulationRankRow GetGlobalRankTabular(string leaderboardNameOrId, long? leaderboardEpoch = default(long?));

        /// <summary>
        /// Gets Rank Among all Players
        /// </summary>
        /// <remarks>
        /// Gets the current Profile&#39;s rank among all players for the particular leaderboard.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">Specifies the leaderboard name or ID.</param>
        /// <param name="leaderboardEpoch">Specifies the epoch for the leaderboard. If not provided, the current epoch will be used by default for epochal leaderboards. This value will be ignored for all-time leaderboards. Set this value to 0 to explicitly reference the current epoch (when applicable). (optional)</param>
        /// <returns>ApiResponse of TabulationRankRow</returns>
        ApiResponse<TabulationRankRow> GetGlobalRankTabularWithHttpInfo(string leaderboardNameOrId, long? leaderboardEpoch = default(long?));
        /// <summary>
        /// Gets a Google Play Application Configuration
        /// </summary>
        /// <remarks>
        /// Gets a single Google Play application based on unique name or ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>GooglePlayApplicationConfiguration</returns>
        GooglePlayApplicationConfiguration GetGooglePlayApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId);

        /// <summary>
        /// Gets a Google Play Application Configuration
        /// </summary>
        /// <remarks>
        /// Gets a single Google Play application based on unique name or ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>ApiResponse of GooglePlayApplicationConfiguration</returns>
        ApiResponse<GooglePlayApplicationConfiguration> GetGooglePlayApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId);
        /// <summary>
        /// Gets a iOS Application Configuration
        /// </summary>
        /// <remarks>
        /// Gets a single iOS application based on unique name or ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>IosApplicationConfiguration</returns>
        IosApplicationConfiguration GetIosApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId);

        /// <summary>
        /// Gets a iOS Application Configuration
        /// </summary>
        /// <remarks>
        /// Gets a single iOS application based on unique name or ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>ApiResponse of IosApplicationConfiguration</returns>
        ApiResponse<IosApplicationConfiguration> GetIosApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId);
        /// <summary>
        /// Retrieves a single Item by id or by name
        /// </summary>
        /// <remarks>
        /// Looks up an item by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="identifier"></param>
        /// <returns>Item</returns>
        Item GetItemByIdentifier(string identifier);

        /// <summary>
        /// Retrieves a single Item by id or by name
        /// </summary>
        /// <remarks>
        /// Looks up an item by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="identifier"></param>
        /// <returns>ApiResponse of Item</returns>
        ApiResponse<Item> GetItemByIdentifierWithHttpInfo(string identifier);
        /// <summary>
        /// Retrieves all Items
        /// </summary>
        /// <remarks>
        /// Searches all items and returns all matching items, filtered by the passed in search parameters.  If multiple tags are specified, then all items that contain at least one of the passed in tags is returned.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="category"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationItem</returns>
        PaginationItem GetItems(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string category = default(string), string search = default(string));

        /// <summary>
        /// Retrieves all Items
        /// </summary>
        /// <remarks>
        /// Searches all items and returns all matching items, filtered by the passed in search parameters.  If multiple tags are specified, then all items that contain at least one of the passed in tags is returned.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="category"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationItem</returns>
        ApiResponse<PaginationItem> GetItemsWithHttpInfo(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string category = default(string), string search = default(string));
        /// <summary>
        /// Gets a specific JSON Schema
        /// </summary>
        /// <remarks>
        /// Gets a specific JSON Schema backed by the supplied MetadataSpec by name.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecName"></param>
        /// <returns>JsonSchema</returns>
        JsonSchema GetJsonSchema(string metadataSpecName);

        /// <summary>
        /// Gets a specific JSON Schema
        /// </summary>
        /// <remarks>
        /// Gets a specific JSON Schema backed by the supplied MetadataSpec by name.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecName"></param>
        /// <returns>ApiResponse of JsonSchema</returns>
        ApiResponse<JsonSchema> GetJsonSchemaWithHttpInfo(string metadataSpecName);
        /// <summary>
        /// Get a LargeObject
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <returns>LargeObject</returns>
        LargeObject GetLargeObject(string largeObjectId);

        /// <summary>
        /// Get a LargeObject
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <returns>ApiResponse of LargeObject</returns>
        ApiResponse<LargeObject> GetLargeObjectWithHttpInfo(string largeObjectId);
        /// <summary>
        /// Get an Leaderboard
        /// </summary>
        /// <remarks>
        /// Gets the metadata for a single leaderboard.  This may include more specific details not availble in the bulk-get or fetch operation.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <returns>Leaderboard</returns>
        Leaderboard GetLeaderboard(string nameOrId);

        /// <summary>
        /// Get an Leaderboard
        /// </summary>
        /// <remarks>
        /// Gets the metadata for a single leaderboard.  This may include more specific details not availble in the bulk-get or fetch operation.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <returns>ApiResponse of Leaderboard</returns>
        ApiResponse<Leaderboard> GetLeaderboardWithHttpInfo(string nameOrId);
        /// <summary>
        /// Search Leaderboards
        /// </summary>
        /// <remarks>
        /// Performs a full-text search of all leaderboards known to the server.  As with other full-text endpoints this allows for pagination and offset.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationLeaderboard</returns>
        PaginationLeaderboard GetLeaderboards(int? offset = default(int?), int? count = default(int?), string search = default(string));

        /// <summary>
        /// Search Leaderboards
        /// </summary>
        /// <remarks>
        /// Performs a full-text search of all leaderboards known to the server.  As with other full-text endpoints this allows for pagination and offset.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationLeaderboard</returns>
        ApiResponse<PaginationLeaderboard> GetLeaderboardsWithHttpInfo(int? offset = default(int?), int? count = default(int?), string search = default(string));
        /// <summary>
        /// Gets a Specific Match
        /// </summary>
        /// <remarks>
        /// Gets a specific match given the match&#39;s unique ID.  Additionally, it is possible to instruct the API to wait for a period of time before sending the response.  The request will intentionally hang until the requested Match with ID has been updated in the database.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchId"></param>
        /// <param name="socialEngineLongPollTimeout">The maximum amount time the server will wait until a request returns a default set of data for long polling.  Specifying a zero will request that the server wait indefinitely until responding.  Though, the server may enforce a practical upper limit on the amount of time it takes to return.  Omitting this header will prompt the server to treat the request as a normal request. (optional)</param>
        /// <returns>Match</returns>
        Match GetMatch(string matchId, long? socialEngineLongPollTimeout = default(long?));

        /// <summary>
        /// Gets a Specific Match
        /// </summary>
        /// <remarks>
        /// Gets a specific match given the match&#39;s unique ID.  Additionally, it is possible to instruct the API to wait for a period of time before sending the response.  The request will intentionally hang until the requested Match with ID has been updated in the database.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchId"></param>
        /// <param name="socialEngineLongPollTimeout">The maximum amount time the server will wait until a request returns a default set of data for long polling.  Specifying a zero will request that the server wait indefinitely until responding.  Though, the server may enforce a practical upper limit on the amount of time it takes to return.  Omitting this header will prompt the server to treat the request as a normal request. (optional)</param>
        /// <returns>ApiResponse of Match</returns>
        ApiResponse<Match> GetMatchWithHttpInfo(string matchId, long? socialEngineLongPollTimeout = default(long?));
        /// <summary>
        /// Match normalized phone numbers with requested list
        /// </summary>
        /// <remarks>
        /// Both phones from request and from DB are normalized and compared.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="inviteViaPhonesRequest"> (optional)</param>
        /// <returns>InviteViaPhonesResponse</returns>
        InviteViaPhonesResponse GetMatchedUserProfilesWithPhoneNumbers(int? offset = default(int?), int? count = default(int?), InviteViaPhonesRequest inviteViaPhonesRequest = default(InviteViaPhonesRequest));

        /// <summary>
        /// Match normalized phone numbers with requested list
        /// </summary>
        /// <remarks>
        /// Both phones from request and from DB are normalized and compared.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="inviteViaPhonesRequest"> (optional)</param>
        /// <returns>ApiResponse of InviteViaPhonesResponse</returns>
        ApiResponse<InviteViaPhonesResponse> GetMatchedUserProfilesWithPhoneNumbersWithHttpInfo(int? offset = default(int?), int? count = default(int?), InviteViaPhonesRequest inviteViaPhonesRequest = default(InviteViaPhonesRequest));
        /// <summary>
        /// List Matches
        /// </summary>
        /// <remarks>
        /// Lists all matches available.  Under most circumstances, this will requires that a profile be made available to the request.  The server may choose to return an error if no suitable profile can be determined.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationMatch</returns>
        PaginationMatch GetMatches(int? offset = default(int?), int? count = default(int?), string search = default(string));

        /// <summary>
        /// List Matches
        /// </summary>
        /// <remarks>
        /// Lists all matches available.  Under most circumstances, this will requires that a profile be made available to the request.  The server may choose to return an error if no suitable profile can be determined.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationMatch</returns>
        ApiResponse<PaginationMatch> GetMatchesWithHttpInfo(int? offset = default(int?), int? count = default(int?), string search = default(string));
        /// <summary>
        /// Gets a iOS Application Configuration
        /// </summary>
        /// <remarks>
        /// Gets a single iOS application based on unique name or ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>MatchmakingApplicationConfiguration</returns>
        MatchmakingApplicationConfiguration GetMatchmakingApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId);

        /// <summary>
        /// Gets a iOS Application Configuration
        /// </summary>
        /// <remarks>
        /// Gets a single iOS application based on unique name or ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>ApiResponse of MatchmakingApplicationConfiguration</returns>
        ApiResponse<MatchmakingApplicationConfiguration> GetMatchmakingApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId);
        /// <summary>
        /// Gets a specific Metadata object
        /// </summary>
        /// <remarks>
        /// Gets a specific metadata object by name or id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>Metadata</returns>
        Metadata GetMetadataObject(string id);

        /// <summary>
        /// Gets a specific Metadata object
        /// </summary>
        /// <remarks>
        /// Gets a specific metadata object by name or id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>ApiResponse of Metadata</returns>
        ApiResponse<Metadata> GetMetadataObjectWithHttpInfo(string id);
        /// <summary>
        /// Search Metadata
        /// </summary>
        /// <remarks>
        /// Searches all metadata in the system and returning all matches against the given search filter.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationMetadata</returns>
        PaginationMetadata GetMetadataObjects(int? offset = default(int?), int? count = default(int?), string search = default(string));

        /// <summary>
        /// Search Metadata
        /// </summary>
        /// <remarks>
        /// Searches all metadata in the system and returning all matches against the given search filter.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationMetadata</returns>
        ApiResponse<PaginationMetadata> GetMetadataObjectsWithHttpInfo(int? offset = default(int?), int? count = default(int?), string search = default(string));
        /// <summary>
        /// Gets a specific Metadata Spec
        /// </summary>
        /// <remarks>
        /// Gets a specific MetadataSpec by name or Id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecNameOrId"></param>
        /// <returns>MetadataSpec</returns>
        MetadataSpec GetMetadataSpec(string metadataSpecNameOrId);

        /// <summary>
        /// Gets a specific Metadata Spec
        /// </summary>
        /// <remarks>
        /// Gets a specific MetadataSpec by name or Id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecNameOrId"></param>
        /// <returns>ApiResponse of MetadataSpec</returns>
        ApiResponse<MetadataSpec> GetMetadataSpecWithHttpInfo(string metadataSpecNameOrId);
        /// <summary>
        /// Get Metadata Specs
        /// </summary>
        /// <remarks>
        /// Gets a pagination of Metadata Specs for the given query.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <returns>PaginationMetadataSpec</returns>
        PaginationMetadataSpec GetMetadataSpecs(int? offset = default(int?), int? count = default(int?));

        /// <summary>
        /// Get Metadata Specs
        /// </summary>
        /// <remarks>
        /// Gets a pagination of Metadata Specs for the given query.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <returns>ApiResponse of PaginationMetadataSpec</returns>
        ApiResponse<PaginationMetadataSpec> GetMetadataSpecsWithHttpInfo(int? offset = default(int?), int? count = default(int?));
        /// <summary>
        /// Retrieves a single Mission by id or by name
        /// </summary>
        /// <remarks>
        /// Looks up a mission by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="missionNameOrId"></param>
        /// <returns>Mission</returns>
        Mission GetMissionByNameOrId(string missionNameOrId);

        /// <summary>
        /// Retrieves a single Mission by id or by name
        /// </summary>
        /// <remarks>
        /// Looks up a mission by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="missionNameOrId"></param>
        /// <returns>ApiResponse of Mission</returns>
        ApiResponse<Mission> GetMissionByNameOrIdWithHttpInfo(string missionNameOrId);
        /// <summary>
        /// Search Missions
        /// </summary>
        /// <remarks>
        /// Searches all missions in the system and returning a number of matches against the given search filter, delimited by the offset and count.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationMission</returns>
        PaginationMission GetMissions(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string search = default(string));

        /// <summary>
        /// Search Missions
        /// </summary>
        /// <remarks>
        /// Searches all missions in the system and returning a number of matches against the given search filter, delimited by the offset and count.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationMission</returns>
        ApiResponse<PaginationMission> GetMissionsWithHttpInfo(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string search = default(string));
        /// <summary>
        /// Gets a PSN Application Configuration
        /// </summary>
        /// <remarks>
        /// Gets a single PSN application based on unique name or ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>PSNApplicationConfiguration</returns>
        PSNApplicationConfiguration GetPSNApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId);

        /// <summary>
        /// Gets a PSN Application Configuration
        /// </summary>
        /// <remarks>
        /// Gets a single PSN application based on unique name or ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>ApiResponse of PSNApplicationConfiguration</returns>
        ApiResponse<PSNApplicationConfiguration> GetPSNApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId);
        /// <summary>
        /// Gets all index plans.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <returns>PaginationIndexPlanObject</returns>
        PaginationIndexPlanObject GetPlans(int? offset = default(int?), int? count = default(int?));

        /// <summary>
        /// Gets all index plans.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <returns>ApiResponse of PaginationIndexPlanObject</returns>
        ApiResponse<PaginationIndexPlanObject> GetPlansWithHttpInfo(int? offset = default(int?), int? count = default(int?));
        /// <summary>
        /// Gets a Specific Profile
        /// </summary>
        /// <remarks>
        /// Gets a specific profile by profile ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <returns>Profile</returns>
        Profile GetProfile(string name);

        /// <summary>
        /// Gets a Specific Profile
        /// </summary>
        /// <remarks>
        /// Gets a specific profile by profile ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <returns>ApiResponse of Profile</returns>
        ApiResponse<Profile> GetProfileWithHttpInfo(string name);
        /// <summary>
        /// Get save data document.
        /// </summary>
        /// <remarks>
        /// Gets a single save data document based on Profile ID and slot. This is a convenience method whichallows the client to fetch a save data based on slot an profile id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="slot"></param>
        /// <returns>SaveDataDocument</returns>
        SaveDataDocument GetProfileSaveDataDocumentBySlot(string profileId, int slot);

        /// <summary>
        /// Get save data document.
        /// </summary>
        /// <remarks>
        /// Gets a single save data document based on Profile ID and slot. This is a convenience method whichallows the client to fetch a save data based on slot an profile id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="slot"></param>
        /// <returns>ApiResponse of SaveDataDocument</returns>
        ApiResponse<SaveDataDocument> GetProfileSaveDataDocumentBySlotWithHttpInfo(string profileId, int slot);
        /// <summary>
        /// Search Profiles
        /// </summary>
        /// <remarks>
        /// Searches all users in the system and returning the metadata for all matches against the given search filter. Optionally provide &#x60;before&#x60; and &#x60;after&#x60; params to specify a time range [&#x60;after&#x60;, &#x60;before&#x60;] for last-logged-in profiles matching in that range (inclusive). If &#x60;before&#x60; is not specified (or a negative number is provided) but &#x60;after&#x60; is valid, the query will return all records successive to the given &#x60;after&#x60; timestamp. Similarly, if &#x60;after&#x60; is not specified (or a negative number is provided) but &#x60;before&#x60; is valid, the query will return all records preceding the given &#x60;before&#x60; timestamp. Note that search and time range parameters currently cannot be combined in the same query.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="before"> (optional)</param>
        /// <param name="after"> (optional)</param>
        /// <param name="application"> (optional)</param>
        /// <param name="user"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationProfile</returns>
        PaginationProfile GetProfiles(int? offset = default(int?), int? count = default(int?), long? before = default(long?), long? after = default(long?), string application = default(string), string user = default(string), string search = default(string));

        /// <summary>
        /// Search Profiles
        /// </summary>
        /// <remarks>
        /// Searches all users in the system and returning the metadata for all matches against the given search filter. Optionally provide &#x60;before&#x60; and &#x60;after&#x60; params to specify a time range [&#x60;after&#x60;, &#x60;before&#x60;] for last-logged-in profiles matching in that range (inclusive). If &#x60;before&#x60; is not specified (or a negative number is provided) but &#x60;after&#x60; is valid, the query will return all records successive to the given &#x60;after&#x60; timestamp. Similarly, if &#x60;after&#x60; is not specified (or a negative number is provided) but &#x60;before&#x60; is valid, the query will return all records preceding the given &#x60;before&#x60; timestamp. Note that search and time range parameters currently cannot be combined in the same query.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="before"> (optional)</param>
        /// <param name="after"> (optional)</param>
        /// <param name="application"> (optional)</param>
        /// <param name="user"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationProfile</returns>
        ApiResponse<PaginationProfile> GetProfilesWithHttpInfo(int? offset = default(int?), int? count = default(int?), long? before = default(long?), long? after = default(long?), string application = default(string), string user = default(string), string search = default(string));
        /// <summary>
        /// Retrieves a single Progress by id
        /// </summary>
        /// <remarks>
        /// Looks up a progress by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progressId"></param>
        /// <returns>Progress</returns>
        Progress GetProgressByNameOrId(string progressId);

        /// <summary>
        /// Retrieves a single Progress by id
        /// </summary>
        /// <remarks>
        /// Looks up a progress by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progressId"></param>
        /// <returns>ApiResponse of Progress</returns>
        ApiResponse<Progress> GetProgressByNameOrIdWithHttpInfo(string progressId);
        /// <summary>
        /// Gets Rank Among all Players
        /// </summary>
        /// <remarks>
        /// Gets the current Profile&#39;s rank among all players for the particular leaderboard.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>TabulationProgressRow</returns>
        TabulationProgressRow GetProgressTabular();

        /// <summary>
        /// Gets Rank Among all Players
        /// </summary>
        /// <remarks>
        /// Gets the current Profile&#39;s rank among all players for the particular leaderboard.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of TabulationProgressRow</returns>
        ApiResponse<TabulationProgressRow> GetProgressTabularWithHttpInfo();
        /// <summary>
        /// Gets Rank among Friends
        /// </summary>
        /// <remarks>
        /// Gets the current Profile&#39;s rank among friends for the particular leaderboard.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">Specifies the leaderboard name or ID.</param>
        /// <param name="offset">May be negative to place the requested player in the middle of the page. (optional)</param>
        /// <param name="count">The number of results to return in the page. (optional)</param>
        /// <param name="relative">Indicates whether or not to fetch results in a relative fashion. (optional)</param>
        /// <param name="leaderboardEpoch">Specifies the epoch for the leaderboard. If no value is provided, the current epoch will befetched. (optional)</param>
        /// <returns>PaginationRank</returns>
        PaginationRank GetRankAmongFriends(string leaderboardNameOrId, int? offset = default(int?), int? count = default(int?), bool? relative = default(bool?), long? leaderboardEpoch = default(long?));

        /// <summary>
        /// Gets Rank among Friends
        /// </summary>
        /// <remarks>
        /// Gets the current Profile&#39;s rank among friends for the particular leaderboard.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">Specifies the leaderboard name or ID.</param>
        /// <param name="offset">May be negative to place the requested player in the middle of the page. (optional)</param>
        /// <param name="count">The number of results to return in the page. (optional)</param>
        /// <param name="relative">Indicates whether or not to fetch results in a relative fashion. (optional)</param>
        /// <param name="leaderboardEpoch">Specifies the epoch for the leaderboard. If no value is provided, the current epoch will befetched. (optional)</param>
        /// <returns>ApiResponse of PaginationRank</returns>
        ApiResponse<PaginationRank> GetRankAmongFriendsWithHttpInfo(string leaderboardNameOrId, int? offset = default(int?), int? count = default(int?), bool? relative = default(bool?), long? leaderboardEpoch = default(long?));
        /// <summary>
        /// Gets Rank among Mutual Followers
        /// </summary>
        /// <remarks>
        /// Gets the current Profile&#39;s rank among mutual followers for the particular leaderboard.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">Specifies the leaderboard name or ID.</param>
        /// <param name="offset">May be negative to place the requested player in the middle of the page. (optional)</param>
        /// <param name="count">The number of results to return in the page. (optional)</param>
        /// <param name="relative">Indicates whether or not to fetch results in a relative fashion. (optional)</param>
        /// <param name="leaderboardEpoch">Specifies the epoch for the leaderboard. If no value is provided, the current epoch will befetched. (optional)</param>
        /// <returns>PaginationRank</returns>
        PaginationRank GetRankAmongMutualFollowers(string leaderboardNameOrId, int? offset = default(int?), int? count = default(int?), bool? relative = default(bool?), long? leaderboardEpoch = default(long?));

        /// <summary>
        /// Gets Rank among Mutual Followers
        /// </summary>
        /// <remarks>
        /// Gets the current Profile&#39;s rank among mutual followers for the particular leaderboard.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">Specifies the leaderboard name or ID.</param>
        /// <param name="offset">May be negative to place the requested player in the middle of the page. (optional)</param>
        /// <param name="count">The number of results to return in the page. (optional)</param>
        /// <param name="relative">Indicates whether or not to fetch results in a relative fashion. (optional)</param>
        /// <param name="leaderboardEpoch">Specifies the epoch for the leaderboard. If no value is provided, the current epoch will befetched. (optional)</param>
        /// <returns>ApiResponse of PaginationRank</returns>
        ApiResponse<PaginationRank> GetRankAmongMutualFollowersWithHttpInfo(string leaderboardNameOrId, int? offset = default(int?), int? count = default(int?), bool? relative = default(bool?), long? leaderboardEpoch = default(long?));
        /// <summary>
        /// Retrieves a single RewardIssuance by id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rewardIssuanceId"></param>
        /// <returns>RewardIssuance</returns>
        RewardIssuance GetRewardIssuance(string rewardIssuanceId);

        /// <summary>
        /// Retrieves a single RewardIssuance by id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rewardIssuanceId"></param>
        /// <returns>ApiResponse of RewardIssuance</returns>
        ApiResponse<RewardIssuance> GetRewardIssuanceWithHttpInfo(string rewardIssuanceId);
        /// <summary>
        /// Retrieves the current user&#39;s reward issuances, optionally filtered by the given state.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="states"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <returns>PaginationRewardIssuance</returns>
        PaginationRewardIssuance GetRewardIssuances(int? offset = default(int?), int? count = default(int?), List<string> states = default(List<string>), List<string> tags = default(List<string>));

        /// <summary>
        /// Retrieves the current user&#39;s reward issuances, optionally filtered by the given state.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="states"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <returns>ApiResponse of PaginationRewardIssuance</returns>
        ApiResponse<PaginationRewardIssuance> GetRewardIssuancesWithHttpInfo(int? offset = default(int?), int? count = default(int?), List<string> states = default(List<string>), List<string> tags = default(List<string>));
        /// <summary>
        /// Get save data document.
        /// </summary>
        /// <remarks>
        /// Gets a single save data document
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>SaveDataDocument</returns>
        SaveDataDocument GetSaveDataDocument(string id);

        /// <summary>
        /// Get save data document.
        /// </summary>
        /// <remarks>
        /// Gets a single save data document
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>ApiResponse of SaveDataDocument</returns>
        ApiResponse<SaveDataDocument> GetSaveDataDocumentWithHttpInfo(string id);
        /// <summary>
        /// Search Save Data Documents
        /// </summary>
        /// <remarks>
        /// Gets all save data documents available to the user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="profileId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationSaveDataDocument</returns>
        PaginationSaveDataDocument GetSaveDataDocuments(int? offset = default(int?), int? count = default(int?), string userId = default(string), string profileId = default(string), string search = default(string));

        /// <summary>
        /// Search Save Data Documents
        /// </summary>
        /// <remarks>
        /// Gets all save data documents available to the user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="profileId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationSaveDataDocument</returns>
        ApiResponse<PaginationSaveDataDocument> GetSaveDataDocumentsWithHttpInfo(int? offset = default(int?), int? count = default(int?), string userId = default(string), string profileId = default(string), string search = default(string));
        /// <summary>
        /// Retrieves a single Schedule by id or by name
        /// </summary>
        /// <remarks>
        /// Looks up a schedule by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <returns>Schedule</returns>
        Schedule GetScheduleByNameOrId(string scheduleNameOrId);

        /// <summary>
        /// Retrieves a single Schedule by id or by name
        /// </summary>
        /// <remarks>
        /// Looks up a schedule by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <returns>ApiResponse of Schedule</returns>
        ApiResponse<Schedule> GetScheduleByNameOrIdWithHttpInfo(string scheduleNameOrId);
        /// <summary>
        /// Retrieves a single ScheduleEvent by id or by name
        /// </summary>
        /// <remarks>
        /// Looks up a schedule by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="scheduleEventId"></param>
        /// <returns>ScheduleEvent</returns>
        ScheduleEvent GetScheduleEventByNameOrId(string scheduleNameOrId, string scheduleEventId);

        /// <summary>
        /// Retrieves a single ScheduleEvent by id or by name
        /// </summary>
        /// <remarks>
        /// Looks up a schedule by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="scheduleEventId"></param>
        /// <returns>ApiResponse of ScheduleEvent</returns>
        ApiResponse<ScheduleEvent> GetScheduleEventByNameOrIdWithHttpInfo(string scheduleNameOrId, string scheduleEventId);
        /// <summary>
        /// Search ScheduleEvents
        /// </summary>
        /// <remarks>
        /// Searches all schedules in the system and returning a number of matches against the given search filter, delimited by the offset and count.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationScheduleEvent</returns>
        PaginationScheduleEvent GetScheduleEvents(string scheduleNameOrId, int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string search = default(string));

        /// <summary>
        /// Search ScheduleEvents
        /// </summary>
        /// <remarks>
        /// Searches all schedules in the system and returning a number of matches against the given search filter, delimited by the offset and count.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationScheduleEvent</returns>
        ApiResponse<PaginationScheduleEvent> GetScheduleEventsWithHttpInfo(string scheduleNameOrId, int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string search = default(string));
        /// <summary>
        /// Gets all Progresses assigned via this schedule
        /// </summary>
        /// <remarks>
        /// Fetches all current assignments to the currently logged-in profile.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <returns>PaginationProgress</returns>
        PaginationProgress GetScheduleProgresses(string scheduleNameOrId, int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>));

        /// <summary>
        /// Gets all Progresses assigned via this schedule
        /// </summary>
        /// <remarks>
        /// Fetches all current assignments to the currently logged-in profile.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <returns>ApiResponse of PaginationProgress</returns>
        ApiResponse<PaginationProgress> GetScheduleProgressesWithHttpInfo(string scheduleNameOrId, int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>));
        /// <summary>
        /// Search Schedules
        /// </summary>
        /// <remarks>
        /// Searches all schedules in the system and returning a number of matches against the given search filter, delimited by the offset and count.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationSchedule</returns>
        PaginationSchedule GetSchedules(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string search = default(string));

        /// <summary>
        /// Search Schedules
        /// </summary>
        /// <remarks>
        /// Searches all schedules in the system and returning a number of matches against the given search filter, delimited by the offset and count.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationSchedule</returns>
        ApiResponse<PaginationSchedule> GetSchedulesWithHttpInfo(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string search = default(string));
        /// <summary>
        /// Performs the health check.
        /// </summary>
        /// <remarks>
        /// Performs the health check for the server. What this actually does is deployment and implementation specific. However, any successful response code should indicate that the service is capable of servicing requests. Any unsuccessful error codes should indicate that the instance has internal issues and should be taken offline.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>HealthStatus</returns>
        HealthStatus GetServerHealth();

        /// <summary>
        /// Performs the health check.
        /// </summary>
        /// <remarks>
        /// Performs the health check for the server. What this actually does is deployment and implementation specific. However, any successful response code should indicate that the service is capable of servicing requests. Any unsuccessful error codes should indicate that the instance has internal issues and should be taken offline.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of HealthStatus</returns>
        ApiResponse<HealthStatus> GetServerHealthWithHttpInfo();
        /// <summary>
        /// Gets inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Gets the first (primary) inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <returns>InventoryItem</returns>
        InventoryItem GetSimpleInventoryItem(string inventoryItemId);

        /// <summary>
        /// Gets inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Gets the first (primary) inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <returns>ApiResponse of InventoryItem</returns>
        ApiResponse<InventoryItem> GetSimpleInventoryItemWithHttpInfo(string inventoryItemId);
        /// <summary>
        /// Search inventory items
        /// </summary>
        /// <remarks>
        /// Searches all inventory items in the system and returns the metadata for all matches against the given search filter.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationInventoryItem</returns>
        PaginationInventoryItem GetSimpleInventoryItems(int? offset = default(int?), int? count = default(int?), string userId = default(string), string search = default(string));

        /// <summary>
        /// Search inventory items
        /// </summary>
        /// <remarks>
        /// Searches all inventory items in the system and returns the metadata for all matches against the given search filter.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationInventoryItem</returns>
        ApiResponse<PaginationInventoryItem> GetSimpleInventoryItemsWithHttpInfo(int? offset = default(int?), int? count = default(int?), string userId = default(string), string search = default(string));
        /// <summary>
        /// Gets a specific  Smart Contract
        /// </summary>
        /// <remarks>
        /// Gets a specific  Smart Contract by contractId.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractId"></param>
        /// <returns>SmartContract</returns>
        SmartContract GetSmartContract(string contractId);

        /// <summary>
        /// Gets a specific  Smart Contract
        /// </summary>
        /// <remarks>
        /// Gets a specific  Smart Contract by contractId.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractId"></param>
        /// <returns>ApiResponse of SmartContract</returns>
        ApiResponse<SmartContract> GetSmartContractWithHttpInfo(string contractId);
        /// <summary>
        /// Gets  contracts.
        /// </summary>
        /// <remarks>
        /// Gets a pagination of  SmartContracts.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="api"> (optional)</param>
        /// <param name="network"> (optional)</param>
        /// <returns>PaginationSmartContract</returns>
        PaginationSmartContract GetSmartContracts(int? offset = default(int?), int? count = default(int?), string api = default(string), List<string> network = default(List<string>));

        /// <summary>
        /// Gets  contracts.
        /// </summary>
        /// <remarks>
        /// Gets a pagination of  SmartContracts.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="api"> (optional)</param>
        /// <param name="network"> (optional)</param>
        /// <returns>ApiResponse of PaginationSmartContract</returns>
        ApiResponse<PaginationSmartContract> GetSmartContractsWithHttpInfo(int? offset = default(int?), int? count = default(int?), string api = default(string), List<string> network = default(List<string>));
        /// <summary>
        /// Gets a Specific User
        /// </summary>
        /// <remarks>
        /// Gets a specific user by name, email, or unique user ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <returns>User</returns>
        User GetUser(string name);

        /// <summary>
        /// Gets a Specific User
        /// </summary>
        /// <remarks>
        /// Gets a specific user by name, email, or unique user ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <returns>ApiResponse of User</returns>
        ApiResponse<User> GetUserWithHttpInfo(string name);
        /// <summary>
        /// Get save data document.
        /// </summary>
        /// <remarks>
        /// Gets a single save data document based on UserID and slot. This is a convenience method whichallows the client to fetch a save data based on slot an user id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="slot"></param>
        /// <returns>SaveDataDocument</returns>
        SaveDataDocument GetUserSaveDataDocumentBySlot(string userId, int slot);

        /// <summary>
        /// Get save data document.
        /// </summary>
        /// <remarks>
        /// Gets a single save data document based on UserID and slot. This is a convenience method whichallows the client to fetch a save data based on slot an user id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="slot"></param>
        /// <returns>ApiResponse of SaveDataDocument</returns>
        ApiResponse<SaveDataDocument> GetUserSaveDataDocumentBySlotWithHttpInfo(string userId, int slot);
        /// <summary>
        /// Search Users
        /// </summary>
        /// <remarks>
        /// Searches all users in the system and returning the metadata for all matches against the given search filter.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationUser</returns>
        PaginationUser GetUsers(int? offset = default(int?), int? count = default(int?), string search = default(string));

        /// <summary>
        /// Search Users
        /// </summary>
        /// <remarks>
        /// Searches all users in the system and returning the metadata for all matches against the given search filter.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationUser</returns>
        ApiResponse<PaginationUser> GetUsersWithHttpInfo(int? offset = default(int?), int? count = default(int?), string search = default(string));
        /// <summary>
        /// Gets a specific  Vault
        /// </summary>
        /// <remarks>
        /// Gets a specific  Vault by Id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <returns>Vault</returns>
        Vault GetVault(string vaultId);

        /// <summary>
        /// Gets a specific  Vault
        /// </summary>
        /// <remarks>
        /// Gets a specific  Vault by Id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <returns>ApiResponse of Vault</returns>
        ApiResponse<Vault> GetVaultWithHttpInfo(string vaultId);
        /// <summary>
        /// Gets  vaults. Optionally filtered for a specific user
        /// </summary>
        /// <remarks>
        /// Gets a pagination of  Wallets. Optionally a user Id can be specified to filter for a given user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <returns>PaginationVault</returns>
        PaginationVault GetVaults(int? offset = default(int?), int? count = default(int?), string userId = default(string));

        /// <summary>
        /// Gets  vaults. Optionally filtered for a specific user
        /// </summary>
        /// <remarks>
        /// Gets a pagination of  Wallets. Optionally a user Id can be specified to filter for a given user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <returns>ApiResponse of PaginationVault</returns>
        ApiResponse<PaginationVault> GetVaultsWithHttpInfo(int? offset = default(int?), int? count = default(int?), string userId = default(string));
        /// <summary>
        /// Show Server Version Information
        /// </summary>
        /// <remarks>
        /// Returns information about the current server version.  This should always return theversion metadata.  This information is only known in packaged releases.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ModelVersion</returns>
        ModelVersion GetVersion();

        /// <summary>
        /// Show Server Version Information
        /// </summary>
        /// <remarks>
        /// Returns information about the current server version.  This should always return theversion metadata.  This information is only known in packaged releases.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of ModelVersion</returns>
        ApiResponse<ModelVersion> GetVersionWithHttpInfo();
        /// <summary>
        /// Gets a specific  Wallet
        /// </summary>
        /// <remarks>
        /// Gets a specific  Wallet by Id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="walletId"></param>
        /// <returns>Wallet</returns>
        Wallet GetWallet(string vaultId, string walletId);

        /// <summary>
        /// Gets a specific  Wallet
        /// </summary>
        /// <remarks>
        /// Gets a specific  Wallet by Id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="walletId"></param>
        /// <returns>ApiResponse of Wallet</returns>
        ApiResponse<Wallet> GetWalletWithHttpInfo(string vaultId, string walletId);
        /// <summary>
        /// Gets a specific  Wallet
        /// </summary>
        /// <remarks>
        /// Gets a specific  Wallet by Id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="walletId"></param>
        /// <returns>Wallet</returns>
        Wallet GetWallet1(string walletId);

        /// <summary>
        /// Gets a specific  Wallet
        /// </summary>
        /// <remarks>
        /// Gets a specific  Wallet by Id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="walletId"></param>
        /// <returns>ApiResponse of Wallet</returns>
        ApiResponse<Wallet> GetWallet1WithHttpInfo(string walletId);
        /// <summary>
        /// Gets  wallets. Optionally filtered for a specific user
        /// </summary>
        /// <remarks>
        /// Gets a pagination of  Wallets. Optionally a user Id can be specified to filter for a given user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="api"> (optional)</param>
        /// <param name="network"> (optional)</param>
        /// <returns>PaginationWallet</returns>
        PaginationWallet GetWallets(string vaultId, int? offset = default(int?), int? count = default(int?), string userId = default(string), string api = default(string), List<string> network = default(List<string>));

        /// <summary>
        /// Gets  wallets. Optionally filtered for a specific user
        /// </summary>
        /// <remarks>
        /// Gets a pagination of  Wallets. Optionally a user Id can be specified to filter for a given user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="api"> (optional)</param>
        /// <param name="network"> (optional)</param>
        /// <returns>ApiResponse of PaginationWallet</returns>
        ApiResponse<PaginationWallet> GetWalletsWithHttpInfo(string vaultId, int? offset = default(int?), int? count = default(int?), string userId = default(string), string api = default(string), List<string> network = default(List<string>));
        /// <summary>
        /// Redeems the RewardIssuance.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rewardIssuanceId"></param>
        /// <returns>RewardIssuanceRedemptionResult</returns>
        RewardIssuanceRedemptionResult RedeemRewardIssuance(string rewardIssuanceId);

        /// <summary>
        /// Redeems the RewardIssuance.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rewardIssuanceId"></param>
        /// <returns>ApiResponse of RewardIssuanceRedemptionResult</returns>
        ApiResponse<RewardIssuanceRedemptionResult> RedeemRewardIssuanceWithHttpInfo(string rewardIssuanceId);
        /// <summary>
        /// Redeems the given list of RewardIssuances.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>List&lt;RewardIssuanceRedemptionResult&gt;</returns>
        List<RewardIssuanceRedemptionResult> RedeemRewardIssuances(List<string> requestBody = default(List<string>));

        /// <summary>
        /// Redeems the given list of RewardIssuances.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>ApiResponse of List&lt;RewardIssuanceRedemptionResult&gt;</returns>
        ApiResponse<List<RewardIssuanceRedemptionResult>> RedeemRewardIssuancesWithHttpInfo(List<string> requestBody = default(List<string>));
        /// <summary>
        /// Sign Up a User
        /// </summary>
        /// <remarks>
        /// Supplying the user create request object, this will create a new user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userCreateRequest"> (optional)</param>
        /// <returns>UserCreateResponse</returns>
        UserCreateResponse SignUpUser(UserCreateRequest userCreateRequest = default(UserCreateRequest));

        /// <summary>
        /// Sign Up a User
        /// </summary>
        /// <remarks>
        /// Supplying the user create request object, this will create a new user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userCreateRequest"> (optional)</param>
        /// <returns>ApiResponse of UserCreateResponse</returns>
        ApiResponse<UserCreateResponse> SignUpUserWithHttpInfo(UserCreateRequest userCreateRequest = default(UserCreateRequest));
        /// <summary>
        /// Updates an Application
        /// </summary>
        /// <remarks>
        /// Performs an update to an existing application known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="updateApplicationRequest"> (optional)</param>
        /// <returns>Application</returns>
        Application UpdateApplication(string nameOrId, UpdateApplicationRequest updateApplicationRequest = default(UpdateApplicationRequest));

        /// <summary>
        /// Updates an Application
        /// </summary>
        /// <remarks>
        /// Performs an update to an existing application known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="updateApplicationRequest"> (optional)</param>
        /// <returns>ApiResponse of Application</returns>
        ApiResponse<Application> UpdateApplicationWithHttpInfo(string nameOrId, UpdateApplicationRequest updateApplicationRequest = default(UpdateApplicationRequest));
        /// <summary>
        /// Updates an Auth Scheme
        /// </summary>
        /// <remarks>
        /// Updates an Auth Scheme with the specified data in the auth scheme request.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSchemeId"></param>
        /// <param name="updateAuthSchemeRequest"> (optional)</param>
        /// <returns>UpdateAuthSchemeResponse</returns>
        UpdateAuthSchemeResponse UpdateAuthScheme(string authSchemeId, UpdateAuthSchemeRequest updateAuthSchemeRequest = default(UpdateAuthSchemeRequest));

        /// <summary>
        /// Updates an Auth Scheme
        /// </summary>
        /// <remarks>
        /// Updates an Auth Scheme with the specified data in the auth scheme request.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSchemeId"></param>
        /// <param name="updateAuthSchemeRequest"> (optional)</param>
        /// <returns>ApiResponse of UpdateAuthSchemeResponse</returns>
        ApiResponse<UpdateAuthSchemeResponse> UpdateAuthSchemeWithHttpInfo(string authSchemeId, UpdateAuthSchemeRequest updateAuthSchemeRequest = default(UpdateAuthSchemeRequest));
        /// <summary>
        /// Updates an Auth Scheme
        /// </summary>
        /// <remarks>
        /// Updates an Auth Scheme with the specified data in the auth scheme request.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2AuthSchemeId"></param>
        /// <param name="createOrUpdateOAuth2AuthSchemeRequest"> (optional)</param>
        /// <returns>CreateOrUpdateOAuth2AuthSchemeResponse</returns>
        CreateOrUpdateOAuth2AuthSchemeResponse UpdateAuthScheme1(string oAuth2AuthSchemeId, CreateOrUpdateOAuth2AuthSchemeRequest createOrUpdateOAuth2AuthSchemeRequest = default(CreateOrUpdateOAuth2AuthSchemeRequest));

        /// <summary>
        /// Updates an Auth Scheme
        /// </summary>
        /// <remarks>
        /// Updates an Auth Scheme with the specified data in the auth scheme request.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2AuthSchemeId"></param>
        /// <param name="createOrUpdateOAuth2AuthSchemeRequest"> (optional)</param>
        /// <returns>ApiResponse of CreateOrUpdateOAuth2AuthSchemeResponse</returns>
        ApiResponse<CreateOrUpdateOAuth2AuthSchemeResponse> UpdateAuthScheme1WithHttpInfo(string oAuth2AuthSchemeId, CreateOrUpdateOAuth2AuthSchemeRequest createOrUpdateOAuth2AuthSchemeRequest = default(CreateOrUpdateOAuth2AuthSchemeRequest));
        /// <summary>
        /// Updates an Auth Scheme
        /// </summary>
        /// <remarks>
        /// Updates an Auth Scheme with the specified data in the auth scheme request.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcAuthSchemeId"></param>
        /// <param name="createOrUpdateOidcAuthSchemeRequest"> (optional)</param>
        /// <returns>CreateOrUpdateOidcAuthSchemeResponse</returns>
        CreateOrUpdateOidcAuthSchemeResponse UpdateAuthScheme2(string oidcAuthSchemeId, CreateOrUpdateOidcAuthSchemeRequest createOrUpdateOidcAuthSchemeRequest = default(CreateOrUpdateOidcAuthSchemeRequest));

        /// <summary>
        /// Updates an Auth Scheme
        /// </summary>
        /// <remarks>
        /// Updates an Auth Scheme with the specified data in the auth scheme request.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcAuthSchemeId"></param>
        /// <param name="createOrUpdateOidcAuthSchemeRequest"> (optional)</param>
        /// <returns>ApiResponse of CreateOrUpdateOidcAuthSchemeResponse</returns>
        ApiResponse<CreateOrUpdateOidcAuthSchemeResponse> UpdateAuthScheme2WithHttpInfo(string oidcAuthSchemeId, CreateOrUpdateOidcAuthSchemeRequest createOrUpdateOidcAuthSchemeRequest = default(CreateOrUpdateOidcAuthSchemeRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="version"></param>
        /// <param name="updateDeploymentRequest"> (optional)</param>
        /// <returns>Deployment</returns>
        Deployment UpdateDeployment(string applicationId, string version, UpdateDeploymentRequest updateDeploymentRequest = default(UpdateDeploymentRequest));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="version"></param>
        /// <param name="updateDeploymentRequest"> (optional)</param>
        /// <returns>ApiResponse of Deployment</returns>
        ApiResponse<Deployment> UpdateDeploymentWithHttpInfo(string applicationId, string version, UpdateDeploymentRequest updateDeploymentRequest = default(UpdateDeploymentRequest));
        /// <summary>
        /// Updates an inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Updates an inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="distinctInventoryItemId"></param>
        /// <param name="updateDistinctInventoryItemRequest"> (optional)</param>
        /// <returns>DistinctInventoryItem</returns>
        DistinctInventoryItem UpdateDistinctInventoryItem(string distinctInventoryItemId, UpdateDistinctInventoryItemRequest updateDistinctInventoryItemRequest = default(UpdateDistinctInventoryItemRequest));

        /// <summary>
        /// Updates an inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Updates an inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="distinctInventoryItemId"></param>
        /// <param name="updateDistinctInventoryItemRequest"> (optional)</param>
        /// <returns>ApiResponse of DistinctInventoryItem</returns>
        ApiResponse<DistinctInventoryItem> UpdateDistinctInventoryItemWithHttpInfo(string distinctInventoryItemId, UpdateDistinctInventoryItemRequest updateDistinctInventoryItemRequest = default(UpdateDistinctInventoryItemRequest));
        /// <summary>
        /// Updates a Facebook ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Updates an existing Facebook Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="facebookApplicationConfiguration"> (optional)</param>
        /// <returns>FacebookApplicationConfiguration</returns>
        FacebookApplicationConfiguration UpdateFacebookApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId, FacebookApplicationConfiguration facebookApplicationConfiguration = default(FacebookApplicationConfiguration));

        /// <summary>
        /// Updates a Facebook ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Updates an existing Facebook Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="facebookApplicationConfiguration"> (optional)</param>
        /// <returns>ApiResponse of FacebookApplicationConfiguration</returns>
        ApiResponse<FacebookApplicationConfiguration> UpdateFacebookApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId, FacebookApplicationConfiguration facebookApplicationConfiguration = default(FacebookApplicationConfiguration));
        /// <summary>
        /// Updates a Firebase ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Updates an existing Firebase Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="firebaseApplicationConfiguration"> (optional)</param>
        /// <returns>FirebaseApplicationConfiguration</returns>
        FirebaseApplicationConfiguration UpdateFirebaseApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId, FirebaseApplicationConfiguration firebaseApplicationConfiguration = default(FirebaseApplicationConfiguration));

        /// <summary>
        /// Updates a Firebase ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Updates an existing Firebase Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="firebaseApplicationConfiguration"> (optional)</param>
        /// <returns>ApiResponse of FirebaseApplicationConfiguration</returns>
        ApiResponse<FirebaseApplicationConfiguration> UpdateFirebaseApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId, FirebaseApplicationConfiguration firebaseApplicationConfiguration = default(FirebaseApplicationConfiguration));
        /// <summary>
        /// Updates a Google Play ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Updates an existing Google Play Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="googlePlayApplicationConfiguration"> (optional)</param>
        /// <returns>GooglePlayApplicationConfiguration</returns>
        GooglePlayApplicationConfiguration UpdateGooglePlayApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId, GooglePlayApplicationConfiguration googlePlayApplicationConfiguration = default(GooglePlayApplicationConfiguration));

        /// <summary>
        /// Updates a Google Play ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Updates an existing Google Play Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="googlePlayApplicationConfiguration"> (optional)</param>
        /// <returns>ApiResponse of GooglePlayApplicationConfiguration</returns>
        ApiResponse<GooglePlayApplicationConfiguration> UpdateGooglePlayApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId, GooglePlayApplicationConfiguration googlePlayApplicationConfiguration = default(GooglePlayApplicationConfiguration));
        /// <summary>
        /// Updates a iOS ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Updates an existing iOS Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="iosApplicationConfiguration"> (optional)</param>
        /// <returns>IosApplicationConfiguration</returns>
        IosApplicationConfiguration UpdateIosApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId, IosApplicationConfiguration iosApplicationConfiguration = default(IosApplicationConfiguration));

        /// <summary>
        /// Updates a iOS ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Updates an existing iOS Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="iosApplicationConfiguration"> (optional)</param>
        /// <returns>ApiResponse of IosApplicationConfiguration</returns>
        ApiResponse<IosApplicationConfiguration> UpdateIosApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId, IosApplicationConfiguration iosApplicationConfiguration = default(IosApplicationConfiguration));
        /// <summary>
        /// Updates a single Item
        /// </summary>
        /// <remarks>
        /// Supplying an item, this will update the Item identified by the identifier in the path with contents from the passed in request body. 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="identifier"></param>
        /// <param name="updateItemRequest"> (optional)</param>
        /// <returns>Item</returns>
        Item UpdateItem(string identifier, UpdateItemRequest updateItemRequest = default(UpdateItemRequest));

        /// <summary>
        /// Updates a single Item
        /// </summary>
        /// <remarks>
        /// Supplying an item, this will update the Item identified by the identifier in the path with contents from the passed in request body. 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="identifier"></param>
        /// <param name="updateItemRequest"> (optional)</param>
        /// <returns>ApiResponse of Item</returns>
        ApiResponse<Item> UpdateItemWithHttpInfo(string identifier, UpdateItemRequest updateItemRequest = default(UpdateItemRequest));
        /// <summary>
        /// Updates a LargeObject
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <param name="updateLargeObjectRequest"> (optional)</param>
        /// <returns>LargeObject</returns>
        LargeObject UpdateLargeObject(string largeObjectId, UpdateLargeObjectRequest updateLargeObjectRequest = default(UpdateLargeObjectRequest));

        /// <summary>
        /// Updates a LargeObject
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <param name="updateLargeObjectRequest"> (optional)</param>
        /// <returns>ApiResponse of LargeObject</returns>
        ApiResponse<LargeObject> UpdateLargeObjectWithHttpInfo(string largeObjectId, UpdateLargeObjectRequest updateLargeObjectRequest = default(UpdateLargeObjectRequest));
        /// <summary>
        /// Updates a LargeObject content
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <param name="body"> (optional)</param>
        /// <returns>LargeObject</returns>
        LargeObject UpdateLargeObjectContents(string largeObjectId, Object body = default(Object));

        /// <summary>
        /// Updates a LargeObject content
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of LargeObject</returns>
        ApiResponse<LargeObject> UpdateLargeObjectContentsWithHttpInfo(string largeObjectId, Object body = default(Object));
        /// <summary>
        /// Updates an Leaderboard
        /// </summary>
        /// <remarks>
        /// Performs an update to an existing leaderboard known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="leaderboard"> (optional)</param>
        /// <returns>Leaderboard</returns>
        Leaderboard UpdateLeaderboard(string nameOrId, Leaderboard leaderboard = default(Leaderboard));

        /// <summary>
        /// Updates an Leaderboard
        /// </summary>
        /// <remarks>
        /// Performs an update to an existing leaderboard known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="leaderboard"> (optional)</param>
        /// <returns>ApiResponse of Leaderboard</returns>
        ApiResponse<Leaderboard> UpdateLeaderboardWithHttpInfo(string nameOrId, Leaderboard leaderboard = default(Leaderboard));
        /// <summary>
        /// Updates a iOS ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Updates an existing iOS Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="matchmakingApplicationConfiguration"> (optional)</param>
        /// <returns>MatchmakingApplicationConfiguration</returns>
        MatchmakingApplicationConfiguration UpdateMatchmakingApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId, MatchmakingApplicationConfiguration matchmakingApplicationConfiguration = default(MatchmakingApplicationConfiguration));

        /// <summary>
        /// Updates a iOS ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Updates an existing iOS Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="matchmakingApplicationConfiguration"> (optional)</param>
        /// <returns>ApiResponse of MatchmakingApplicationConfiguration</returns>
        ApiResponse<MatchmakingApplicationConfiguration> UpdateMatchmakingApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId, MatchmakingApplicationConfiguration matchmakingApplicationConfiguration = default(MatchmakingApplicationConfiguration));
        /// <summary>
        /// Updates a specific Metadata object
        /// </summary>
        /// <remarks>
        /// Updates a specific metadata object by name or id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="updateMetadataRequest"> (optional)</param>
        /// <returns>Metadata</returns>
        Metadata UpdateMetadata(string id, UpdateMetadataRequest updateMetadataRequest = default(UpdateMetadataRequest));

        /// <summary>
        /// Updates a specific Metadata object
        /// </summary>
        /// <remarks>
        /// Updates a specific metadata object by name or id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="updateMetadataRequest"> (optional)</param>
        /// <returns>ApiResponse of Metadata</returns>
        ApiResponse<Metadata> UpdateMetadataWithHttpInfo(string id, UpdateMetadataRequest updateMetadataRequest = default(UpdateMetadataRequest));
        /// <summary>
        /// Updates a Metadata Spec
        /// </summary>
        /// <remarks>
        /// Updates a MetadataSpec with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecId"></param>
        /// <param name="updateMetadataSpecRequest"> (optional)</param>
        /// <returns>MetadataSpec</returns>
        MetadataSpec UpdateMetadataSpec(string metadataSpecId, UpdateMetadataSpecRequest updateMetadataSpecRequest = default(UpdateMetadataSpecRequest));

        /// <summary>
        /// Updates a Metadata Spec
        /// </summary>
        /// <remarks>
        /// Updates a MetadataSpec with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecId"></param>
        /// <param name="updateMetadataSpecRequest"> (optional)</param>
        /// <returns>ApiResponse of MetadataSpec</returns>
        ApiResponse<MetadataSpec> UpdateMetadataSpecWithHttpInfo(string metadataSpecId, UpdateMetadataSpecRequest updateMetadataSpecRequest = default(UpdateMetadataSpecRequest));
        /// <summary>
        /// Updates an entire single Mission
        /// </summary>
        /// <remarks>
        /// Supplying a mission, this will update the Mission identified by the name or ID in the path with contents from the passed in request body. 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="missionNameOrId"></param>
        /// <param name="mission"> (optional)</param>
        /// <returns>Mission</returns>
        Mission UpdateMission(string missionNameOrId, Mission mission = default(Mission));

        /// <summary>
        /// Updates an entire single Mission
        /// </summary>
        /// <remarks>
        /// Supplying a mission, this will update the Mission identified by the name or ID in the path with contents from the passed in request body. 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="missionNameOrId"></param>
        /// <param name="mission"> (optional)</param>
        /// <returns>ApiResponse of Mission</returns>
        ApiResponse<Mission> UpdateMissionWithHttpInfo(string missionNameOrId, Mission mission = default(Mission));
        /// <summary>
        /// Updates a PSN ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Updates an existing PSN Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="pSNApplicationConfiguration"> (optional)</param>
        /// <returns>PSNApplicationConfiguration</returns>
        PSNApplicationConfiguration UpdatePSNApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId, PSNApplicationConfiguration pSNApplicationConfiguration = default(PSNApplicationConfiguration));

        /// <summary>
        /// Updates a PSN ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Updates an existing PSN Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="pSNApplicationConfiguration"> (optional)</param>
        /// <returns>ApiResponse of PSNApplicationConfiguration</returns>
        ApiResponse<PSNApplicationConfiguration> UpdatePSNApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId, PSNApplicationConfiguration pSNApplicationConfiguration = default(PSNApplicationConfiguration));
        /// <summary>
        /// Updates the ProductBundle
        /// </summary>
        /// <remarks>
        /// Updates the ProductBundle for the given ApplicationConfiguration
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="productBundle"> (optional)</param>
        /// <returns>ApplicationConfiguration</returns>
        ApplicationConfiguration UpdateProductBundleForApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId, List<ProductBundle> productBundle = default(List<ProductBundle>));

        /// <summary>
        /// Updates the ProductBundle
        /// </summary>
        /// <remarks>
        /// Updates the ProductBundle for the given ApplicationConfiguration
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="productBundle"> (optional)</param>
        /// <returns>ApiResponse of ApplicationConfiguration</returns>
        ApiResponse<ApplicationConfiguration> UpdateProductBundleForApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId, List<ProductBundle> productBundle = default(List<ProductBundle>));
        /// <summary>
        /// Updates the ProductBundle
        /// </summary>
        /// <remarks>
        /// Updates the ProductBundle for the given ApplicationConfiguration
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="productBundle"> (optional)</param>
        /// <returns>ApplicationConfiguration</returns>
        ApplicationConfiguration UpdateProductBundleForApplicationConfiguration1(string applicationNameOrId, string applicationConfigurationNameOrId, List<ProductBundle> productBundle = default(List<ProductBundle>));

        /// <summary>
        /// Updates the ProductBundle
        /// </summary>
        /// <remarks>
        /// Updates the ProductBundle for the given ApplicationConfiguration
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="productBundle"> (optional)</param>
        /// <returns>ApiResponse of ApplicationConfiguration</returns>
        ApiResponse<ApplicationConfiguration> UpdateProductBundleForApplicationConfiguration1WithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId, List<ProductBundle> productBundle = default(List<ProductBundle>));
        /// <summary>
        /// Updates a Profile
        /// </summary>
        /// <remarks>
        /// Supplying an update request will attempt to update the profile.  The call will return the profile as it was written to the database.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="updateProfileRequest"> (optional)</param>
        /// <returns>Profile</returns>
        Profile UpdateProfile(string profileId, UpdateProfileRequest updateProfileRequest = default(UpdateProfileRequest));

        /// <summary>
        /// Updates a Profile
        /// </summary>
        /// <remarks>
        /// Supplying an update request will attempt to update the profile.  The call will return the profile as it was written to the database.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="updateProfileRequest"> (optional)</param>
        /// <returns>ApiResponse of Profile</returns>
        ApiResponse<Profile> UpdateProfileWithHttpInfo(string profileId, UpdateProfileRequest updateProfileRequest = default(UpdateProfileRequest));
        /// <summary>
        /// Updates a Profile image object
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="updateProfileImageRequest"> (optional)</param>
        /// <returns>Profile</returns>
        Profile UpdateProfileImage(string profileId, UpdateProfileImageRequest updateProfileImageRequest = default(UpdateProfileImageRequest));

        /// <summary>
        /// Updates a Profile image object
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="updateProfileImageRequest"> (optional)</param>
        /// <returns>ApiResponse of Profile</returns>
        ApiResponse<Profile> UpdateProfileImageWithHttpInfo(string profileId, UpdateProfileImageRequest updateProfileImageRequest = default(UpdateProfileImageRequest));
        /// <summary>
        /// Updates a single Progress
        /// </summary>
        /// <remarks>
        /// Supplying a progress, this will update the Progress identified by the ID in the path with contents from the passed in request body. 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progressId"></param>
        /// <param name="progress"> (optional)</param>
        /// <returns>Progress</returns>
        Progress UpdateProgress(string progressId, Progress progress = default(Progress));

        /// <summary>
        /// Updates a single Progress
        /// </summary>
        /// <remarks>
        /// Supplying a progress, this will update the Progress identified by the ID in the path with contents from the passed in request body. 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progressId"></param>
        /// <param name="progress"> (optional)</param>
        /// <returns>ApiResponse of Progress</returns>
        ApiResponse<Progress> UpdateProgressWithHttpInfo(string progressId, Progress progress = default(Progress));
        /// <summary>
        /// Update an FCM Registration Token
        /// </summary>
        /// <remarks>
        /// Supplying FCM registration token, this will update the token string with the supplied values.  Clients may update the same registration with a different token issued with Firebase if they wish to simply retain the association with the 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fcmRegistrationId"></param>
        /// <param name="fCMRegistration"> (optional)</param>
        /// <returns>FCMRegistration</returns>
        FCMRegistration UpdateRegistration(string fcmRegistrationId, FCMRegistration fCMRegistration = default(FCMRegistration));

        /// <summary>
        /// Update an FCM Registration Token
        /// </summary>
        /// <remarks>
        /// Supplying FCM registration token, this will update the token string with the supplied values.  Clients may update the same registration with a different token issued with Firebase if they wish to simply retain the association with the 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fcmRegistrationId"></param>
        /// <param name="fCMRegistration"> (optional)</param>
        /// <returns>ApiResponse of FCMRegistration</returns>
        ApiResponse<FCMRegistration> UpdateRegistrationWithHttpInfo(string fcmRegistrationId, FCMRegistration fCMRegistration = default(FCMRegistration));
        /// <summary>
        /// Creates a save data document.
        /// </summary>
        /// <remarks>
        /// Gets a single save data document.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="saveDataDocumentId"></param>
        /// <param name="updateSaveDataDocumentRequest"> (optional)</param>
        /// <returns>SaveDataDocument</returns>
        SaveDataDocument UpdateSaveDocument(string saveDataDocumentId, UpdateSaveDataDocumentRequest updateSaveDataDocumentRequest = default(UpdateSaveDataDocumentRequest));

        /// <summary>
        /// Creates a save data document.
        /// </summary>
        /// <remarks>
        /// Gets a single save data document.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="saveDataDocumentId"></param>
        /// <param name="updateSaveDataDocumentRequest"> (optional)</param>
        /// <returns>ApiResponse of SaveDataDocument</returns>
        ApiResponse<SaveDataDocument> UpdateSaveDocumentWithHttpInfo(string saveDataDocumentId, UpdateSaveDataDocumentRequest updateSaveDataDocumentRequest = default(UpdateSaveDataDocumentRequest));
        /// <summary>
        /// Updates an entire single Schedule
        /// </summary>
        /// <remarks>
        /// Supplying a schedule, this will update the Schedule identified by the name or ID in the path with contents from the passed in request body. 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="updateScheduleRequest"> (optional)</param>
        /// <returns>Schedule</returns>
        Schedule UpdateSchedule(string scheduleNameOrId, UpdateScheduleRequest updateScheduleRequest = default(UpdateScheduleRequest));

        /// <summary>
        /// Updates an entire single Schedule
        /// </summary>
        /// <remarks>
        /// Supplying a schedule, this will update the Schedule identified by the name or ID in the path with contents from the passed in request body. 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="updateScheduleRequest"> (optional)</param>
        /// <returns>ApiResponse of Schedule</returns>
        ApiResponse<Schedule> UpdateScheduleWithHttpInfo(string scheduleNameOrId, UpdateScheduleRequest updateScheduleRequest = default(UpdateScheduleRequest));
        /// <summary>
        /// Updates an entire single ScheduleEvent
        /// </summary>
        /// <remarks>
        /// Supplying a schedule, this will update the ScheduleEvent identified by the name or ID in the path with contents from the passed in request body. 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="scheduleEventId"></param>
        /// <param name="updateScheduleEventRequest"> (optional)</param>
        /// <returns>ScheduleEvent</returns>
        ScheduleEvent UpdateScheduleEvent(string scheduleNameOrId, string scheduleEventId, UpdateScheduleEventRequest updateScheduleEventRequest = default(UpdateScheduleEventRequest));

        /// <summary>
        /// Updates an entire single ScheduleEvent
        /// </summary>
        /// <remarks>
        /// Supplying a schedule, this will update the ScheduleEvent identified by the name or ID in the path with contents from the passed in request body. 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="scheduleEventId"></param>
        /// <param name="updateScheduleEventRequest"> (optional)</param>
        /// <returns>ApiResponse of ScheduleEvent</returns>
        ApiResponse<ScheduleEvent> UpdateScheduleEventWithHttpInfo(string scheduleNameOrId, string scheduleEventId, UpdateScheduleEventRequest updateScheduleEventRequest = default(UpdateScheduleEventRequest));
        /// <summary>
        /// Updates an inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Updates an inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="updateInventoryItemRequest"> (optional)</param>
        /// <returns>InventoryItem</returns>
        InventoryItem UpdateSimpleInventoryItem(string inventoryItemId, UpdateInventoryItemRequest updateInventoryItemRequest = default(UpdateInventoryItemRequest));

        /// <summary>
        /// Updates an inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Updates an inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="updateInventoryItemRequest"> (optional)</param>
        /// <returns>ApiResponse of InventoryItem</returns>
        ApiResponse<InventoryItem> UpdateSimpleInventoryItemWithHttpInfo(string inventoryItemId, UpdateInventoryItemRequest updateInventoryItemRequest = default(UpdateInventoryItemRequest));
        /// <summary>
        /// Updates an inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Updates an inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="updateInventoryItemRequest"> (optional)</param>
        /// <returns>InventoryItem</returns>
        InventoryItem UpdateSimpleInventoryItem1(string inventoryItemId, UpdateInventoryItemRequest updateInventoryItemRequest = default(UpdateInventoryItemRequest));

        /// <summary>
        /// Updates an inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Updates an inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="updateInventoryItemRequest"> (optional)</param>
        /// <returns>ApiResponse of InventoryItem</returns>
        ApiResponse<InventoryItem> UpdateSimpleInventoryItem1WithHttpInfo(string inventoryItemId, UpdateInventoryItemRequest updateInventoryItemRequest = default(UpdateInventoryItemRequest));
        /// <summary>
        /// Patches a  Smart Contract
        /// </summary>
        /// <remarks>
        /// Patches a  Smart Contract entry, associated with the specified deployed script hash.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractId"></param>
        /// <param name="updateSmartContractRequest"> (optional)</param>
        /// <returns>SmartContract</returns>
        SmartContract UpdateSmartContract(string contractId, UpdateSmartContractRequest updateSmartContractRequest = default(UpdateSmartContractRequest));

        /// <summary>
        /// Patches a  Smart Contract
        /// </summary>
        /// <remarks>
        /// Patches a  Smart Contract entry, associated with the specified deployed script hash.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractId"></param>
        /// <param name="updateSmartContractRequest"> (optional)</param>
        /// <returns>ApiResponse of SmartContract</returns>
        ApiResponse<SmartContract> UpdateSmartContractWithHttpInfo(string contractId, UpdateSmartContractRequest updateSmartContractRequest = default(UpdateSmartContractRequest));
        /// <summary>
        /// Updates a User
        /// </summary>
        /// <remarks>
        /// Supplying the user object, this will update the user with the new information supplied in the body of the request.  Optionally, the user&#39;s password may be provided in the User object.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="userUpdateRequest"> (optional)</param>
        /// <returns>User</returns>
        User UpdateUser(string userId, UserUpdateRequest userUpdateRequest = default(UserUpdateRequest));

        /// <summary>
        /// Updates a User
        /// </summary>
        /// <remarks>
        /// Supplying the user object, this will update the user with the new information supplied in the body of the request.  Optionally, the user&#39;s password may be provided in the User object.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="userUpdateRequest"> (optional)</param>
        /// <returns>ApiResponse of User</returns>
        ApiResponse<User> UpdateUserWithHttpInfo(string userId, UserUpdateRequest userUpdateRequest = default(UserUpdateRequest));
        /// <summary>
        /// Updates a User&#39;s Password
        /// </summary>
        /// <remarks>
        /// Supplying the UserUpdatePasswordRequest, this will attempt to update the user&#39;s password only if they supply the correct existing password.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="userUpdatePasswordRequest"> (optional)</param>
        /// <returns>SessionCreation</returns>
        SessionCreation UpdateUserPassword(string userId, UserUpdatePasswordRequest userUpdatePasswordRequest = default(UserUpdatePasswordRequest));

        /// <summary>
        /// Updates a User&#39;s Password
        /// </summary>
        /// <remarks>
        /// Supplying the UserUpdatePasswordRequest, this will attempt to update the user&#39;s password only if they supply the correct existing password.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="userUpdatePasswordRequest"> (optional)</param>
        /// <returns>ApiResponse of SessionCreation</returns>
        ApiResponse<SessionCreation> UpdateUserPasswordWithHttpInfo(string userId, UserUpdatePasswordRequest userUpdatePasswordRequest = default(UserUpdatePasswordRequest));
        /// <summary>
        /// Updates a  Vault
        /// </summary>
        /// <remarks>
        /// Updates a  Vault with the specified name or id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="updateVaultRequest"> (optional)</param>
        /// <returns>Vault</returns>
        Vault UpdateVault(string vaultId, UpdateVaultRequest updateVaultRequest = default(UpdateVaultRequest));

        /// <summary>
        /// Updates a  Vault
        /// </summary>
        /// <remarks>
        /// Updates a  Vault with the specified name or id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="updateVaultRequest"> (optional)</param>
        /// <returns>ApiResponse of Vault</returns>
        ApiResponse<Vault> UpdateVaultWithHttpInfo(string vaultId, UpdateVaultRequest updateVaultRequest = default(UpdateVaultRequest));
        /// <summary>
        /// Updates a  Wallet
        /// </summary>
        /// <remarks>
        /// Updates a  Wallet with the specified name or id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="walletId"></param>
        /// <param name="updateWalletRequest"> (optional)</param>
        /// <returns>Wallet</returns>
        Wallet UpdateWallet(string vaultId, string walletId, UpdateWalletRequest updateWalletRequest = default(UpdateWalletRequest));

        /// <summary>
        /// Updates a  Wallet
        /// </summary>
        /// <remarks>
        /// Updates a  Wallet with the specified name or id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="walletId"></param>
        /// <param name="updateWalletRequest"> (optional)</param>
        /// <returns>ApiResponse of Wallet</returns>
        ApiResponse<Wallet> UpdateWalletWithHttpInfo(string vaultId, string walletId, UpdateWalletRequest updateWalletRequest = default(UpdateWalletRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Upload Apple IAP Receipt. Returns a list of RewardIssuances, which may contain already-redeemed issuances.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAppleIapReceipt"> (optional)</param>
        /// <returns>List&lt;RewardIssuance&gt;</returns>
        List<RewardIssuance> UploadAppleIapReceipt(CreateAppleIapReceipt createAppleIapReceipt = default(CreateAppleIapReceipt));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Upload Apple IAP Receipt. Returns a list of RewardIssuances, which may contain already-redeemed issuances.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAppleIapReceipt"> (optional)</param>
        /// <returns>ApiResponse of List&lt;RewardIssuance&gt;</returns>
        ApiResponse<List<RewardIssuance>> UploadAppleIapReceiptWithHttpInfo(CreateAppleIapReceipt createAppleIapReceipt = default(CreateAppleIapReceipt));
        /// <summary>
        /// Upload Google Play IAP Receipt data (package name, product id and Google Play-issued purchase token). Returns a list of RewardIssuances, some or all of which may be already redeemed.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createGooglePlayIapReceipt"> (optional)</param>
        /// <returns>List&lt;RewardIssuance&gt;</returns>
        List<RewardIssuance> UploadGooglePlayIapPurchase(CreateGooglePlayIapReceipt createGooglePlayIapReceipt = default(CreateGooglePlayIapReceipt));

        /// <summary>
        /// Upload Google Play IAP Receipt data (package name, product id and Google Play-issued purchase token). Returns a list of RewardIssuances, some or all of which may be already redeemed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createGooglePlayIapReceipt"> (optional)</param>
        /// <returns>ApiResponse of List&lt;RewardIssuance&gt;</returns>
        ApiResponse<List<RewardIssuance>> UploadGooglePlayIapPurchaseWithHttpInfo(CreateGooglePlayIapReceipt createGooglePlayIapReceipt = default(CreateGooglePlayIapReceipt));
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IDefaultApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Adjust the quantity of the inventory item for the specified item.
        /// </summary>
        /// <remarks>
        /// Adjust the quantity of the first (primary) inventory item for the specified item.  This implicitly will create the InventoryItem if it does not exist.  The inventory item value
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="advancedInventoryItemQuantityAdjustment"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InventoryItem</returns>
        System.Threading.Tasks.Task<InventoryItem> AdjustAdvancedInventoryItemQuantityAsync(string inventoryItemId, AdvancedInventoryItemQuantityAdjustment advancedInventoryItemQuantityAdjustment = default(AdvancedInventoryItemQuantityAdjustment), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Adjust the quantity of the inventory item for the specified item.
        /// </summary>
        /// <remarks>
        /// Adjust the quantity of the first (primary) inventory item for the specified item.  This implicitly will create the InventoryItem if it does not exist.  The inventory item value
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="advancedInventoryItemQuantityAdjustment"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InventoryItem)</returns>
        System.Threading.Tasks.Task<ApiResponse<InventoryItem>> AdjustAdvancedInventoryItemQuantityWithHttpInfoAsync(string inventoryItemId, AdvancedInventoryItemQuantityAdjustment advancedInventoryItemQuantityAdjustment = default(AdvancedInventoryItemQuantityAdjustment), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Adjust the quantity of the inventory item for the specified item.
        /// </summary>
        /// <remarks>
        /// Adjust the quantity of the first (primary) inventory item for the specified item.  This implicitly will create the InventoryItem if it does not exist.  The inventory item value
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="simpleInventoryItemQuantityAdjustment"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InventoryItem</returns>
        System.Threading.Tasks.Task<InventoryItem> AdjustSimpleInventoryItemQuantityAsync(string inventoryItemId, SimpleInventoryItemQuantityAdjustment simpleInventoryItemQuantityAdjustment = default(SimpleInventoryItemQuantityAdjustment), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Adjust the quantity of the inventory item for the specified item.
        /// </summary>
        /// <remarks>
        /// Adjust the quantity of the first (primary) inventory item for the specified item.  This implicitly will create the InventoryItem if it does not exist.  The inventory item value
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="simpleInventoryItemQuantityAdjustment"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InventoryItem)</returns>
        System.Threading.Tasks.Task<ApiResponse<InventoryItem>> AdjustSimpleInventoryItemQuantityWithHttpInfoAsync(string inventoryItemId, SimpleInventoryItemQuantityAdjustment simpleInventoryItemQuantityAdjustment = default(SimpleInventoryItemQuantityAdjustment), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Destroys the Session
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionSecret"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task BlacklistSessionAsync(string sessionSecret, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Destroys the Session
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionSecret"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> BlacklistSessionWithHttpInfoAsync(string sessionSecret, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Builds all indexes.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="buildIndexRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task BuildIndexesAsync(BuildIndexRequest buildIndexRequest = default(BuildIndexRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Builds all indexes.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="buildIndexRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> BuildIndexesWithHttpInfoAsync(BuildIndexRequest buildIndexRequest = default(BuildIndexRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Create an inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Create an inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAdvancedInventoryItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InventoryItem</returns>
        System.Threading.Tasks.Task<InventoryItem> CreateAdvancedInventoryItemAsync(CreateAdvancedInventoryItemRequest createAdvancedInventoryItemRequest = default(CreateAdvancedInventoryItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Create an inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Create an inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAdvancedInventoryItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InventoryItem)</returns>
        System.Threading.Tasks.Task<ApiResponse<InventoryItem>> CreateAdvancedInventoryItemWithHttpInfoAsync(CreateAdvancedInventoryItemRequest createAdvancedInventoryItemRequest = default(CreateAdvancedInventoryItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a New Application
        /// </summary>
        /// <remarks>
        /// Gets the metadata for a single application.  This may include more specific details not available in the bulk-get or fetch operation.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createApplicationRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Application</returns>
        System.Threading.Tasks.Task<Application> CreateApplicationAsync(CreateApplicationRequest createApplicationRequest = default(CreateApplicationRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a New Application
        /// </summary>
        /// <remarks>
        /// Gets the metadata for a single application.  This may include more specific details not available in the bulk-get or fetch operation.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createApplicationRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Application)</returns>
        System.Threading.Tasks.Task<ApiResponse<Application>> CreateApplicationWithHttpInfoAsync(CreateApplicationRequest createApplicationRequest = default(CreateApplicationRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a new Auth Scheme
        /// </summary>
        /// <remarks>
        /// Creates a new Auth Scheme, from the data in the given auth scheme request
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAuthSchemeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CreateAuthSchemeResponse</returns>
        System.Threading.Tasks.Task<CreateAuthSchemeResponse> CreateAuthSchemeAsync(CreateAuthSchemeRequest createAuthSchemeRequest = default(CreateAuthSchemeRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a new Auth Scheme
        /// </summary>
        /// <remarks>
        /// Creates a new Auth Scheme, from the data in the given auth scheme request
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAuthSchemeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CreateAuthSchemeResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<CreateAuthSchemeResponse>> CreateAuthSchemeWithHttpInfoAsync(CreateAuthSchemeRequest createAuthSchemeRequest = default(CreateAuthSchemeRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a new Auth Scheme
        /// </summary>
        /// <remarks>
        /// Creates a new Auth Scheme, from the data in the given auth scheme request
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createOrUpdateOAuth2AuthSchemeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CreateOrUpdateOAuth2AuthSchemeResponse</returns>
        System.Threading.Tasks.Task<CreateOrUpdateOAuth2AuthSchemeResponse> CreateAuthScheme1Async(CreateOrUpdateOAuth2AuthSchemeRequest createOrUpdateOAuth2AuthSchemeRequest = default(CreateOrUpdateOAuth2AuthSchemeRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a new Auth Scheme
        /// </summary>
        /// <remarks>
        /// Creates a new Auth Scheme, from the data in the given auth scheme request
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createOrUpdateOAuth2AuthSchemeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CreateOrUpdateOAuth2AuthSchemeResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<CreateOrUpdateOAuth2AuthSchemeResponse>> CreateAuthScheme1WithHttpInfoAsync(CreateOrUpdateOAuth2AuthSchemeRequest createOrUpdateOAuth2AuthSchemeRequest = default(CreateOrUpdateOAuth2AuthSchemeRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a new Auth Scheme
        /// </summary>
        /// <remarks>
        /// Creates a new Auth Scheme, from the data in the given auth scheme request
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createOrUpdateOidcAuthSchemeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CreateOrUpdateOidcAuthSchemeResponse</returns>
        System.Threading.Tasks.Task<CreateOrUpdateOidcAuthSchemeResponse> CreateAuthScheme2Async(CreateOrUpdateOidcAuthSchemeRequest createOrUpdateOidcAuthSchemeRequest = default(CreateOrUpdateOidcAuthSchemeRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a new Auth Scheme
        /// </summary>
        /// <remarks>
        /// Creates a new Auth Scheme, from the data in the given auth scheme request
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createOrUpdateOidcAuthSchemeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CreateOrUpdateOidcAuthSchemeResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<CreateOrUpdateOidcAuthSchemeResponse>> CreateAuthScheme2WithHttpInfoAsync(CreateOrUpdateOidcAuthSchemeRequest createOrUpdateOidcAuthSchemeRequest = default(CreateOrUpdateOidcAuthSchemeRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Create an inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Create an inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createDistinctInventoryItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of DistinctInventoryItem</returns>
        System.Threading.Tasks.Task<DistinctInventoryItem> CreateDistinctInventoryItemAsync(CreateDistinctInventoryItemRequest createDistinctInventoryItemRequest = default(CreateDistinctInventoryItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Create an inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Create an inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createDistinctInventoryItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (DistinctInventoryItem)</returns>
        System.Threading.Tasks.Task<ApiResponse<DistinctInventoryItem>> CreateDistinctInventoryItemWithHttpInfoAsync(CreateDistinctInventoryItemRequest createDistinctInventoryItemRequest = default(CreateDistinctInventoryItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates an FCM Registration Token
        /// </summary>
        /// <remarks>
        /// Supplying FCM registration token, this will create a new token based on the information supplied to the endpoint.  The response will contain the token as it was written to the database.  Clients may subsequently update the token string with new values as they are issued by Firebase.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fCMRegistration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FCMRegistration</returns>
        System.Threading.Tasks.Task<FCMRegistration> CreateFCMRegistrationAsync(FCMRegistration fCMRegistration = default(FCMRegistration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates an FCM Registration Token
        /// </summary>
        /// <remarks>
        /// Supplying FCM registration token, this will create a new token based on the information supplied to the endpoint.  The response will contain the token as it was written to the database.  Clients may subsequently update the token string with new values as they are issued by Firebase.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fCMRegistration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FCMRegistration)</returns>
        System.Threading.Tasks.Task<ApiResponse<FCMRegistration>> CreateFCMRegistrationWithHttpInfoAsync(FCMRegistration fCMRegistration = default(FCMRegistration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a new Facebook ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Creates a new Facebook ApplicationConfiguration with the specific ID or application.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="facebookApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FacebookApplicationConfiguration</returns>
        System.Threading.Tasks.Task<FacebookApplicationConfiguration> CreateFacebookApplicationConfigurationAsync(string applicationNameOrId, FacebookApplicationConfiguration facebookApplicationConfiguration = default(FacebookApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a new Facebook ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Creates a new Facebook ApplicationConfiguration with the specific ID or application.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="facebookApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FacebookApplicationConfiguration)</returns>
        System.Threading.Tasks.Task<ApiResponse<FacebookApplicationConfiguration>> CreateFacebookApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, FacebookApplicationConfiguration facebookApplicationConfiguration = default(FacebookApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a new Firebase ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Creates a new Firebase ApplicationConfiguration with the specific ID or application.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="firebaseApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FirebaseApplicationConfiguration</returns>
        System.Threading.Tasks.Task<FirebaseApplicationConfiguration> CreateFirebaseApplicationConfigurationAsync(string applicationNameOrId, FirebaseApplicationConfiguration firebaseApplicationConfiguration = default(FirebaseApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a new Firebase ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Creates a new Firebase ApplicationConfiguration with the specific ID or application.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="firebaseApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FirebaseApplicationConfiguration)</returns>
        System.Threading.Tasks.Task<ApiResponse<FirebaseApplicationConfiguration>> CreateFirebaseApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, FirebaseApplicationConfiguration firebaseApplicationConfiguration = default(FirebaseApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a Follower relationship between two profiles.
        /// </summary>
        /// <remarks>
        /// Supplying the follower object, this will store the information supplied in the body of the request.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="createFollowerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task CreateFollowerAsync(string profileId, CreateFollowerRequest createFollowerRequest = default(CreateFollowerRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a Follower relationship between two profiles.
        /// </summary>
        /// <remarks>
        /// Supplying the follower object, this will store the information supplied in the body of the request.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="createFollowerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> CreateFollowerWithHttpInfoAsync(string profileId, CreateFollowerRequest createFollowerRequest = default(CreateFollowerRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a new Google Play ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Creates a new GooglePlay ApplicationConfiguration with the specific ID or application.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="googlePlayApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GooglePlayApplicationConfiguration</returns>
        System.Threading.Tasks.Task<GooglePlayApplicationConfiguration> CreateGooglePlayApplicationConfigurationAsync(string applicationNameOrId, GooglePlayApplicationConfiguration googlePlayApplicationConfiguration = default(GooglePlayApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a new Google Play ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Creates a new GooglePlay ApplicationConfiguration with the specific ID or application.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="googlePlayApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GooglePlayApplicationConfiguration)</returns>
        System.Threading.Tasks.Task<ApiResponse<GooglePlayApplicationConfiguration>> CreateGooglePlayApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, GooglePlayApplicationConfiguration googlePlayApplicationConfiguration = default(GooglePlayApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a new iOS ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Creates a new iOS ApplicationConfiguration with the specific ID or application.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="iosApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IosApplicationConfiguration</returns>
        System.Threading.Tasks.Task<IosApplicationConfiguration> CreateIosApplicationConfigurationAsync(string applicationNameOrId, IosApplicationConfiguration iosApplicationConfiguration = default(IosApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a new iOS ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Creates a new iOS ApplicationConfiguration with the specific ID or application.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="iosApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IosApplicationConfiguration)</returns>
        System.Threading.Tasks.Task<ApiResponse<IosApplicationConfiguration>> CreateIosApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, IosApplicationConfiguration iosApplicationConfiguration = default(IosApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a new digital Item
        /// </summary>
        /// <remarks>
        /// Supplying an item object, this will create a new item with a newly assigned unique id.  The Item representation returned in the response body is a representation of the Item as persisted with a unique identifier signed and with its fields properly normalized.  The supplied item object submitted with the request must have a name property that is unique across all items.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Item</returns>
        System.Threading.Tasks.Task<Item> CreateItemAsync(CreateItemRequest createItemRequest = default(CreateItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a new digital Item
        /// </summary>
        /// <remarks>
        /// Supplying an item object, this will create a new item with a newly assigned unique id.  The Item representation returned in the response body is a representation of the Item as persisted with a unique identifier signed and with its fields properly normalized.  The supplied item object submitted with the request must have a name property that is unique across all items.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Item)</returns>
        System.Threading.Tasks.Task<ApiResponse<Item>> CreateItemWithHttpInfoAsync(CreateItemRequest createItemRequest = default(CreateItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a LargeObject with content
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="varObject"> (optional)</param>
        /// <param name="metadata"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LargeObject</returns>
        System.Threading.Tasks.Task<LargeObject> CreateLargeObjectAsync(FormDataBodyPart varObject = default(FormDataBodyPart), CreateLargeObjectRequest metadata = default(CreateLargeObjectRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a LargeObject with content
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="varObject"> (optional)</param>
        /// <param name="metadata"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LargeObject)</returns>
        System.Threading.Tasks.Task<ApiResponse<LargeObject>> CreateLargeObjectWithHttpInfoAsync(FormDataBodyPart varObject = default(FormDataBodyPart), CreateLargeObjectRequest metadata = default(CreateLargeObjectRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a LargeObject
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createLargeObjectRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LargeObject</returns>
        System.Threading.Tasks.Task<LargeObject> CreateLargeObject1Async(CreateLargeObjectRequest createLargeObjectRequest = default(CreateLargeObjectRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a LargeObject
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createLargeObjectRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LargeObject)</returns>
        System.Threading.Tasks.Task<ApiResponse<LargeObject>> CreateLargeObject1WithHttpInfoAsync(CreateLargeObjectRequest createLargeObjectRequest = default(CreateLargeObjectRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a LargeObject from provided URL
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createLargeObjectFromUrlRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LargeObject</returns>
        System.Threading.Tasks.Task<LargeObject> CreateLargeObjectFromUrlAsync(CreateLargeObjectFromUrlRequest createLargeObjectFromUrlRequest = default(CreateLargeObjectFromUrlRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a LargeObject from provided URL
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createLargeObjectFromUrlRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LargeObject)</returns>
        System.Threading.Tasks.Task<ApiResponse<LargeObject>> CreateLargeObjectFromUrlWithHttpInfoAsync(CreateLargeObjectFromUrlRequest createLargeObjectFromUrlRequest = default(CreateLargeObjectFromUrlRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a New Leaderboard
        /// </summary>
        /// <remarks>
        /// Gets the metadata for a single leaderboard.  This may include more specific details not available in the bulk-get or fetch operation.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboard"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Leaderboard</returns>
        System.Threading.Tasks.Task<Leaderboard> CreateLeaderboardAsync(Leaderboard leaderboard = default(Leaderboard), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a New Leaderboard
        /// </summary>
        /// <remarks>
        /// Gets the metadata for a single leaderboard.  This may include more specific details not available in the bulk-get or fetch operation.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboard"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Leaderboard)</returns>
        System.Threading.Tasks.Task<ApiResponse<Leaderboard>> CreateLeaderboardWithHttpInfoAsync(Leaderboard leaderboard = default(Leaderboard), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a Match
        /// </summary>
        /// <remarks>
        /// This method accepts an instance of Match, effectively requesting that the server find a suitable opponent for a game.  As other suitable players create matches the created match object may be updated as a suitable opponent is found.  The client must poll matches for updates and react accordingly.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="match"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Match</returns>
        System.Threading.Tasks.Task<Match> CreateMatchAsync(Match match = default(Match), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a Match
        /// </summary>
        /// <remarks>
        /// This method accepts an instance of Match, effectively requesting that the server find a suitable opponent for a game.  As other suitable players create matches the created match object may be updated as a suitable opponent is found.  The client must poll matches for updates and react accordingly.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="match"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Match)</returns>
        System.Threading.Tasks.Task<ApiResponse<Match>> CreateMatchWithHttpInfoAsync(Match match = default(Match), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a new iOS ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Creates a new iOS ApplicationConfiguration with the specific ID or application.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="matchmakingApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MatchmakingApplicationConfiguration</returns>
        System.Threading.Tasks.Task<MatchmakingApplicationConfiguration> CreateMatchmakingApplicationConfigurationAsync(string applicationNameOrId, MatchmakingApplicationConfiguration matchmakingApplicationConfiguration = default(MatchmakingApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a new iOS ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Creates a new iOS ApplicationConfiguration with the specific ID or application.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="matchmakingApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MatchmakingApplicationConfiguration)</returns>
        System.Threading.Tasks.Task<ApiResponse<MatchmakingApplicationConfiguration>> CreateMatchmakingApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, MatchmakingApplicationConfiguration matchmakingApplicationConfiguration = default(MatchmakingApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a new Metadata object
        /// </summary>
        /// <remarks>
        /// Creates a new Metadata object with the provided details.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createMetadataRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Metadata</returns>
        System.Threading.Tasks.Task<Metadata> CreateMetadataAsync(CreateMetadataRequest createMetadataRequest = default(CreateMetadataRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a new Metadata object
        /// </summary>
        /// <remarks>
        /// Creates a new Metadata object with the provided details.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createMetadataRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Metadata)</returns>
        System.Threading.Tasks.Task<ApiResponse<Metadata>> CreateMetadataWithHttpInfoAsync(CreateMetadataRequest createMetadataRequest = default(CreateMetadataRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a new Metadata Spec definition
        /// </summary>
        /// <remarks>
        /// Creates a new Metadata Spec definition.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createMetadataSpecRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MetadataSpec</returns>
        System.Threading.Tasks.Task<MetadataSpec> CreateMetadataSpecAsync(CreateMetadataSpecRequest createMetadataSpecRequest = default(CreateMetadataSpecRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a new Metadata Spec definition
        /// </summary>
        /// <remarks>
        /// Creates a new Metadata Spec definition.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createMetadataSpecRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MetadataSpec)</returns>
        System.Threading.Tasks.Task<ApiResponse<MetadataSpec>> CreateMetadataSpecWithHttpInfoAsync(CreateMetadataSpecRequest createMetadataSpecRequest = default(CreateMetadataSpecRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a new mission
        /// </summary>
        /// <remarks>
        /// Supplying a mission object, this will create a new mission with a newly assigned unique id.  The Mission representation returned in the response body is a representation of the Mission as persisted with a unique identifier assigned and with its fields properly normalized.  The supplied mission object submitted with the request must have a name property that is unique across all items.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mission"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Mission</returns>
        System.Threading.Tasks.Task<Mission> CreateMissionAsync(Mission mission = default(Mission), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a new mission
        /// </summary>
        /// <remarks>
        /// Supplying a mission object, this will create a new mission with a newly assigned unique id.  The Mission representation returned in the response body is a representation of the Mission as persisted with a unique identifier assigned and with its fields properly normalized.  The supplied mission object submitted with the request must have a name property that is unique across all items.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mission"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Mission)</returns>
        System.Threading.Tasks.Task<ApiResponse<Mission>> CreateMissionWithHttpInfoAsync(Mission mission = default(Mission), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a Mock Session
        /// </summary>
        /// <remarks>
        /// Begins a session by accepting a mock session request.  The request must be made with an authenticated super-user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mockSessionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MockSessionCreation</returns>
        System.Threading.Tasks.Task<MockSessionCreation> CreateMockSessionAsync(MockSessionRequest mockSessionRequest = default(MockSessionRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a Mock Session
        /// </summary>
        /// <remarks>
        /// Begins a session by accepting a mock session request.  The request must be made with an authenticated super-user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mockSessionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MockSessionCreation)</returns>
        System.Threading.Tasks.Task<ApiResponse<MockSessionCreation>> CreateMockSessionWithHttpInfoAsync(MockSessionRequest mockSessionRequest = default(MockSessionRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="createDeploymentRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Deployment</returns>
        System.Threading.Tasks.Task<Deployment> CreateNewDeploymentAsync(string applicationId, CreateDeploymentRequest createDeploymentRequest = default(CreateDeploymentRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="createDeploymentRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Deployment)</returns>
        System.Threading.Tasks.Task<ApiResponse<Deployment>> CreateNewDeploymentWithHttpInfoAsync(string applicationId, CreateDeploymentRequest createDeploymentRequest = default(CreateDeploymentRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a Session using OAuth2
        /// </summary>
        /// <remarks>
        /// Begins a session by accepting a session request with parameters matching the specified OAuth2 Scheme. Upon successful validation against the scheme provided in the path, this will return a Session which can be used for authentication. If there is no User associated with the supplied credentials, this will implicitly create a new account and will include that account information in the response. If there is an account, or this method receives an existing session key, this will link to the existing scheme if the account was not previously linked.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2SessionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SessionCreation</returns>
        System.Threading.Tasks.Task<SessionCreation> CreateOAuth2SessionAsync(OAuth2SessionRequest oAuth2SessionRequest = default(OAuth2SessionRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a Session using OAuth2
        /// </summary>
        /// <remarks>
        /// Begins a session by accepting a session request with parameters matching the specified OAuth2 Scheme. Upon successful validation against the scheme provided in the path, this will return a Session which can be used for authentication. If there is no User associated with the supplied credentials, this will implicitly create a new account and will include that account information in the response. If there is an account, or this method receives an existing session key, this will link to the existing scheme if the account was not previously linked.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2SessionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SessionCreation)</returns>
        System.Threading.Tasks.Task<ApiResponse<SessionCreation>> CreateOAuth2SessionWithHttpInfoAsync(OAuth2SessionRequest oAuth2SessionRequest = default(OAuth2SessionRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a Session using OIDC
        /// </summary>
        /// <remarks>
        /// Begins a session by accepting a JWT. Upon successful validation against the scheme provided in the path, this will return a Session which can be used for authentication. If there is no User associated with the supplied credentials, this will implicitly create a new account and will include that account information in the response. If there is an account, or this method receives an existing session key, this will link to the existing scheme if the account was not previously linked.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcSessionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SessionCreation</returns>
        System.Threading.Tasks.Task<SessionCreation> CreateOidcSessionAsync(OidcSessionRequest oidcSessionRequest = default(OidcSessionRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a Session using OIDC
        /// </summary>
        /// <remarks>
        /// Begins a session by accepting a JWT. Upon successful validation against the scheme provided in the path, this will return a Session which can be used for authentication. If there is no User associated with the supplied credentials, this will implicitly create a new account and will include that account information in the response. If there is an account, or this method receives an existing session key, this will link to the existing scheme if the account was not previously linked.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcSessionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SessionCreation)</returns>
        System.Threading.Tasks.Task<ApiResponse<SessionCreation>> CreateOidcSessionWithHttpInfoAsync(OidcSessionRequest oidcSessionRequest = default(OidcSessionRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a new PSN ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Creates a new PSN ApplicationConfiguration with the specific ID or application.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="pSNApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PSNApplicationConfiguration</returns>
        System.Threading.Tasks.Task<PSNApplicationConfiguration> CreatePSNApplicationConfigurationAsync(string applicationNameOrId, PSNApplicationConfiguration pSNApplicationConfiguration = default(PSNApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a new PSN ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Creates a new PSN ApplicationConfiguration with the specific ID or application.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="pSNApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PSNApplicationConfiguration)</returns>
        System.Threading.Tasks.Task<ApiResponse<PSNApplicationConfiguration>> CreatePSNApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, PSNApplicationConfiguration pSNApplicationConfiguration = default(PSNApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a Profile
        /// </summary>
        /// <remarks>
        /// Supplying the create profile request, this will update the profile with the new information supplied in the body of the request. This will fire an event, dev.getelements.elements.service.profile.created, from the event manifest.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createProfileRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Profile</returns>
        System.Threading.Tasks.Task<Profile> CreateProfileAsync(CreateProfileRequest createProfileRequest = default(CreateProfileRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a Profile
        /// </summary>
        /// <remarks>
        /// Supplying the create profile request, this will update the profile with the new information supplied in the body of the request. This will fire an event, dev.getelements.elements.service.profile.created, from the event manifest.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createProfileRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Profile)</returns>
        System.Threading.Tasks.Task<ApiResponse<Profile>> CreateProfileWithHttpInfoAsync(CreateProfileRequest createProfileRequest = default(CreateProfileRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a new progress
        /// </summary>
        /// <remarks>
        /// Supplying a progress object, this will create a new progress with a newly assigned unique id.  The Progress representation returned in the response body is a representation of the Progress as persisted with a unique identifier assigned and with its fields properly normalized.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progress"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Progress</returns>
        System.Threading.Tasks.Task<Progress> CreateProgressAsync(Progress progress = default(Progress), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a new progress
        /// </summary>
        /// <remarks>
        /// Supplying a progress object, this will create a new progress with a newly assigned unique id.  The Progress representation returned in the response body is a representation of the Progress as persisted with a unique identifier assigned and with its fields properly normalized.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progress"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Progress)</returns>
        System.Threading.Tasks.Task<ApiResponse<Progress>> CreateProgressWithHttpInfoAsync(Progress progress = default(Progress), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a save data document.
        /// </summary>
        /// <remarks>
        /// Gets a single save data document.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createSaveDataDocumentRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SaveDataDocument</returns>
        System.Threading.Tasks.Task<SaveDataDocument> CreateSaveDocumentAsync(CreateSaveDataDocumentRequest createSaveDataDocumentRequest = default(CreateSaveDataDocumentRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a save data document.
        /// </summary>
        /// <remarks>
        /// Gets a single save data document.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createSaveDataDocumentRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SaveDataDocument)</returns>
        System.Threading.Tasks.Task<ApiResponse<SaveDataDocument>> CreateSaveDocumentWithHttpInfoAsync(CreateSaveDataDocumentRequest createSaveDataDocumentRequest = default(CreateSaveDataDocumentRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a new schedule
        /// </summary>
        /// <remarks>
        /// Supplying a schedule object, this will create a new schedule with a newly assigned unique id.  The Schedule representation returned in the response body is a representation of the Schedule as persisted with a unique identifier assigned and with its fields properly normalized.  The supplied schedule object submitted with the request must have a name property that is unique across all items.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createScheduleRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Schedule</returns>
        System.Threading.Tasks.Task<Schedule> CreateScheduleAsync(CreateScheduleRequest createScheduleRequest = default(CreateScheduleRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a new schedule
        /// </summary>
        /// <remarks>
        /// Supplying a schedule object, this will create a new schedule with a newly assigned unique id.  The Schedule representation returned in the response body is a representation of the Schedule as persisted with a unique identifier assigned and with its fields properly normalized.  The supplied schedule object submitted with the request must have a name property that is unique across all items.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createScheduleRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Schedule)</returns>
        System.Threading.Tasks.Task<ApiResponse<Schedule>> CreateScheduleWithHttpInfoAsync(CreateScheduleRequest createScheduleRequest = default(CreateScheduleRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a new schedule
        /// </summary>
        /// <remarks>
        /// Supplying a schedule object, this will create a new schedule with a newly assigned unique id.  The ScheduleEvent representation returned in the response body is a representation of the ScheduleEvent as persisted with a unique identifier assigned and with its fields properly normalized.  The supplied schedule object submitted with the request must have a name property that is unique across all items.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="createScheduleEventRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ScheduleEvent</returns>
        System.Threading.Tasks.Task<ScheduleEvent> CreateScheduleEventAsync(string scheduleNameOrId, CreateScheduleEventRequest createScheduleEventRequest = default(CreateScheduleEventRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a new schedule
        /// </summary>
        /// <remarks>
        /// Supplying a schedule object, this will create a new schedule with a newly assigned unique id.  The ScheduleEvent representation returned in the response body is a representation of the ScheduleEvent as persisted with a unique identifier assigned and with its fields properly normalized.  The supplied schedule object submitted with the request must have a name property that is unique across all items.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="createScheduleEventRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ScheduleEvent)</returns>
        System.Threading.Tasks.Task<ApiResponse<ScheduleEvent>> CreateScheduleEventWithHttpInfoAsync(string scheduleNameOrId, CreateScheduleEventRequest createScheduleEventRequest = default(CreateScheduleEventRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a New Score
        /// </summary>
        /// <remarks>
        /// Posts a single score for the currently logged-in profile. Conceptually, this is creationg a new resource, however the server may opt to overwrite the existing identifier if it sees fit.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">The name or id of the leaderboard.</param>
        /// <param name="score"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Score</returns>
        System.Threading.Tasks.Task<Score> CreateScoreAsync(string leaderboardNameOrId, Score score = default(Score), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a New Score
        /// </summary>
        /// <remarks>
        /// Posts a single score for the currently logged-in profile. Conceptually, this is creationg a new resource, however the server may opt to overwrite the existing identifier if it sees fit.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">The name or id of the leaderboard.</param>
        /// <param name="score"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Score)</returns>
        System.Threading.Tasks.Task<ApiResponse<Score>> CreateScoreWithHttpInfoAsync(string leaderboardNameOrId, Score score = default(Score), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Create an inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Create an inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createSimpleInventoryItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InventoryItem</returns>
        System.Threading.Tasks.Task<InventoryItem> CreateSimpleInventoryItemAsync(CreateSimpleInventoryItemRequest createSimpleInventoryItemRequest = default(CreateSimpleInventoryItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Create an inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Create an inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createSimpleInventoryItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InventoryItem)</returns>
        System.Threading.Tasks.Task<ApiResponse<InventoryItem>> CreateSimpleInventoryItemWithHttpInfoAsync(CreateSimpleInventoryItemRequest createSimpleInventoryItemRequest = default(CreateSimpleInventoryItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Patches a  Smart Contract
        /// </summary>
        /// <remarks>
        /// Patches a  Smart Contract entry, associated with the specified deployed script hash.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createSmartContractRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SmartContract</returns>
        System.Threading.Tasks.Task<SmartContract> CreateSmartContractAsync(CreateSmartContractRequest createSmartContractRequest = default(CreateSmartContractRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Patches a  Smart Contract
        /// </summary>
        /// <remarks>
        /// Patches a  Smart Contract entry, associated with the specified deployed script hash.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createSmartContractRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SmartContract)</returns>
        System.Threading.Tasks.Task<ApiResponse<SmartContract>> CreateSmartContractWithHttpInfoAsync(CreateSmartContractRequest createSmartContractRequest = default(CreateSmartContractRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a User
        /// </summary>
        /// <remarks>
        /// Supplying the user object, this will update the user with the new information supplied in the body of the request.  Optionally, the user&#39;s password may be provided in the User object.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userCreateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UserCreateResponse</returns>
        System.Threading.Tasks.Task<UserCreateResponse> CreateUserAsync(UserCreateRequest userCreateRequest = default(UserCreateRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a User
        /// </summary>
        /// <remarks>
        /// Supplying the user object, this will update the user with the new information supplied in the body of the request.  Optionally, the user&#39;s password may be provided in the User object.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userCreateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UserCreateResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<UserCreateResponse>> CreateUserWithHttpInfoAsync(UserCreateRequest userCreateRequest = default(UserCreateRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a Session
        /// </summary>
        /// <remarks>
        /// Begins a session by accepting both the UserID and the Passoword.  Upon successful completion of this call, the user will be added to the current HTTP session.  If the session expires, the user will have to reestablish the session by supplying credentials again.  This is most useful for applications delivered in a web page.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="usernamePasswordSessionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SessionCreation</returns>
        System.Threading.Tasks.Task<SessionCreation> CreateUsernamePasswordSessionAsync(UsernamePasswordSessionRequest usernamePasswordSessionRequest = default(UsernamePasswordSessionRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a Session
        /// </summary>
        /// <remarks>
        /// Begins a session by accepting both the UserID and the Passoword.  Upon successful completion of this call, the user will be added to the current HTTP session.  If the session expires, the user will have to reestablish the session by supplying credentials again.  This is most useful for applications delivered in a web page.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="usernamePasswordSessionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SessionCreation)</returns>
        System.Threading.Tasks.Task<ApiResponse<SessionCreation>> CreateUsernamePasswordSessionWithHttpInfoAsync(UsernamePasswordSessionRequest usernamePasswordSessionRequest = default(UsernamePasswordSessionRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a new  Vault
        /// </summary>
        /// <remarks>
        /// Creates a new  Vault, associated with the given user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createVaultRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Vault</returns>
        System.Threading.Tasks.Task<Vault> CreateVaultAsync(CreateVaultRequest createVaultRequest = default(CreateVaultRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a new  Vault
        /// </summary>
        /// <remarks>
        /// Creates a new  Vault, associated with the given user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createVaultRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Vault)</returns>
        System.Threading.Tasks.Task<ApiResponse<Vault>> CreateVaultWithHttpInfoAsync(CreateVaultRequest createVaultRequest = default(CreateVaultRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a new  Wallet
        /// </summary>
        /// <remarks>
        /// Creates a new  Wallet, associated with the given user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="createWalletRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Wallet</returns>
        System.Threading.Tasks.Task<Wallet> CreateWalletAsync(string vaultId, CreateWalletRequest createWalletRequest = default(CreateWalletRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a new  Wallet
        /// </summary>
        /// <remarks>
        /// Creates a new  Wallet, associated with the given user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="createWalletRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Wallet)</returns>
        System.Threading.Tasks.Task<ApiResponse<Wallet>> CreateWalletWithHttpInfoAsync(string vaultId, CreateWalletRequest createWalletRequest = default(CreateWalletRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes a Profile
        /// </summary>
        /// <remarks>
        /// Deletes and permanently removes the Profile from the server.  The server maykeep some record around to preserve relationships and references, but this profile will not be accessible again until it is recreated.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeactivateProfileAsync(string profileId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes a Profile
        /// </summary>
        /// <remarks>
        /// Deletes and permanently removes the Profile from the server.  The server maykeep some record around to preserve relationships and references, but this profile will not be accessible again until it is recreated.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeactivateProfileWithHttpInfoAsync(string profileId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes a User
        /// </summary>
        /// <remarks>
        /// Deletes and permanently removes the user from the server.  The server may keep some metadata as necessary to avoid data inconsistency.  However, the user has been deleted from the client standpoint and will not be accessible through any of the existing APIs.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeactivateUserAsync(string name, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes a User
        /// </summary>
        /// <remarks>
        /// Deletes and permanently removes the user from the server.  The server may keep some metadata as necessary to avoid data inconsistency.  However, the user has been deleted from the client standpoint and will not be accessible through any of the existing APIs.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeactivateUserWithHttpInfoAsync(string name, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Delete the inventory item as identified by the given item name/id
        /// </summary>
        /// <remarks>
        /// Delete the inventory item as identified by the given item name/id
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteAdvancedInventoryItemAsync(string inventoryItemId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Delete the inventory item as identified by the given item name/id
        /// </summary>
        /// <remarks>
        /// Delete the inventory item as identified by the given item name/id
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteAdvancedInventoryItemWithHttpInfoAsync(string inventoryItemId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes an Application
        /// </summary>
        /// <remarks>
        /// Deletes a specific application known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteApplicationAsync(string nameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes an Application
        /// </summary>
        /// <remarks>
        /// Deletes a specific application known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteApplicationWithHttpInfoAsync(string nameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes an Auth Scheme
        /// </summary>
        /// <remarks>
        /// Deletes an Auth Scheme with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSchemeId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteAuthSchemeAsync(string authSchemeId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes an Auth Scheme
        /// </summary>
        /// <remarks>
        /// Deletes an Auth Scheme with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSchemeId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteAuthSchemeWithHttpInfoAsync(string authSchemeId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes an Auth Scheme
        /// </summary>
        /// <remarks>
        /// Deletes an Auth Scheme with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2AuthSchemeId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteAuthScheme1Async(string oAuth2AuthSchemeId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes an Auth Scheme
        /// </summary>
        /// <remarks>
        /// Deletes an Auth Scheme with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2AuthSchemeId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteAuthScheme1WithHttpInfoAsync(string oAuth2AuthSchemeId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes an Auth Scheme
        /// </summary>
        /// <remarks>
        /// Deletes an Auth Scheme with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcAuthSchemeId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteAuthScheme2Async(string oidcAuthSchemeId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes an Auth Scheme
        /// </summary>
        /// <remarks>
        /// Deletes an Auth Scheme with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcAuthSchemeId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteAuthScheme2WithHttpInfoAsync(string oidcAuthSchemeId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes a  Smart Contract
        /// </summary>
        /// <remarks>
        /// Deletes a  Smart Contract with the specified contractId.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteContractAsync(string contractId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes a  Smart Contract
        /// </summary>
        /// <remarks>
        /// Deletes a  Smart Contract with the specified contractId.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteContractWithHttpInfoAsync(string contractId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="deploymentId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteDeploymentAsync(string applicationId, string deploymentId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="deploymentId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteDeploymentWithHttpInfoAsync(string applicationId, string deploymentId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Delete the inventory item as identified by the given item name/id
        /// </summary>
        /// <remarks>
        /// Delete the inventory item as identified by the given item name/id
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="distinctInventoryItemId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteDistinctInventoryItemAsync(string distinctInventoryItemId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Delete the inventory item as identified by the given item name/id
        /// </summary>
        /// <remarks>
        /// Delete the inventory item as identified by the given item name/id
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="distinctInventoryItemId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteDistinctInventoryItemWithHttpInfoAsync(string distinctInventoryItemId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fcmRegistrationId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteFCMRegistrationAsync(string fcmRegistrationId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fcmRegistrationId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteFCMRegistrationWithHttpInfoAsync(string fcmRegistrationId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes a Facebook ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Deletes an existing Facebook Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteFacebookApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes a Facebook ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Deletes an existing Facebook Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteFacebookApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes a Firebase ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Deletes an existing Firebase Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteFirebaseApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes a Firebase ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Deletes an existing Firebase Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteFirebaseApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes a Follower relationship
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="profileToUnfollowId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteFollowerAsync(string profileId, string profileToUnfollowId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes a Follower relationship
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="profileToUnfollowId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteFollowerWithHttpInfoAsync(string profileId, string profileToUnfollowId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes a Friend
        /// </summary>
        /// <remarks>
        /// Once a friend is deleted, re-creating a friend will set the friendship status to outgoing.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="friendId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteFriendRegistrationAsync(string friendId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes a Friend
        /// </summary>
        /// <remarks>
        /// Once a friend is deleted, re-creating a friend will set the friendship status to outgoing.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="friendId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteFriendRegistrationWithHttpInfoAsync(string friendId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes a Google Play ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Deletes an existing Google Play Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteGooglePlayApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes a Google Play ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Deletes an existing Google Play Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteGooglePlayApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes a iOS ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Deletes an existing iOS Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteIosApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes a iOS ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Deletes an existing iOS Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteIosApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes a LargeObject
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteLargeObjectAsync(string largeObjectId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes a LargeObject
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteLargeObjectWithHttpInfoAsync(string largeObjectId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes an Leaderboard
        /// </summary>
        /// <remarks>
        /// Deletes a specific leaderboard known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteLeaderboardAsync(string nameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes an Leaderboard
        /// </summary>
        /// <remarks>
        /// Deletes a specific leaderboard known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteLeaderboardWithHttpInfoAsync(string nameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes a Match
        /// </summary>
        /// <remarks>
        /// Deletes and permanently removes the Match fromt he server.  This effectively will cancel any pending request for a match.  If a game is currently being played agaist the match, the server may reject the request to delete the match until the game concludes.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteMatchAsync(string matchId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes a Match
        /// </summary>
        /// <remarks>
        /// Deletes and permanently removes the Match fromt he server.  This effectively will cancel any pending request for a match.  If a game is currently being played agaist the match, the server may reject the request to delete the match until the game concludes.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteMatchWithHttpInfoAsync(string matchId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes a iOS ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Deletes an existing iOS Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteMatchmakingApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes a iOS ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Deletes an existing iOS Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteMatchmakingApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes a specific Metadata object
        /// </summary>
        /// <remarks>
        /// Deletes a specific metadata object by name or id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteMetadataAsync(string id, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes a specific Metadata object
        /// </summary>
        /// <remarks>
        /// Deletes a specific metadata object by name or id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteMetadataWithHttpInfoAsync(string id, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes a MetadataSpec
        /// </summary>
        /// <remarks>
        /// Deletes a MetadataSpec with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteMetadataSpecAsync(string metadataSpecId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes a MetadataSpec
        /// </summary>
        /// <remarks>
        /// Deletes a MetadataSpec with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteMetadataSpecWithHttpInfoAsync(string metadataSpecId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes the Mission identified by id or by name
        /// </summary>
        /// <remarks>
        /// Deletes a mission by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="missionNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteMissionAsync(string missionNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes the Mission identified by id or by name
        /// </summary>
        /// <remarks>
        /// Deletes a mission by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="missionNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteMissionWithHttpInfoAsync(string missionNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes a PSN ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Deletes an existing PSN Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeletePSNApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes a PSN ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Deletes an existing PSN Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeletePSNApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes the Progress identified by id
        /// </summary>
        /// <remarks>
        /// Deletes a progress by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progressId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteProgressAsync(string progressId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes the Progress identified by id
        /// </summary>
        /// <remarks>
        /// Deletes a progress by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progressId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteProgressWithHttpInfoAsync(string progressId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes a save data document
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="saveDataDocumentId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteSaveDocumentAsync(string saveDataDocumentId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes a save data document
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="saveDataDocumentId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteSaveDocumentWithHttpInfoAsync(string saveDataDocumentId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes the Schedule identified by id or by name
        /// </summary>
        /// <remarks>
        /// Deletes a schedule by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteScheduleAsync(string scheduleNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes the Schedule identified by id or by name
        /// </summary>
        /// <remarks>
        /// Deletes a schedule by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteScheduleWithHttpInfoAsync(string scheduleNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes the ScheduleEvent identified by id or by name
        /// </summary>
        /// <remarks>
        /// Deletes a schedule by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="scheduleEventId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteScheduleEventAsync(string scheduleNameOrId, string scheduleEventId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes the ScheduleEvent identified by id or by name
        /// </summary>
        /// <remarks>
        /// Deletes a schedule by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="scheduleEventId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteScheduleEventWithHttpInfoAsync(string scheduleNameOrId, string scheduleEventId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Delete the inventory item as identified by the given item name/id
        /// </summary>
        /// <remarks>
        /// Delete the inventory item as identified by the given item name/id
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteSimpleInventoryItemAsync(string inventoryItemId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Delete the inventory item as identified by the given item name/id
        /// </summary>
        /// <remarks>
        /// Delete the inventory item as identified by the given item name/id
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteSimpleInventoryItemWithHttpInfoAsync(string inventoryItemId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes a  Vault
        /// </summary>
        /// <remarks>
        /// Deletes a  Vault with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteVaultAsync(string vaultId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes a  Vault
        /// </summary>
        /// <remarks>
        /// Deletes a  Vault with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteVaultWithHttpInfoAsync(string vaultId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Deletes a  Wallet
        /// </summary>
        /// <remarks>
        /// Deletes a  Wallet with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="walletId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteWalletAsync(string vaultId, string walletId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Deletes a  Wallet
        /// </summary>
        /// <remarks>
        /// Deletes a  Wallet with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="walletId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteWalletWithHttpInfoAsync(string vaultId, string walletId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Generate Client API Code
        /// </summary>
        /// <remarks>
        /// Generates API code for use on the client. Will generate Elements core if no application is specified in the request body.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="codegenRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task GenerateCodeAsync(CodegenRequest codegenRequest = default(CodegenRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Generate Client API Code
        /// </summary>
        /// <remarks>
        /// Generates API code for use on the client. Will generate Elements core if no application is specified in the request body.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="codegenRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> GenerateCodeWithHttpInfoAsync(CodegenRequest codegenRequest = default(CodegenRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Gets the first (primary) inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InventoryItem</returns>
        System.Threading.Tasks.Task<InventoryItem> GetAdvancedInventoryItemAsync(string inventoryItemId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Gets the first (primary) inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InventoryItem)</returns>
        System.Threading.Tasks.Task<ApiResponse<InventoryItem>> GetAdvancedInventoryItemWithHttpInfoAsync(string inventoryItemId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Search inventory items
        /// </summary>
        /// <remarks>
        /// Searches all inventory items in the system and returns the metadata for all matches against the given search filter.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationInventoryItem</returns>
        System.Threading.Tasks.Task<PaginationInventoryItem> GetAdvancedInventoryItemsAsync(int? offset = default(int?), int? count = default(int?), string userId = default(string), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Search inventory items
        /// </summary>
        /// <remarks>
        /// Searches all inventory items in the system and returns the metadata for all matches against the given search filter.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationInventoryItem)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationInventoryItem>> GetAdvancedInventoryItemsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), string userId = default(string), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Get an Application
        /// </summary>
        /// <remarks>
        /// Gets the metadata for a single application.  This may include more specific details not available in the bulk-get or fetch operation.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Application</returns>
        System.Threading.Tasks.Task<Application> GetApplicationAsync(string nameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Get an Application
        /// </summary>
        /// <remarks>
        /// Gets the metadata for a single application.  This may include more specific details not available in the bulk-get or fetch operation.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Application)</returns>
        System.Threading.Tasks.Task<ApiResponse<Application>> GetApplicationWithHttpInfoAsync(string nameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Searches application profiles
        /// </summary>
        /// <remarks>
        /// Searches all instances of ApplicationProfiles associated with  the application.  The search query may be a full text search.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationApplicationConfiguration</returns>
        System.Threading.Tasks.Task<PaginationApplicationConfiguration> GetApplicationProfilesAsync(string applicationNameOrId, int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Searches application profiles
        /// </summary>
        /// <remarks>
        /// Searches all instances of ApplicationProfiles associated with  the application.  The search query may be a full text search.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationApplicationConfiguration)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationApplicationConfiguration>> GetApplicationProfilesWithHttpInfoAsync(string applicationNameOrId, int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Search Applications
        /// </summary>
        /// <remarks>
        /// Performs a full-text search of all applications known to the server.  As with other full-text endpoints this allows for pagination and offset.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationApplication</returns>
        System.Threading.Tasks.Task<PaginationApplication> GetApplicationsAsync(int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Search Applications
        /// </summary>
        /// <remarks>
        /// Performs a full-text search of all applications known to the server.  As with other full-text endpoints this allows for pagination and offset.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationApplication)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationApplication>> GetApplicationsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets a specific Auth Scheme
        /// </summary>
        /// <remarks>
        /// Gets a specific Auth Scheme by the authSchemeId.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSchemeId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of AuthScheme</returns>
        System.Threading.Tasks.Task<AuthScheme> GetAuthSchemeAsync(string authSchemeId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets a specific Auth Scheme
        /// </summary>
        /// <remarks>
        /// Gets a specific Auth Scheme by the authSchemeId.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSchemeId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (AuthScheme)</returns>
        System.Threading.Tasks.Task<ApiResponse<AuthScheme>> GetAuthSchemeWithHttpInfoAsync(string authSchemeId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets a specific Auth Scheme
        /// </summary>
        /// <remarks>
        /// Gets a specific Auth Scheme by the oAuth2AuthSchemeId.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2AuthSchemeId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of OAuth2AuthScheme</returns>
        System.Threading.Tasks.Task<OAuth2AuthScheme> GetAuthScheme1Async(string oAuth2AuthSchemeId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets a specific Auth Scheme
        /// </summary>
        /// <remarks>
        /// Gets a specific Auth Scheme by the oAuth2AuthSchemeId.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2AuthSchemeId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (OAuth2AuthScheme)</returns>
        System.Threading.Tasks.Task<ApiResponse<OAuth2AuthScheme>> GetAuthScheme1WithHttpInfoAsync(string oAuth2AuthSchemeId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets a specific Auth Scheme
        /// </summary>
        /// <remarks>
        /// Gets a specific Auth Scheme by the oidcAuthSchemeId.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcAuthSchemeId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of OidcAuthScheme</returns>
        System.Threading.Tasks.Task<OidcAuthScheme> GetAuthScheme2Async(string oidcAuthSchemeId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets a specific Auth Scheme
        /// </summary>
        /// <remarks>
        /// Gets a specific Auth Scheme by the oidcAuthSchemeId.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcAuthSchemeId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (OidcAuthScheme)</returns>
        System.Threading.Tasks.Task<ApiResponse<OidcAuthScheme>> GetAuthScheme2WithHttpInfoAsync(string oidcAuthSchemeId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Lists all auth schemes in the system
        /// </summary>
        /// <remarks>
        /// Requires SUPERUSER access. Gets a pagination of Auth Schemes for the given query.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationAuthScheme</returns>
        System.Threading.Tasks.Task<PaginationAuthScheme> GetAuthSchemesAsync(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Lists all auth schemes in the system
        /// </summary>
        /// <remarks>
        /// Requires SUPERUSER access. Gets a pagination of Auth Schemes for the given query.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationAuthScheme)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationAuthScheme>> GetAuthSchemesWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Lists all auth schemes in the system
        /// </summary>
        /// <remarks>
        /// Requires SUPERUSER access. Gets a pagination of Auth Schemes for the given query.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationOAuth2AuthScheme</returns>
        System.Threading.Tasks.Task<PaginationOAuth2AuthScheme> GetAuthSchemes1Async(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Lists all auth schemes in the system
        /// </summary>
        /// <remarks>
        /// Requires SUPERUSER access. Gets a pagination of Auth Schemes for the given query.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationOAuth2AuthScheme)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationOAuth2AuthScheme>> GetAuthSchemes1WithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Lists all auth schemes in the system
        /// </summary>
        /// <remarks>
        /// Requires SUPERUSER access. Gets a pagination of Auth Schemes for the given query.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationOidcAuthScheme</returns>
        System.Threading.Tasks.Task<PaginationOidcAuthScheme> GetAuthSchemes2Async(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Lists all auth schemes in the system
        /// </summary>
        /// <remarks>
        /// Requires SUPERUSER access. Gets a pagination of Auth Schemes for the given query.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationOidcAuthScheme)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationOidcAuthScheme>> GetAuthSchemes2WithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Deployment</returns>
        System.Threading.Tasks.Task<Deployment> GetCurrentDeploymentAsync(string applicationId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Deployment)</returns>
        System.Threading.Tasks.Task<ApiResponse<Deployment>> GetCurrentDeploymentWithHttpInfoAsync(string applicationId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets the current Profile
        /// </summary>
        /// <remarks>
        /// This is a special endpoing which fetches the current Profile based on current auth credentials.  This considers the currently loggged-in Dser as well as the Application or Application Configuration against which the User is operating.  This may not be availble, in which case the appopraite error is rasied.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Profile</returns>
        System.Threading.Tasks.Task<Profile> GetCurrentProfileAsync(System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets the current Profile
        /// </summary>
        /// <remarks>
        /// This is a special endpoing which fetches the current Profile based on current auth credentials.  This considers the currently loggged-in Dser as well as the Application or Application Configuration against which the User is operating.  This may not be availble, in which case the appopraite error is rasied.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Profile)</returns>
        System.Threading.Tasks.Task<ApiResponse<Profile>> GetCurrentProfileWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets the current User
        /// </summary>
        /// <remarks>
        /// A special endpoint used to get the current user for the request.  The current user is typically associated with the session but may be derived any other way.  This is essentially an alias for using GET /user/myUserId
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of User</returns>
        System.Threading.Tasks.Task<User> GetCurrentUserAsync(System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets the current User
        /// </summary>
        /// <remarks>
        /// A special endpoint used to get the current user for the request.  The current user is typically associated with the session but may be derived any other way.  This is essentially an alias for using GET /user/myUserId
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (User)</returns>
        System.Threading.Tasks.Task<ApiResponse<User>> GetCurrentUserWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="deploymentId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Deployment</returns>
        System.Threading.Tasks.Task<Deployment> GetDeploymentAsync(string applicationId, string deploymentId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="deploymentId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Deployment)</returns>
        System.Threading.Tasks.Task<ApiResponse<Deployment>> GetDeploymentWithHttpInfoAsync(string applicationId, string deploymentId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationDeployment</returns>
        System.Threading.Tasks.Task<PaginationDeployment> GetDeploymentsAsync(string applicationId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationDeployment)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationDeployment>> GetDeploymentsWithHttpInfoAsync(string applicationId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Gets the first (primary) inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of DistinctInventoryItem</returns>
        System.Threading.Tasks.Task<DistinctInventoryItem> GetDistinctInventoryItemAsync(string inventoryItemId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Gets the first (primary) inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (DistinctInventoryItem)</returns>
        System.Threading.Tasks.Task<ApiResponse<DistinctInventoryItem>> GetDistinctInventoryItemWithHttpInfoAsync(string inventoryItemId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Search inventory items
        /// </summary>
        /// <remarks>
        /// Searches all inventory items in the system and returns the metadata for all matches against the given search filter.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="profileId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationDistinctInventoryItem</returns>
        System.Threading.Tasks.Task<PaginationDistinctInventoryItem> GetDistinctInventoryItemsAsync(int? offset = default(int?), int? count = default(int?), string userId = default(string), string profileId = default(string), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Search inventory items
        /// </summary>
        /// <remarks>
        /// Searches all inventory items in the system and returns the metadata for all matches against the given search filter.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="profileId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationDistinctInventoryItem)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationDistinctInventoryItem>> GetDistinctInventoryItemsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), string userId = default(string), string profileId = default(string), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets a specific Metadata Editor Schema
        /// </summary>
        /// <remarks>
        /// Gets a specific Metadata Editor Schema backed by the supplied MetadataSpec by name.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecName"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EditorSchema</returns>
        System.Threading.Tasks.Task<EditorSchema> GetEditorSchemaAsync(string metadataSpecName, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets a specific Metadata Editor Schema
        /// </summary>
        /// <remarks>
        /// Gets a specific Metadata Editor Schema backed by the supplied MetadataSpec by name.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecName"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EditorSchema)</returns>
        System.Threading.Tasks.Task<ApiResponse<EditorSchema>> GetEditorSchemaWithHttpInfoAsync(string metadataSpecName, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets a Facebook Application Configuration
        /// </summary>
        /// <remarks>
        /// Gets a single Facebook application based on unique name or ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FacebookApplicationConfiguration</returns>
        System.Threading.Tasks.Task<FacebookApplicationConfiguration> GetFacebookApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets a Facebook Application Configuration
        /// </summary>
        /// <remarks>
        /// Gets a single Facebook application based on unique name or ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FacebookApplicationConfiguration)</returns>
        System.Threading.Tasks.Task<ApiResponse<FacebookApplicationConfiguration>> GetFacebookApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets a Firebase Application Configuration
        /// </summary>
        /// <remarks>
        /// Gets a single Firebase application based on unique name or ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FirebaseApplicationConfiguration</returns>
        System.Threading.Tasks.Task<FirebaseApplicationConfiguration> GetFirebaseApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets a Firebase Application Configuration
        /// </summary>
        /// <remarks>
        /// Gets a single Firebase application based on unique name or ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FirebaseApplicationConfiguration)</returns>
        System.Threading.Tasks.Task<ApiResponse<FirebaseApplicationConfiguration>> GetFirebaseApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets a specific profile using the ID of the profile and followed id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="followedId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Profile</returns>
        System.Threading.Tasks.Task<Profile> GetFollowerAsync(string profileId, string followedId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets a specific profile using the ID of the profile and followed id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="followedId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Profile)</returns>
        System.Threading.Tasks.Task<ApiResponse<Profile>> GetFollowerWithHttpInfoAsync(string profileId, string followedId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Search Followers
        /// </summary>
        /// <remarks>
        /// Searches all followers in the system and returning the metadata for all matches against the given profile id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationProfile</returns>
        System.Threading.Tasks.Task<PaginationProfile> GetFollowersAsync(string profileId, int? offset = default(int?), int? count = default(int?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Search Followers
        /// </summary>
        /// <remarks>
        /// Searches all followers in the system and returning the metadata for all matches against the given profile id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationProfile)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationProfile>> GetFollowersWithHttpInfoAsync(string profileId, int? offset = default(int?), int? count = default(int?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Search Followers
        /// </summary>
        /// <remarks>
        /// Searches all followers in the system and returning the metadata for all matches against the given profile id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationProfile</returns>
        System.Threading.Tasks.Task<PaginationProfile> GetFollowers1Async(string profileId, int? offset = default(int?), int? count = default(int?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Search Followers
        /// </summary>
        /// <remarks>
        /// Searches all followers in the system and returning the metadata for all matches against the given profile id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationProfile)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationProfile>> GetFollowers1WithHttpInfoAsync(string profileId, int? offset = default(int?), int? count = default(int?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets a Specific Friend
        /// </summary>
        /// <remarks>
        /// Gets a specific friend using the ID of the friend.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="friendId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Friend</returns>
        System.Threading.Tasks.Task<Friend> GetFriendAsync(string friendId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets a Specific Friend
        /// </summary>
        /// <remarks>
        /// Gets a specific friend using the ID of the friend.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="friendId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Friend)</returns>
        System.Threading.Tasks.Task<ApiResponse<Friend>> GetFriendWithHttpInfoAsync(string friendId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Search Friends
        /// </summary>
        /// <remarks>
        /// Searches all friends in the system and returning the metadata for all matches against the given search filter.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationFriend</returns>
        System.Threading.Tasks.Task<PaginationFriend> GetFriendsAsync(int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Search Friends
        /// </summary>
        /// <remarks>
        /// Searches all friends in the system and returning the metadata for all matches against the given search filter.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationFriend)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationFriend>> GetFriendsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets Rank Among all Players
        /// </summary>
        /// <remarks>
        /// Gets the current Profile&#39;s rank among all players for the particular leaderboard.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">Specifies the leaderboard name or ID.</param>
        /// <param name="leaderboardEpoch">Specifies the epoch for the leaderboard. If not provided, the current epoch will be used by default for epochal leaderboards. This value will be ignored for all-time leaderboards. Set this value to 0 to explicitly reference the current epoch (when applicable). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TabulationRankRow</returns>
        System.Threading.Tasks.Task<TabulationRankRow> GetGlobalRankTabularAsync(string leaderboardNameOrId, long? leaderboardEpoch = default(long?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets Rank Among all Players
        /// </summary>
        /// <remarks>
        /// Gets the current Profile&#39;s rank among all players for the particular leaderboard.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">Specifies the leaderboard name or ID.</param>
        /// <param name="leaderboardEpoch">Specifies the epoch for the leaderboard. If not provided, the current epoch will be used by default for epochal leaderboards. This value will be ignored for all-time leaderboards. Set this value to 0 to explicitly reference the current epoch (when applicable). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TabulationRankRow)</returns>
        System.Threading.Tasks.Task<ApiResponse<TabulationRankRow>> GetGlobalRankTabularWithHttpInfoAsync(string leaderboardNameOrId, long? leaderboardEpoch = default(long?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets a Google Play Application Configuration
        /// </summary>
        /// <remarks>
        /// Gets a single Google Play application based on unique name or ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GooglePlayApplicationConfiguration</returns>
        System.Threading.Tasks.Task<GooglePlayApplicationConfiguration> GetGooglePlayApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets a Google Play Application Configuration
        /// </summary>
        /// <remarks>
        /// Gets a single Google Play application based on unique name or ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GooglePlayApplicationConfiguration)</returns>
        System.Threading.Tasks.Task<ApiResponse<GooglePlayApplicationConfiguration>> GetGooglePlayApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets a iOS Application Configuration
        /// </summary>
        /// <remarks>
        /// Gets a single iOS application based on unique name or ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IosApplicationConfiguration</returns>
        System.Threading.Tasks.Task<IosApplicationConfiguration> GetIosApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets a iOS Application Configuration
        /// </summary>
        /// <remarks>
        /// Gets a single iOS application based on unique name or ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IosApplicationConfiguration)</returns>
        System.Threading.Tasks.Task<ApiResponse<IosApplicationConfiguration>> GetIosApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Retrieves a single Item by id or by name
        /// </summary>
        /// <remarks>
        /// Looks up an item by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="identifier"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Item</returns>
        System.Threading.Tasks.Task<Item> GetItemByIdentifierAsync(string identifier, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Retrieves a single Item by id or by name
        /// </summary>
        /// <remarks>
        /// Looks up an item by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="identifier"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Item)</returns>
        System.Threading.Tasks.Task<ApiResponse<Item>> GetItemByIdentifierWithHttpInfoAsync(string identifier, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Retrieves all Items
        /// </summary>
        /// <remarks>
        /// Searches all items and returns all matching items, filtered by the passed in search parameters.  If multiple tags are specified, then all items that contain at least one of the passed in tags is returned.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="category"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationItem</returns>
        System.Threading.Tasks.Task<PaginationItem> GetItemsAsync(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string category = default(string), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Retrieves all Items
        /// </summary>
        /// <remarks>
        /// Searches all items and returns all matching items, filtered by the passed in search parameters.  If multiple tags are specified, then all items that contain at least one of the passed in tags is returned.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="category"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationItem)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationItem>> GetItemsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string category = default(string), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets a specific JSON Schema
        /// </summary>
        /// <remarks>
        /// Gets a specific JSON Schema backed by the supplied MetadataSpec by name.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecName"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of JsonSchema</returns>
        System.Threading.Tasks.Task<JsonSchema> GetJsonSchemaAsync(string metadataSpecName, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets a specific JSON Schema
        /// </summary>
        /// <remarks>
        /// Gets a specific JSON Schema backed by the supplied MetadataSpec by name.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecName"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (JsonSchema)</returns>
        System.Threading.Tasks.Task<ApiResponse<JsonSchema>> GetJsonSchemaWithHttpInfoAsync(string metadataSpecName, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Get a LargeObject
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LargeObject</returns>
        System.Threading.Tasks.Task<LargeObject> GetLargeObjectAsync(string largeObjectId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Get a LargeObject
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LargeObject)</returns>
        System.Threading.Tasks.Task<ApiResponse<LargeObject>> GetLargeObjectWithHttpInfoAsync(string largeObjectId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Get an Leaderboard
        /// </summary>
        /// <remarks>
        /// Gets the metadata for a single leaderboard.  This may include more specific details not availble in the bulk-get or fetch operation.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Leaderboard</returns>
        System.Threading.Tasks.Task<Leaderboard> GetLeaderboardAsync(string nameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Get an Leaderboard
        /// </summary>
        /// <remarks>
        /// Gets the metadata for a single leaderboard.  This may include more specific details not availble in the bulk-get or fetch operation.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Leaderboard)</returns>
        System.Threading.Tasks.Task<ApiResponse<Leaderboard>> GetLeaderboardWithHttpInfoAsync(string nameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Search Leaderboards
        /// </summary>
        /// <remarks>
        /// Performs a full-text search of all leaderboards known to the server.  As with other full-text endpoints this allows for pagination and offset.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationLeaderboard</returns>
        System.Threading.Tasks.Task<PaginationLeaderboard> GetLeaderboardsAsync(int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Search Leaderboards
        /// </summary>
        /// <remarks>
        /// Performs a full-text search of all leaderboards known to the server.  As with other full-text endpoints this allows for pagination and offset.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationLeaderboard)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationLeaderboard>> GetLeaderboardsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets a Specific Match
        /// </summary>
        /// <remarks>
        /// Gets a specific match given the match&#39;s unique ID.  Additionally, it is possible to instruct the API to wait for a period of time before sending the response.  The request will intentionally hang until the requested Match with ID has been updated in the database.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchId"></param>
        /// <param name="socialEngineLongPollTimeout">The maximum amount time the server will wait until a request returns a default set of data for long polling.  Specifying a zero will request that the server wait indefinitely until responding.  Though, the server may enforce a practical upper limit on the amount of time it takes to return.  Omitting this header will prompt the server to treat the request as a normal request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Match</returns>
        System.Threading.Tasks.Task<Match> GetMatchAsync(string matchId, long? socialEngineLongPollTimeout = default(long?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets a Specific Match
        /// </summary>
        /// <remarks>
        /// Gets a specific match given the match&#39;s unique ID.  Additionally, it is possible to instruct the API to wait for a period of time before sending the response.  The request will intentionally hang until the requested Match with ID has been updated in the database.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchId"></param>
        /// <param name="socialEngineLongPollTimeout">The maximum amount time the server will wait until a request returns a default set of data for long polling.  Specifying a zero will request that the server wait indefinitely until responding.  Though, the server may enforce a practical upper limit on the amount of time it takes to return.  Omitting this header will prompt the server to treat the request as a normal request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Match)</returns>
        System.Threading.Tasks.Task<ApiResponse<Match>> GetMatchWithHttpInfoAsync(string matchId, long? socialEngineLongPollTimeout = default(long?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Match normalized phone numbers with requested list
        /// </summary>
        /// <remarks>
        /// Both phones from request and from DB are normalized and compared.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="inviteViaPhonesRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InviteViaPhonesResponse</returns>
        System.Threading.Tasks.Task<InviteViaPhonesResponse> GetMatchedUserProfilesWithPhoneNumbersAsync(int? offset = default(int?), int? count = default(int?), InviteViaPhonesRequest inviteViaPhonesRequest = default(InviteViaPhonesRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Match normalized phone numbers with requested list
        /// </summary>
        /// <remarks>
        /// Both phones from request and from DB are normalized and compared.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="inviteViaPhonesRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InviteViaPhonesResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<InviteViaPhonesResponse>> GetMatchedUserProfilesWithPhoneNumbersWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), InviteViaPhonesRequest inviteViaPhonesRequest = default(InviteViaPhonesRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// List Matches
        /// </summary>
        /// <remarks>
        /// Lists all matches available.  Under most circumstances, this will requires that a profile be made available to the request.  The server may choose to return an error if no suitable profile can be determined.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationMatch</returns>
        System.Threading.Tasks.Task<PaginationMatch> GetMatchesAsync(int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// List Matches
        /// </summary>
        /// <remarks>
        /// Lists all matches available.  Under most circumstances, this will requires that a profile be made available to the request.  The server may choose to return an error if no suitable profile can be determined.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationMatch)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationMatch>> GetMatchesWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets a iOS Application Configuration
        /// </summary>
        /// <remarks>
        /// Gets a single iOS application based on unique name or ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MatchmakingApplicationConfiguration</returns>
        System.Threading.Tasks.Task<MatchmakingApplicationConfiguration> GetMatchmakingApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets a iOS Application Configuration
        /// </summary>
        /// <remarks>
        /// Gets a single iOS application based on unique name or ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MatchmakingApplicationConfiguration)</returns>
        System.Threading.Tasks.Task<ApiResponse<MatchmakingApplicationConfiguration>> GetMatchmakingApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets a specific Metadata object
        /// </summary>
        /// <remarks>
        /// Gets a specific metadata object by name or id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Metadata</returns>
        System.Threading.Tasks.Task<Metadata> GetMetadataObjectAsync(string id, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets a specific Metadata object
        /// </summary>
        /// <remarks>
        /// Gets a specific metadata object by name or id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Metadata)</returns>
        System.Threading.Tasks.Task<ApiResponse<Metadata>> GetMetadataObjectWithHttpInfoAsync(string id, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Search Metadata
        /// </summary>
        /// <remarks>
        /// Searches all metadata in the system and returning all matches against the given search filter.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationMetadata</returns>
        System.Threading.Tasks.Task<PaginationMetadata> GetMetadataObjectsAsync(int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Search Metadata
        /// </summary>
        /// <remarks>
        /// Searches all metadata in the system and returning all matches against the given search filter.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationMetadata)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationMetadata>> GetMetadataObjectsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets a specific Metadata Spec
        /// </summary>
        /// <remarks>
        /// Gets a specific MetadataSpec by name or Id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MetadataSpec</returns>
        System.Threading.Tasks.Task<MetadataSpec> GetMetadataSpecAsync(string metadataSpecNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets a specific Metadata Spec
        /// </summary>
        /// <remarks>
        /// Gets a specific MetadataSpec by name or Id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MetadataSpec)</returns>
        System.Threading.Tasks.Task<ApiResponse<MetadataSpec>> GetMetadataSpecWithHttpInfoAsync(string metadataSpecNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Get Metadata Specs
        /// </summary>
        /// <remarks>
        /// Gets a pagination of Metadata Specs for the given query.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationMetadataSpec</returns>
        System.Threading.Tasks.Task<PaginationMetadataSpec> GetMetadataSpecsAsync(int? offset = default(int?), int? count = default(int?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Get Metadata Specs
        /// </summary>
        /// <remarks>
        /// Gets a pagination of Metadata Specs for the given query.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationMetadataSpec)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationMetadataSpec>> GetMetadataSpecsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Retrieves a single Mission by id or by name
        /// </summary>
        /// <remarks>
        /// Looks up a mission by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="missionNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Mission</returns>
        System.Threading.Tasks.Task<Mission> GetMissionByNameOrIdAsync(string missionNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Retrieves a single Mission by id or by name
        /// </summary>
        /// <remarks>
        /// Looks up a mission by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="missionNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Mission)</returns>
        System.Threading.Tasks.Task<ApiResponse<Mission>> GetMissionByNameOrIdWithHttpInfoAsync(string missionNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Search Missions
        /// </summary>
        /// <remarks>
        /// Searches all missions in the system and returning a number of matches against the given search filter, delimited by the offset and count.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationMission</returns>
        System.Threading.Tasks.Task<PaginationMission> GetMissionsAsync(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Search Missions
        /// </summary>
        /// <remarks>
        /// Searches all missions in the system and returning a number of matches against the given search filter, delimited by the offset and count.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationMission)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationMission>> GetMissionsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets a PSN Application Configuration
        /// </summary>
        /// <remarks>
        /// Gets a single PSN application based on unique name or ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PSNApplicationConfiguration</returns>
        System.Threading.Tasks.Task<PSNApplicationConfiguration> GetPSNApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets a PSN Application Configuration
        /// </summary>
        /// <remarks>
        /// Gets a single PSN application based on unique name or ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PSNApplicationConfiguration)</returns>
        System.Threading.Tasks.Task<ApiResponse<PSNApplicationConfiguration>> GetPSNApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets all index plans.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationIndexPlanObject</returns>
        System.Threading.Tasks.Task<PaginationIndexPlanObject> GetPlansAsync(int? offset = default(int?), int? count = default(int?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets all index plans.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationIndexPlanObject)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationIndexPlanObject>> GetPlansWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets a Specific Profile
        /// </summary>
        /// <remarks>
        /// Gets a specific profile by profile ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Profile</returns>
        System.Threading.Tasks.Task<Profile> GetProfileAsync(string name, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets a Specific Profile
        /// </summary>
        /// <remarks>
        /// Gets a specific profile by profile ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Profile)</returns>
        System.Threading.Tasks.Task<ApiResponse<Profile>> GetProfileWithHttpInfoAsync(string name, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Get save data document.
        /// </summary>
        /// <remarks>
        /// Gets a single save data document based on Profile ID and slot. This is a convenience method whichallows the client to fetch a save data based on slot an profile id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="slot"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SaveDataDocument</returns>
        System.Threading.Tasks.Task<SaveDataDocument> GetProfileSaveDataDocumentBySlotAsync(string profileId, int slot, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Get save data document.
        /// </summary>
        /// <remarks>
        /// Gets a single save data document based on Profile ID and slot. This is a convenience method whichallows the client to fetch a save data based on slot an profile id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="slot"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SaveDataDocument)</returns>
        System.Threading.Tasks.Task<ApiResponse<SaveDataDocument>> GetProfileSaveDataDocumentBySlotWithHttpInfoAsync(string profileId, int slot, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Search Profiles
        /// </summary>
        /// <remarks>
        /// Searches all users in the system and returning the metadata for all matches against the given search filter. Optionally provide &#x60;before&#x60; and &#x60;after&#x60; params to specify a time range [&#x60;after&#x60;, &#x60;before&#x60;] for last-logged-in profiles matching in that range (inclusive). If &#x60;before&#x60; is not specified (or a negative number is provided) but &#x60;after&#x60; is valid, the query will return all records successive to the given &#x60;after&#x60; timestamp. Similarly, if &#x60;after&#x60; is not specified (or a negative number is provided) but &#x60;before&#x60; is valid, the query will return all records preceding the given &#x60;before&#x60; timestamp. Note that search and time range parameters currently cannot be combined in the same query.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="before"> (optional)</param>
        /// <param name="after"> (optional)</param>
        /// <param name="application"> (optional)</param>
        /// <param name="user"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationProfile</returns>
        System.Threading.Tasks.Task<PaginationProfile> GetProfilesAsync(int? offset = default(int?), int? count = default(int?), long? before = default(long?), long? after = default(long?), string application = default(string), string user = default(string), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Search Profiles
        /// </summary>
        /// <remarks>
        /// Searches all users in the system and returning the metadata for all matches against the given search filter. Optionally provide &#x60;before&#x60; and &#x60;after&#x60; params to specify a time range [&#x60;after&#x60;, &#x60;before&#x60;] for last-logged-in profiles matching in that range (inclusive). If &#x60;before&#x60; is not specified (or a negative number is provided) but &#x60;after&#x60; is valid, the query will return all records successive to the given &#x60;after&#x60; timestamp. Similarly, if &#x60;after&#x60; is not specified (or a negative number is provided) but &#x60;before&#x60; is valid, the query will return all records preceding the given &#x60;before&#x60; timestamp. Note that search and time range parameters currently cannot be combined in the same query.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="before"> (optional)</param>
        /// <param name="after"> (optional)</param>
        /// <param name="application"> (optional)</param>
        /// <param name="user"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationProfile)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationProfile>> GetProfilesWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), long? before = default(long?), long? after = default(long?), string application = default(string), string user = default(string), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Retrieves a single Progress by id
        /// </summary>
        /// <remarks>
        /// Looks up a progress by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progressId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Progress</returns>
        System.Threading.Tasks.Task<Progress> GetProgressByNameOrIdAsync(string progressId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Retrieves a single Progress by id
        /// </summary>
        /// <remarks>
        /// Looks up a progress by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progressId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Progress)</returns>
        System.Threading.Tasks.Task<ApiResponse<Progress>> GetProgressByNameOrIdWithHttpInfoAsync(string progressId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets Rank Among all Players
        /// </summary>
        /// <remarks>
        /// Gets the current Profile&#39;s rank among all players for the particular leaderboard.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TabulationProgressRow</returns>
        System.Threading.Tasks.Task<TabulationProgressRow> GetProgressTabularAsync(System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets Rank Among all Players
        /// </summary>
        /// <remarks>
        /// Gets the current Profile&#39;s rank among all players for the particular leaderboard.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TabulationProgressRow)</returns>
        System.Threading.Tasks.Task<ApiResponse<TabulationProgressRow>> GetProgressTabularWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets Rank among Friends
        /// </summary>
        /// <remarks>
        /// Gets the current Profile&#39;s rank among friends for the particular leaderboard.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">Specifies the leaderboard name or ID.</param>
        /// <param name="offset">May be negative to place the requested player in the middle of the page. (optional)</param>
        /// <param name="count">The number of results to return in the page. (optional)</param>
        /// <param name="relative">Indicates whether or not to fetch results in a relative fashion. (optional)</param>
        /// <param name="leaderboardEpoch">Specifies the epoch for the leaderboard. If no value is provided, the current epoch will befetched. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationRank</returns>
        System.Threading.Tasks.Task<PaginationRank> GetRankAmongFriendsAsync(string leaderboardNameOrId, int? offset = default(int?), int? count = default(int?), bool? relative = default(bool?), long? leaderboardEpoch = default(long?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets Rank among Friends
        /// </summary>
        /// <remarks>
        /// Gets the current Profile&#39;s rank among friends for the particular leaderboard.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">Specifies the leaderboard name or ID.</param>
        /// <param name="offset">May be negative to place the requested player in the middle of the page. (optional)</param>
        /// <param name="count">The number of results to return in the page. (optional)</param>
        /// <param name="relative">Indicates whether or not to fetch results in a relative fashion. (optional)</param>
        /// <param name="leaderboardEpoch">Specifies the epoch for the leaderboard. If no value is provided, the current epoch will befetched. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationRank)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationRank>> GetRankAmongFriendsWithHttpInfoAsync(string leaderboardNameOrId, int? offset = default(int?), int? count = default(int?), bool? relative = default(bool?), long? leaderboardEpoch = default(long?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets Rank among Mutual Followers
        /// </summary>
        /// <remarks>
        /// Gets the current Profile&#39;s rank among mutual followers for the particular leaderboard.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">Specifies the leaderboard name or ID.</param>
        /// <param name="offset">May be negative to place the requested player in the middle of the page. (optional)</param>
        /// <param name="count">The number of results to return in the page. (optional)</param>
        /// <param name="relative">Indicates whether or not to fetch results in a relative fashion. (optional)</param>
        /// <param name="leaderboardEpoch">Specifies the epoch for the leaderboard. If no value is provided, the current epoch will befetched. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationRank</returns>
        System.Threading.Tasks.Task<PaginationRank> GetRankAmongMutualFollowersAsync(string leaderboardNameOrId, int? offset = default(int?), int? count = default(int?), bool? relative = default(bool?), long? leaderboardEpoch = default(long?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets Rank among Mutual Followers
        /// </summary>
        /// <remarks>
        /// Gets the current Profile&#39;s rank among mutual followers for the particular leaderboard.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">Specifies the leaderboard name or ID.</param>
        /// <param name="offset">May be negative to place the requested player in the middle of the page. (optional)</param>
        /// <param name="count">The number of results to return in the page. (optional)</param>
        /// <param name="relative">Indicates whether or not to fetch results in a relative fashion. (optional)</param>
        /// <param name="leaderboardEpoch">Specifies the epoch for the leaderboard. If no value is provided, the current epoch will befetched. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationRank)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationRank>> GetRankAmongMutualFollowersWithHttpInfoAsync(string leaderboardNameOrId, int? offset = default(int?), int? count = default(int?), bool? relative = default(bool?), long? leaderboardEpoch = default(long?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Retrieves a single RewardIssuance by id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rewardIssuanceId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of RewardIssuance</returns>
        System.Threading.Tasks.Task<RewardIssuance> GetRewardIssuanceAsync(string rewardIssuanceId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Retrieves a single RewardIssuance by id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rewardIssuanceId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (RewardIssuance)</returns>
        System.Threading.Tasks.Task<ApiResponse<RewardIssuance>> GetRewardIssuanceWithHttpInfoAsync(string rewardIssuanceId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Retrieves the current user&#39;s reward issuances, optionally filtered by the given state.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="states"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationRewardIssuance</returns>
        System.Threading.Tasks.Task<PaginationRewardIssuance> GetRewardIssuancesAsync(int? offset = default(int?), int? count = default(int?), List<string> states = default(List<string>), List<string> tags = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Retrieves the current user&#39;s reward issuances, optionally filtered by the given state.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="states"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationRewardIssuance)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationRewardIssuance>> GetRewardIssuancesWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), List<string> states = default(List<string>), List<string> tags = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Get save data document.
        /// </summary>
        /// <remarks>
        /// Gets a single save data document
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SaveDataDocument</returns>
        System.Threading.Tasks.Task<SaveDataDocument> GetSaveDataDocumentAsync(string id, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Get save data document.
        /// </summary>
        /// <remarks>
        /// Gets a single save data document
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SaveDataDocument)</returns>
        System.Threading.Tasks.Task<ApiResponse<SaveDataDocument>> GetSaveDataDocumentWithHttpInfoAsync(string id, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Search Save Data Documents
        /// </summary>
        /// <remarks>
        /// Gets all save data documents available to the user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="profileId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationSaveDataDocument</returns>
        System.Threading.Tasks.Task<PaginationSaveDataDocument> GetSaveDataDocumentsAsync(int? offset = default(int?), int? count = default(int?), string userId = default(string), string profileId = default(string), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Search Save Data Documents
        /// </summary>
        /// <remarks>
        /// Gets all save data documents available to the user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="profileId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationSaveDataDocument)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationSaveDataDocument>> GetSaveDataDocumentsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), string userId = default(string), string profileId = default(string), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Retrieves a single Schedule by id or by name
        /// </summary>
        /// <remarks>
        /// Looks up a schedule by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Schedule</returns>
        System.Threading.Tasks.Task<Schedule> GetScheduleByNameOrIdAsync(string scheduleNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Retrieves a single Schedule by id or by name
        /// </summary>
        /// <remarks>
        /// Looks up a schedule by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Schedule)</returns>
        System.Threading.Tasks.Task<ApiResponse<Schedule>> GetScheduleByNameOrIdWithHttpInfoAsync(string scheduleNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Retrieves a single ScheduleEvent by id or by name
        /// </summary>
        /// <remarks>
        /// Looks up a schedule by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="scheduleEventId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ScheduleEvent</returns>
        System.Threading.Tasks.Task<ScheduleEvent> GetScheduleEventByNameOrIdAsync(string scheduleNameOrId, string scheduleEventId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Retrieves a single ScheduleEvent by id or by name
        /// </summary>
        /// <remarks>
        /// Looks up a schedule by the passed in identifier
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="scheduleEventId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ScheduleEvent)</returns>
        System.Threading.Tasks.Task<ApiResponse<ScheduleEvent>> GetScheduleEventByNameOrIdWithHttpInfoAsync(string scheduleNameOrId, string scheduleEventId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Search ScheduleEvents
        /// </summary>
        /// <remarks>
        /// Searches all schedules in the system and returning a number of matches against the given search filter, delimited by the offset and count.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationScheduleEvent</returns>
        System.Threading.Tasks.Task<PaginationScheduleEvent> GetScheduleEventsAsync(string scheduleNameOrId, int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Search ScheduleEvents
        /// </summary>
        /// <remarks>
        /// Searches all schedules in the system and returning a number of matches against the given search filter, delimited by the offset and count.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationScheduleEvent)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationScheduleEvent>> GetScheduleEventsWithHttpInfoAsync(string scheduleNameOrId, int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets all Progresses assigned via this schedule
        /// </summary>
        /// <remarks>
        /// Fetches all current assignments to the currently logged-in profile.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationProgress</returns>
        System.Threading.Tasks.Task<PaginationProgress> GetScheduleProgressesAsync(string scheduleNameOrId, int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets all Progresses assigned via this schedule
        /// </summary>
        /// <remarks>
        /// Fetches all current assignments to the currently logged-in profile.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationProgress)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationProgress>> GetScheduleProgressesWithHttpInfoAsync(string scheduleNameOrId, int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Search Schedules
        /// </summary>
        /// <remarks>
        /// Searches all schedules in the system and returning a number of matches against the given search filter, delimited by the offset and count.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationSchedule</returns>
        System.Threading.Tasks.Task<PaginationSchedule> GetSchedulesAsync(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Search Schedules
        /// </summary>
        /// <remarks>
        /// Searches all schedules in the system and returning a number of matches against the given search filter, delimited by the offset and count.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationSchedule)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationSchedule>> GetSchedulesWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Performs the health check.
        /// </summary>
        /// <remarks>
        /// Performs the health check for the server. What this actually does is deployment and implementation specific. However, any successful response code should indicate that the service is capable of servicing requests. Any unsuccessful error codes should indicate that the instance has internal issues and should be taken offline.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of HealthStatus</returns>
        System.Threading.Tasks.Task<HealthStatus> GetServerHealthAsync(System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Performs the health check.
        /// </summary>
        /// <remarks>
        /// Performs the health check for the server. What this actually does is deployment and implementation specific. However, any successful response code should indicate that the service is capable of servicing requests. Any unsuccessful error codes should indicate that the instance has internal issues and should be taken offline.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (HealthStatus)</returns>
        System.Threading.Tasks.Task<ApiResponse<HealthStatus>> GetServerHealthWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Gets the first (primary) inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InventoryItem</returns>
        System.Threading.Tasks.Task<InventoryItem> GetSimpleInventoryItemAsync(string inventoryItemId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Gets the first (primary) inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InventoryItem)</returns>
        System.Threading.Tasks.Task<ApiResponse<InventoryItem>> GetSimpleInventoryItemWithHttpInfoAsync(string inventoryItemId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Search inventory items
        /// </summary>
        /// <remarks>
        /// Searches all inventory items in the system and returns the metadata for all matches against the given search filter.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationInventoryItem</returns>
        System.Threading.Tasks.Task<PaginationInventoryItem> GetSimpleInventoryItemsAsync(int? offset = default(int?), int? count = default(int?), string userId = default(string), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Search inventory items
        /// </summary>
        /// <remarks>
        /// Searches all inventory items in the system and returns the metadata for all matches against the given search filter.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationInventoryItem)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationInventoryItem>> GetSimpleInventoryItemsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), string userId = default(string), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets a specific  Smart Contract
        /// </summary>
        /// <remarks>
        /// Gets a specific  Smart Contract by contractId.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SmartContract</returns>
        System.Threading.Tasks.Task<SmartContract> GetSmartContractAsync(string contractId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets a specific  Smart Contract
        /// </summary>
        /// <remarks>
        /// Gets a specific  Smart Contract by contractId.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SmartContract)</returns>
        System.Threading.Tasks.Task<ApiResponse<SmartContract>> GetSmartContractWithHttpInfoAsync(string contractId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets  contracts.
        /// </summary>
        /// <remarks>
        /// Gets a pagination of  SmartContracts.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="api"> (optional)</param>
        /// <param name="network"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationSmartContract</returns>
        System.Threading.Tasks.Task<PaginationSmartContract> GetSmartContractsAsync(int? offset = default(int?), int? count = default(int?), string api = default(string), List<string> network = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets  contracts.
        /// </summary>
        /// <remarks>
        /// Gets a pagination of  SmartContracts.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="api"> (optional)</param>
        /// <param name="network"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationSmartContract)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationSmartContract>> GetSmartContractsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), string api = default(string), List<string> network = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets a Specific User
        /// </summary>
        /// <remarks>
        /// Gets a specific user by name, email, or unique user ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of User</returns>
        System.Threading.Tasks.Task<User> GetUserAsync(string name, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets a Specific User
        /// </summary>
        /// <remarks>
        /// Gets a specific user by name, email, or unique user ID.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (User)</returns>
        System.Threading.Tasks.Task<ApiResponse<User>> GetUserWithHttpInfoAsync(string name, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Get save data document.
        /// </summary>
        /// <remarks>
        /// Gets a single save data document based on UserID and slot. This is a convenience method whichallows the client to fetch a save data based on slot an user id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="slot"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SaveDataDocument</returns>
        System.Threading.Tasks.Task<SaveDataDocument> GetUserSaveDataDocumentBySlotAsync(string userId, int slot, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Get save data document.
        /// </summary>
        /// <remarks>
        /// Gets a single save data document based on UserID and slot. This is a convenience method whichallows the client to fetch a save data based on slot an user id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="slot"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SaveDataDocument)</returns>
        System.Threading.Tasks.Task<ApiResponse<SaveDataDocument>> GetUserSaveDataDocumentBySlotWithHttpInfoAsync(string userId, int slot, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Search Users
        /// </summary>
        /// <remarks>
        /// Searches all users in the system and returning the metadata for all matches against the given search filter.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationUser</returns>
        System.Threading.Tasks.Task<PaginationUser> GetUsersAsync(int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Search Users
        /// </summary>
        /// <remarks>
        /// Searches all users in the system and returning the metadata for all matches against the given search filter.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationUser)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationUser>> GetUsersWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets a specific  Vault
        /// </summary>
        /// <remarks>
        /// Gets a specific  Vault by Id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Vault</returns>
        System.Threading.Tasks.Task<Vault> GetVaultAsync(string vaultId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets a specific  Vault
        /// </summary>
        /// <remarks>
        /// Gets a specific  Vault by Id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Vault)</returns>
        System.Threading.Tasks.Task<ApiResponse<Vault>> GetVaultWithHttpInfoAsync(string vaultId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets  vaults. Optionally filtered for a specific user
        /// </summary>
        /// <remarks>
        /// Gets a pagination of  Wallets. Optionally a user Id can be specified to filter for a given user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationVault</returns>
        System.Threading.Tasks.Task<PaginationVault> GetVaultsAsync(int? offset = default(int?), int? count = default(int?), string userId = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets  vaults. Optionally filtered for a specific user
        /// </summary>
        /// <remarks>
        /// Gets a pagination of  Wallets. Optionally a user Id can be specified to filter for a given user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationVault)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationVault>> GetVaultsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), string userId = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Show Server Version Information
        /// </summary>
        /// <remarks>
        /// Returns information about the current server version.  This should always return theversion metadata.  This information is only known in packaged releases.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ModelVersion</returns>
        System.Threading.Tasks.Task<ModelVersion> GetVersionAsync(System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Show Server Version Information
        /// </summary>
        /// <remarks>
        /// Returns information about the current server version.  This should always return theversion metadata.  This information is only known in packaged releases.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ModelVersion)</returns>
        System.Threading.Tasks.Task<ApiResponse<ModelVersion>> GetVersionWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets a specific  Wallet
        /// </summary>
        /// <remarks>
        /// Gets a specific  Wallet by Id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="walletId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Wallet</returns>
        System.Threading.Tasks.Task<Wallet> GetWalletAsync(string vaultId, string walletId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets a specific  Wallet
        /// </summary>
        /// <remarks>
        /// Gets a specific  Wallet by Id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="walletId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Wallet)</returns>
        System.Threading.Tasks.Task<ApiResponse<Wallet>> GetWalletWithHttpInfoAsync(string vaultId, string walletId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets a specific  Wallet
        /// </summary>
        /// <remarks>
        /// Gets a specific  Wallet by Id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="walletId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Wallet</returns>
        System.Threading.Tasks.Task<Wallet> GetWallet1Async(string walletId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets a specific  Wallet
        /// </summary>
        /// <remarks>
        /// Gets a specific  Wallet by Id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="walletId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Wallet)</returns>
        System.Threading.Tasks.Task<ApiResponse<Wallet>> GetWallet1WithHttpInfoAsync(string walletId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Gets  wallets. Optionally filtered for a specific user
        /// </summary>
        /// <remarks>
        /// Gets a pagination of  Wallets. Optionally a user Id can be specified to filter for a given user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="api"> (optional)</param>
        /// <param name="network"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationWallet</returns>
        System.Threading.Tasks.Task<PaginationWallet> GetWalletsAsync(string vaultId, int? offset = default(int?), int? count = default(int?), string userId = default(string), string api = default(string), List<string> network = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Gets  wallets. Optionally filtered for a specific user
        /// </summary>
        /// <remarks>
        /// Gets a pagination of  Wallets. Optionally a user Id can be specified to filter for a given user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="api"> (optional)</param>
        /// <param name="network"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationWallet)</returns>
        System.Threading.Tasks.Task<ApiResponse<PaginationWallet>> GetWalletsWithHttpInfoAsync(string vaultId, int? offset = default(int?), int? count = default(int?), string userId = default(string), string api = default(string), List<string> network = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Redeems the RewardIssuance.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rewardIssuanceId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of RewardIssuanceRedemptionResult</returns>
        System.Threading.Tasks.Task<RewardIssuanceRedemptionResult> RedeemRewardIssuanceAsync(string rewardIssuanceId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Redeems the RewardIssuance.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rewardIssuanceId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (RewardIssuanceRedemptionResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<RewardIssuanceRedemptionResult>> RedeemRewardIssuanceWithHttpInfoAsync(string rewardIssuanceId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Redeems the given list of RewardIssuances.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;RewardIssuanceRedemptionResult&gt;</returns>
        System.Threading.Tasks.Task<List<RewardIssuanceRedemptionResult>> RedeemRewardIssuancesAsync(List<string> requestBody = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Redeems the given list of RewardIssuances.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;RewardIssuanceRedemptionResult&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<RewardIssuanceRedemptionResult>>> RedeemRewardIssuancesWithHttpInfoAsync(List<string> requestBody = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Sign Up a User
        /// </summary>
        /// <remarks>
        /// Supplying the user create request object, this will create a new user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userCreateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UserCreateResponse</returns>
        System.Threading.Tasks.Task<UserCreateResponse> SignUpUserAsync(UserCreateRequest userCreateRequest = default(UserCreateRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Sign Up a User
        /// </summary>
        /// <remarks>
        /// Supplying the user create request object, this will create a new user.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userCreateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UserCreateResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<UserCreateResponse>> SignUpUserWithHttpInfoAsync(UserCreateRequest userCreateRequest = default(UserCreateRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates an Application
        /// </summary>
        /// <remarks>
        /// Performs an update to an existing application known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="updateApplicationRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Application</returns>
        System.Threading.Tasks.Task<Application> UpdateApplicationAsync(string nameOrId, UpdateApplicationRequest updateApplicationRequest = default(UpdateApplicationRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates an Application
        /// </summary>
        /// <remarks>
        /// Performs an update to an existing application known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="updateApplicationRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Application)</returns>
        System.Threading.Tasks.Task<ApiResponse<Application>> UpdateApplicationWithHttpInfoAsync(string nameOrId, UpdateApplicationRequest updateApplicationRequest = default(UpdateApplicationRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates an Auth Scheme
        /// </summary>
        /// <remarks>
        /// Updates an Auth Scheme with the specified data in the auth scheme request.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSchemeId"></param>
        /// <param name="updateAuthSchemeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UpdateAuthSchemeResponse</returns>
        System.Threading.Tasks.Task<UpdateAuthSchemeResponse> UpdateAuthSchemeAsync(string authSchemeId, UpdateAuthSchemeRequest updateAuthSchemeRequest = default(UpdateAuthSchemeRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates an Auth Scheme
        /// </summary>
        /// <remarks>
        /// Updates an Auth Scheme with the specified data in the auth scheme request.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSchemeId"></param>
        /// <param name="updateAuthSchemeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UpdateAuthSchemeResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<UpdateAuthSchemeResponse>> UpdateAuthSchemeWithHttpInfoAsync(string authSchemeId, UpdateAuthSchemeRequest updateAuthSchemeRequest = default(UpdateAuthSchemeRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates an Auth Scheme
        /// </summary>
        /// <remarks>
        /// Updates an Auth Scheme with the specified data in the auth scheme request.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2AuthSchemeId"></param>
        /// <param name="createOrUpdateOAuth2AuthSchemeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CreateOrUpdateOAuth2AuthSchemeResponse</returns>
        System.Threading.Tasks.Task<CreateOrUpdateOAuth2AuthSchemeResponse> UpdateAuthScheme1Async(string oAuth2AuthSchemeId, CreateOrUpdateOAuth2AuthSchemeRequest createOrUpdateOAuth2AuthSchemeRequest = default(CreateOrUpdateOAuth2AuthSchemeRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates an Auth Scheme
        /// </summary>
        /// <remarks>
        /// Updates an Auth Scheme with the specified data in the auth scheme request.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2AuthSchemeId"></param>
        /// <param name="createOrUpdateOAuth2AuthSchemeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CreateOrUpdateOAuth2AuthSchemeResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<CreateOrUpdateOAuth2AuthSchemeResponse>> UpdateAuthScheme1WithHttpInfoAsync(string oAuth2AuthSchemeId, CreateOrUpdateOAuth2AuthSchemeRequest createOrUpdateOAuth2AuthSchemeRequest = default(CreateOrUpdateOAuth2AuthSchemeRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates an Auth Scheme
        /// </summary>
        /// <remarks>
        /// Updates an Auth Scheme with the specified data in the auth scheme request.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcAuthSchemeId"></param>
        /// <param name="createOrUpdateOidcAuthSchemeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CreateOrUpdateOidcAuthSchemeResponse</returns>
        System.Threading.Tasks.Task<CreateOrUpdateOidcAuthSchemeResponse> UpdateAuthScheme2Async(string oidcAuthSchemeId, CreateOrUpdateOidcAuthSchemeRequest createOrUpdateOidcAuthSchemeRequest = default(CreateOrUpdateOidcAuthSchemeRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates an Auth Scheme
        /// </summary>
        /// <remarks>
        /// Updates an Auth Scheme with the specified data in the auth scheme request.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcAuthSchemeId"></param>
        /// <param name="createOrUpdateOidcAuthSchemeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CreateOrUpdateOidcAuthSchemeResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<CreateOrUpdateOidcAuthSchemeResponse>> UpdateAuthScheme2WithHttpInfoAsync(string oidcAuthSchemeId, CreateOrUpdateOidcAuthSchemeRequest createOrUpdateOidcAuthSchemeRequest = default(CreateOrUpdateOidcAuthSchemeRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="version"></param>
        /// <param name="updateDeploymentRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Deployment</returns>
        System.Threading.Tasks.Task<Deployment> UpdateDeploymentAsync(string applicationId, string version, UpdateDeploymentRequest updateDeploymentRequest = default(UpdateDeploymentRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="version"></param>
        /// <param name="updateDeploymentRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Deployment)</returns>
        System.Threading.Tasks.Task<ApiResponse<Deployment>> UpdateDeploymentWithHttpInfoAsync(string applicationId, string version, UpdateDeploymentRequest updateDeploymentRequest = default(UpdateDeploymentRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates an inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Updates an inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="distinctInventoryItemId"></param>
        /// <param name="updateDistinctInventoryItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of DistinctInventoryItem</returns>
        System.Threading.Tasks.Task<DistinctInventoryItem> UpdateDistinctInventoryItemAsync(string distinctInventoryItemId, UpdateDistinctInventoryItemRequest updateDistinctInventoryItemRequest = default(UpdateDistinctInventoryItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates an inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Updates an inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="distinctInventoryItemId"></param>
        /// <param name="updateDistinctInventoryItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (DistinctInventoryItem)</returns>
        System.Threading.Tasks.Task<ApiResponse<DistinctInventoryItem>> UpdateDistinctInventoryItemWithHttpInfoAsync(string distinctInventoryItemId, UpdateDistinctInventoryItemRequest updateDistinctInventoryItemRequest = default(UpdateDistinctInventoryItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates a Facebook ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Updates an existing Facebook Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="facebookApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FacebookApplicationConfiguration</returns>
        System.Threading.Tasks.Task<FacebookApplicationConfiguration> UpdateFacebookApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, FacebookApplicationConfiguration facebookApplicationConfiguration = default(FacebookApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates a Facebook ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Updates an existing Facebook Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="facebookApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FacebookApplicationConfiguration)</returns>
        System.Threading.Tasks.Task<ApiResponse<FacebookApplicationConfiguration>> UpdateFacebookApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, FacebookApplicationConfiguration facebookApplicationConfiguration = default(FacebookApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates a Firebase ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Updates an existing Firebase Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="firebaseApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FirebaseApplicationConfiguration</returns>
        System.Threading.Tasks.Task<FirebaseApplicationConfiguration> UpdateFirebaseApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, FirebaseApplicationConfiguration firebaseApplicationConfiguration = default(FirebaseApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates a Firebase ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Updates an existing Firebase Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="firebaseApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FirebaseApplicationConfiguration)</returns>
        System.Threading.Tasks.Task<ApiResponse<FirebaseApplicationConfiguration>> UpdateFirebaseApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, FirebaseApplicationConfiguration firebaseApplicationConfiguration = default(FirebaseApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates a Google Play ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Updates an existing Google Play Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="googlePlayApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GooglePlayApplicationConfiguration</returns>
        System.Threading.Tasks.Task<GooglePlayApplicationConfiguration> UpdateGooglePlayApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, GooglePlayApplicationConfiguration googlePlayApplicationConfiguration = default(GooglePlayApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates a Google Play ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Updates an existing Google Play Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="googlePlayApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GooglePlayApplicationConfiguration)</returns>
        System.Threading.Tasks.Task<ApiResponse<GooglePlayApplicationConfiguration>> UpdateGooglePlayApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, GooglePlayApplicationConfiguration googlePlayApplicationConfiguration = default(GooglePlayApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates a iOS ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Updates an existing iOS Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="iosApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IosApplicationConfiguration</returns>
        System.Threading.Tasks.Task<IosApplicationConfiguration> UpdateIosApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, IosApplicationConfiguration iosApplicationConfiguration = default(IosApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates a iOS ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Updates an existing iOS Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="iosApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IosApplicationConfiguration)</returns>
        System.Threading.Tasks.Task<ApiResponse<IosApplicationConfiguration>> UpdateIosApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, IosApplicationConfiguration iosApplicationConfiguration = default(IosApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates a single Item
        /// </summary>
        /// <remarks>
        /// Supplying an item, this will update the Item identified by the identifier in the path with contents from the passed in request body. 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="identifier"></param>
        /// <param name="updateItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Item</returns>
        System.Threading.Tasks.Task<Item> UpdateItemAsync(string identifier, UpdateItemRequest updateItemRequest = default(UpdateItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates a single Item
        /// </summary>
        /// <remarks>
        /// Supplying an item, this will update the Item identified by the identifier in the path with contents from the passed in request body. 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="identifier"></param>
        /// <param name="updateItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Item)</returns>
        System.Threading.Tasks.Task<ApiResponse<Item>> UpdateItemWithHttpInfoAsync(string identifier, UpdateItemRequest updateItemRequest = default(UpdateItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates a LargeObject
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <param name="updateLargeObjectRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LargeObject</returns>
        System.Threading.Tasks.Task<LargeObject> UpdateLargeObjectAsync(string largeObjectId, UpdateLargeObjectRequest updateLargeObjectRequest = default(UpdateLargeObjectRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates a LargeObject
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <param name="updateLargeObjectRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LargeObject)</returns>
        System.Threading.Tasks.Task<ApiResponse<LargeObject>> UpdateLargeObjectWithHttpInfoAsync(string largeObjectId, UpdateLargeObjectRequest updateLargeObjectRequest = default(UpdateLargeObjectRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates a LargeObject content
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LargeObject</returns>
        System.Threading.Tasks.Task<LargeObject> UpdateLargeObjectContentsAsync(string largeObjectId, Object body = default(Object), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates a LargeObject content
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LargeObject)</returns>
        System.Threading.Tasks.Task<ApiResponse<LargeObject>> UpdateLargeObjectContentsWithHttpInfoAsync(string largeObjectId, Object body = default(Object), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates an Leaderboard
        /// </summary>
        /// <remarks>
        /// Performs an update to an existing leaderboard known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="leaderboard"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Leaderboard</returns>
        System.Threading.Tasks.Task<Leaderboard> UpdateLeaderboardAsync(string nameOrId, Leaderboard leaderboard = default(Leaderboard), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates an Leaderboard
        /// </summary>
        /// <remarks>
        /// Performs an update to an existing leaderboard known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="leaderboard"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Leaderboard)</returns>
        System.Threading.Tasks.Task<ApiResponse<Leaderboard>> UpdateLeaderboardWithHttpInfoAsync(string nameOrId, Leaderboard leaderboard = default(Leaderboard), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates a iOS ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Updates an existing iOS Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="matchmakingApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MatchmakingApplicationConfiguration</returns>
        System.Threading.Tasks.Task<MatchmakingApplicationConfiguration> UpdateMatchmakingApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, MatchmakingApplicationConfiguration matchmakingApplicationConfiguration = default(MatchmakingApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates a iOS ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Updates an existing iOS Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="matchmakingApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MatchmakingApplicationConfiguration)</returns>
        System.Threading.Tasks.Task<ApiResponse<MatchmakingApplicationConfiguration>> UpdateMatchmakingApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, MatchmakingApplicationConfiguration matchmakingApplicationConfiguration = default(MatchmakingApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates a specific Metadata object
        /// </summary>
        /// <remarks>
        /// Updates a specific metadata object by name or id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="updateMetadataRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Metadata</returns>
        System.Threading.Tasks.Task<Metadata> UpdateMetadataAsync(string id, UpdateMetadataRequest updateMetadataRequest = default(UpdateMetadataRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates a specific Metadata object
        /// </summary>
        /// <remarks>
        /// Updates a specific metadata object by name or id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="updateMetadataRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Metadata)</returns>
        System.Threading.Tasks.Task<ApiResponse<Metadata>> UpdateMetadataWithHttpInfoAsync(string id, UpdateMetadataRequest updateMetadataRequest = default(UpdateMetadataRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates a Metadata Spec
        /// </summary>
        /// <remarks>
        /// Updates a MetadataSpec with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecId"></param>
        /// <param name="updateMetadataSpecRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MetadataSpec</returns>
        System.Threading.Tasks.Task<MetadataSpec> UpdateMetadataSpecAsync(string metadataSpecId, UpdateMetadataSpecRequest updateMetadataSpecRequest = default(UpdateMetadataSpecRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates a Metadata Spec
        /// </summary>
        /// <remarks>
        /// Updates a MetadataSpec with the specified id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecId"></param>
        /// <param name="updateMetadataSpecRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MetadataSpec)</returns>
        System.Threading.Tasks.Task<ApiResponse<MetadataSpec>> UpdateMetadataSpecWithHttpInfoAsync(string metadataSpecId, UpdateMetadataSpecRequest updateMetadataSpecRequest = default(UpdateMetadataSpecRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates an entire single Mission
        /// </summary>
        /// <remarks>
        /// Supplying a mission, this will update the Mission identified by the name or ID in the path with contents from the passed in request body. 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="missionNameOrId"></param>
        /// <param name="mission"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Mission</returns>
        System.Threading.Tasks.Task<Mission> UpdateMissionAsync(string missionNameOrId, Mission mission = default(Mission), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates an entire single Mission
        /// </summary>
        /// <remarks>
        /// Supplying a mission, this will update the Mission identified by the name or ID in the path with contents from the passed in request body. 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="missionNameOrId"></param>
        /// <param name="mission"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Mission)</returns>
        System.Threading.Tasks.Task<ApiResponse<Mission>> UpdateMissionWithHttpInfoAsync(string missionNameOrId, Mission mission = default(Mission), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates a PSN ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Updates an existing PSN Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="pSNApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PSNApplicationConfiguration</returns>
        System.Threading.Tasks.Task<PSNApplicationConfiguration> UpdatePSNApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, PSNApplicationConfiguration pSNApplicationConfiguration = default(PSNApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates a PSN ApplicationConfiguration
        /// </summary>
        /// <remarks>
        /// Updates an existing PSN Application profile if it is known to the server.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="pSNApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PSNApplicationConfiguration)</returns>
        System.Threading.Tasks.Task<ApiResponse<PSNApplicationConfiguration>> UpdatePSNApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, PSNApplicationConfiguration pSNApplicationConfiguration = default(PSNApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates the ProductBundle
        /// </summary>
        /// <remarks>
        /// Updates the ProductBundle for the given ApplicationConfiguration
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="productBundle"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApplicationConfiguration</returns>
        System.Threading.Tasks.Task<ApplicationConfiguration> UpdateProductBundleForApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, List<ProductBundle> productBundle = default(List<ProductBundle>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates the ProductBundle
        /// </summary>
        /// <remarks>
        /// Updates the ProductBundle for the given ApplicationConfiguration
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="productBundle"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ApplicationConfiguration)</returns>
        System.Threading.Tasks.Task<ApiResponse<ApplicationConfiguration>> UpdateProductBundleForApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, List<ProductBundle> productBundle = default(List<ProductBundle>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates the ProductBundle
        /// </summary>
        /// <remarks>
        /// Updates the ProductBundle for the given ApplicationConfiguration
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="productBundle"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApplicationConfiguration</returns>
        System.Threading.Tasks.Task<ApplicationConfiguration> UpdateProductBundleForApplicationConfiguration1Async(string applicationNameOrId, string applicationConfigurationNameOrId, List<ProductBundle> productBundle = default(List<ProductBundle>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates the ProductBundle
        /// </summary>
        /// <remarks>
        /// Updates the ProductBundle for the given ApplicationConfiguration
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="productBundle"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ApplicationConfiguration)</returns>
        System.Threading.Tasks.Task<ApiResponse<ApplicationConfiguration>> UpdateProductBundleForApplicationConfiguration1WithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, List<ProductBundle> productBundle = default(List<ProductBundle>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates a Profile
        /// </summary>
        /// <remarks>
        /// Supplying an update request will attempt to update the profile.  The call will return the profile as it was written to the database.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="updateProfileRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Profile</returns>
        System.Threading.Tasks.Task<Profile> UpdateProfileAsync(string profileId, UpdateProfileRequest updateProfileRequest = default(UpdateProfileRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates a Profile
        /// </summary>
        /// <remarks>
        /// Supplying an update request will attempt to update the profile.  The call will return the profile as it was written to the database.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="updateProfileRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Profile)</returns>
        System.Threading.Tasks.Task<ApiResponse<Profile>> UpdateProfileWithHttpInfoAsync(string profileId, UpdateProfileRequest updateProfileRequest = default(UpdateProfileRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates a Profile image object
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="updateProfileImageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Profile</returns>
        System.Threading.Tasks.Task<Profile> UpdateProfileImageAsync(string profileId, UpdateProfileImageRequest updateProfileImageRequest = default(UpdateProfileImageRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates a Profile image object
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="updateProfileImageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Profile)</returns>
        System.Threading.Tasks.Task<ApiResponse<Profile>> UpdateProfileImageWithHttpInfoAsync(string profileId, UpdateProfileImageRequest updateProfileImageRequest = default(UpdateProfileImageRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates a single Progress
        /// </summary>
        /// <remarks>
        /// Supplying a progress, this will update the Progress identified by the ID in the path with contents from the passed in request body. 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progressId"></param>
        /// <param name="progress"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Progress</returns>
        System.Threading.Tasks.Task<Progress> UpdateProgressAsync(string progressId, Progress progress = default(Progress), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates a single Progress
        /// </summary>
        /// <remarks>
        /// Supplying a progress, this will update the Progress identified by the ID in the path with contents from the passed in request body. 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progressId"></param>
        /// <param name="progress"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Progress)</returns>
        System.Threading.Tasks.Task<ApiResponse<Progress>> UpdateProgressWithHttpInfoAsync(string progressId, Progress progress = default(Progress), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Update an FCM Registration Token
        /// </summary>
        /// <remarks>
        /// Supplying FCM registration token, this will update the token string with the supplied values.  Clients may update the same registration with a different token issued with Firebase if they wish to simply retain the association with the 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fcmRegistrationId"></param>
        /// <param name="fCMRegistration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FCMRegistration</returns>
        System.Threading.Tasks.Task<FCMRegistration> UpdateRegistrationAsync(string fcmRegistrationId, FCMRegistration fCMRegistration = default(FCMRegistration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Update an FCM Registration Token
        /// </summary>
        /// <remarks>
        /// Supplying FCM registration token, this will update the token string with the supplied values.  Clients may update the same registration with a different token issued with Firebase if they wish to simply retain the association with the 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fcmRegistrationId"></param>
        /// <param name="fCMRegistration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FCMRegistration)</returns>
        System.Threading.Tasks.Task<ApiResponse<FCMRegistration>> UpdateRegistrationWithHttpInfoAsync(string fcmRegistrationId, FCMRegistration fCMRegistration = default(FCMRegistration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Creates a save data document.
        /// </summary>
        /// <remarks>
        /// Gets a single save data document.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="saveDataDocumentId"></param>
        /// <param name="updateSaveDataDocumentRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SaveDataDocument</returns>
        System.Threading.Tasks.Task<SaveDataDocument> UpdateSaveDocumentAsync(string saveDataDocumentId, UpdateSaveDataDocumentRequest updateSaveDataDocumentRequest = default(UpdateSaveDataDocumentRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Creates a save data document.
        /// </summary>
        /// <remarks>
        /// Gets a single save data document.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="saveDataDocumentId"></param>
        /// <param name="updateSaveDataDocumentRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SaveDataDocument)</returns>
        System.Threading.Tasks.Task<ApiResponse<SaveDataDocument>> UpdateSaveDocumentWithHttpInfoAsync(string saveDataDocumentId, UpdateSaveDataDocumentRequest updateSaveDataDocumentRequest = default(UpdateSaveDataDocumentRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates an entire single Schedule
        /// </summary>
        /// <remarks>
        /// Supplying a schedule, this will update the Schedule identified by the name or ID in the path with contents from the passed in request body. 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="updateScheduleRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Schedule</returns>
        System.Threading.Tasks.Task<Schedule> UpdateScheduleAsync(string scheduleNameOrId, UpdateScheduleRequest updateScheduleRequest = default(UpdateScheduleRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates an entire single Schedule
        /// </summary>
        /// <remarks>
        /// Supplying a schedule, this will update the Schedule identified by the name or ID in the path with contents from the passed in request body. 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="updateScheduleRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Schedule)</returns>
        System.Threading.Tasks.Task<ApiResponse<Schedule>> UpdateScheduleWithHttpInfoAsync(string scheduleNameOrId, UpdateScheduleRequest updateScheduleRequest = default(UpdateScheduleRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates an entire single ScheduleEvent
        /// </summary>
        /// <remarks>
        /// Supplying a schedule, this will update the ScheduleEvent identified by the name or ID in the path with contents from the passed in request body. 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="scheduleEventId"></param>
        /// <param name="updateScheduleEventRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ScheduleEvent</returns>
        System.Threading.Tasks.Task<ScheduleEvent> UpdateScheduleEventAsync(string scheduleNameOrId, string scheduleEventId, UpdateScheduleEventRequest updateScheduleEventRequest = default(UpdateScheduleEventRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates an entire single ScheduleEvent
        /// </summary>
        /// <remarks>
        /// Supplying a schedule, this will update the ScheduleEvent identified by the name or ID in the path with contents from the passed in request body. 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="scheduleEventId"></param>
        /// <param name="updateScheduleEventRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ScheduleEvent)</returns>
        System.Threading.Tasks.Task<ApiResponse<ScheduleEvent>> UpdateScheduleEventWithHttpInfoAsync(string scheduleNameOrId, string scheduleEventId, UpdateScheduleEventRequest updateScheduleEventRequest = default(UpdateScheduleEventRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates an inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Updates an inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="updateInventoryItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InventoryItem</returns>
        System.Threading.Tasks.Task<InventoryItem> UpdateSimpleInventoryItemAsync(string inventoryItemId, UpdateInventoryItemRequest updateInventoryItemRequest = default(UpdateInventoryItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates an inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Updates an inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="updateInventoryItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InventoryItem)</returns>
        System.Threading.Tasks.Task<ApiResponse<InventoryItem>> UpdateSimpleInventoryItemWithHttpInfoAsync(string inventoryItemId, UpdateInventoryItemRequest updateInventoryItemRequest = default(UpdateInventoryItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates an inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Updates an inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="updateInventoryItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InventoryItem</returns>
        System.Threading.Tasks.Task<InventoryItem> UpdateSimpleInventoryItem1Async(string inventoryItemId, UpdateInventoryItemRequest updateInventoryItemRequest = default(UpdateInventoryItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates an inventory item for the specified item
        /// </summary>
        /// <remarks>
        /// Updates an inventory item for the specified item
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="updateInventoryItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InventoryItem)</returns>
        System.Threading.Tasks.Task<ApiResponse<InventoryItem>> UpdateSimpleInventoryItem1WithHttpInfoAsync(string inventoryItemId, UpdateInventoryItemRequest updateInventoryItemRequest = default(UpdateInventoryItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Patches a  Smart Contract
        /// </summary>
        /// <remarks>
        /// Patches a  Smart Contract entry, associated with the specified deployed script hash.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractId"></param>
        /// <param name="updateSmartContractRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SmartContract</returns>
        System.Threading.Tasks.Task<SmartContract> UpdateSmartContractAsync(string contractId, UpdateSmartContractRequest updateSmartContractRequest = default(UpdateSmartContractRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Patches a  Smart Contract
        /// </summary>
        /// <remarks>
        /// Patches a  Smart Contract entry, associated with the specified deployed script hash.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractId"></param>
        /// <param name="updateSmartContractRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SmartContract)</returns>
        System.Threading.Tasks.Task<ApiResponse<SmartContract>> UpdateSmartContractWithHttpInfoAsync(string contractId, UpdateSmartContractRequest updateSmartContractRequest = default(UpdateSmartContractRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates a User
        /// </summary>
        /// <remarks>
        /// Supplying the user object, this will update the user with the new information supplied in the body of the request.  Optionally, the user&#39;s password may be provided in the User object.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="userUpdateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of User</returns>
        System.Threading.Tasks.Task<User> UpdateUserAsync(string userId, UserUpdateRequest userUpdateRequest = default(UserUpdateRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates a User
        /// </summary>
        /// <remarks>
        /// Supplying the user object, this will update the user with the new information supplied in the body of the request.  Optionally, the user&#39;s password may be provided in the User object.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="userUpdateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (User)</returns>
        System.Threading.Tasks.Task<ApiResponse<User>> UpdateUserWithHttpInfoAsync(string userId, UserUpdateRequest userUpdateRequest = default(UserUpdateRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates a User&#39;s Password
        /// </summary>
        /// <remarks>
        /// Supplying the UserUpdatePasswordRequest, this will attempt to update the user&#39;s password only if they supply the correct existing password.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="userUpdatePasswordRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SessionCreation</returns>
        System.Threading.Tasks.Task<SessionCreation> UpdateUserPasswordAsync(string userId, UserUpdatePasswordRequest userUpdatePasswordRequest = default(UserUpdatePasswordRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates a User&#39;s Password
        /// </summary>
        /// <remarks>
        /// Supplying the UserUpdatePasswordRequest, this will attempt to update the user&#39;s password only if they supply the correct existing password.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="userUpdatePasswordRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SessionCreation)</returns>
        System.Threading.Tasks.Task<ApiResponse<SessionCreation>> UpdateUserPasswordWithHttpInfoAsync(string userId, UserUpdatePasswordRequest userUpdatePasswordRequest = default(UserUpdatePasswordRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates a  Vault
        /// </summary>
        /// <remarks>
        /// Updates a  Vault with the specified name or id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="updateVaultRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Vault</returns>
        System.Threading.Tasks.Task<Vault> UpdateVaultAsync(string vaultId, UpdateVaultRequest updateVaultRequest = default(UpdateVaultRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates a  Vault
        /// </summary>
        /// <remarks>
        /// Updates a  Vault with the specified name or id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="updateVaultRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Vault)</returns>
        System.Threading.Tasks.Task<ApiResponse<Vault>> UpdateVaultWithHttpInfoAsync(string vaultId, UpdateVaultRequest updateVaultRequest = default(UpdateVaultRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Updates a  Wallet
        /// </summary>
        /// <remarks>
        /// Updates a  Wallet with the specified name or id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="walletId"></param>
        /// <param name="updateWalletRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Wallet</returns>
        System.Threading.Tasks.Task<Wallet> UpdateWalletAsync(string vaultId, string walletId, UpdateWalletRequest updateWalletRequest = default(UpdateWalletRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Updates a  Wallet
        /// </summary>
        /// <remarks>
        /// Updates a  Wallet with the specified name or id.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="walletId"></param>
        /// <param name="updateWalletRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Wallet)</returns>
        System.Threading.Tasks.Task<ApiResponse<Wallet>> UpdateWalletWithHttpInfoAsync(string vaultId, string walletId, UpdateWalletRequest updateWalletRequest = default(UpdateWalletRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Upload Apple IAP Receipt. Returns a list of RewardIssuances, which may contain already-redeemed issuances.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAppleIapReceipt"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;RewardIssuance&gt;</returns>
        System.Threading.Tasks.Task<List<RewardIssuance>> UploadAppleIapReceiptAsync(CreateAppleIapReceipt createAppleIapReceipt = default(CreateAppleIapReceipt), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Upload Apple IAP Receipt. Returns a list of RewardIssuances, which may contain already-redeemed issuances.
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAppleIapReceipt"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;RewardIssuance&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<RewardIssuance>>> UploadAppleIapReceiptWithHttpInfoAsync(CreateAppleIapReceipt createAppleIapReceipt = default(CreateAppleIapReceipt), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Upload Google Play IAP Receipt data (package name, product id and Google Play-issued purchase token). Returns a list of RewardIssuances, some or all of which may be already redeemed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createGooglePlayIapReceipt"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;RewardIssuance&gt;</returns>
        System.Threading.Tasks.Task<List<RewardIssuance>> UploadGooglePlayIapPurchaseAsync(CreateGooglePlayIapReceipt createGooglePlayIapReceipt = default(CreateGooglePlayIapReceipt), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Upload Google Play IAP Receipt data (package name, product id and Google Play-issued purchase token). Returns a list of RewardIssuances, some or all of which may be already redeemed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createGooglePlayIapReceipt"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;RewardIssuance&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<RewardIssuance>>> UploadGooglePlayIapPurchaseWithHttpInfoAsync(CreateGooglePlayIapReceipt createGooglePlayIapReceipt = default(CreateGooglePlayIapReceipt), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IDefaultApi : IDefaultApiSync, IDefaultApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class DefaultApi : IDisposable, IDefaultApi
    {
        private Elements.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultApi"/> class.
        /// **IMPORTANT** This will also create an instance of HttpClient, which is less than ideal.
        /// It's better to reuse the <see href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#issues-with-the-original-httpclient-class-available-in-net">HttpClient and HttpClientHandler</see>.
        /// </summary>
        /// <returns></returns>
        public DefaultApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultApi"/> class.
        /// **IMPORTANT** This will also create an instance of HttpClient, which is less than ideal.
        /// It's better to reuse the <see href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#issues-with-the-original-httpclient-class-available-in-net">HttpClient and HttpClientHandler</see>.
        /// </summary>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <exception cref="ArgumentException"></exception>
        /// <returns></returns>
        public DefaultApi(string basePath)
        {
            this.Configuration = Elements.Client.Configuration.MergeConfigurations(
                Elements.Client.GlobalConfiguration.Instance,
                new Elements.Client.Configuration { BasePath = basePath }
            );
            this.ApiClient = new Elements.Client.ApiClient(this.Configuration.BasePath);
            this.Client =  this.ApiClient;
            this.AsynchronousClient = this.ApiClient;
            this.ExceptionFactory = Elements.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultApi"/> class using Configuration object.
        /// **IMPORTANT** This will also create an instance of HttpClient, which is less than ideal.
        /// It's better to reuse the <see href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#issues-with-the-original-httpclient-class-available-in-net">HttpClient and HttpClientHandler</see>.
        /// </summary>
        /// <param name="configuration">An instance of Configuration.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        public DefaultApi(Elements.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = Elements.Client.Configuration.MergeConfigurations(
                Elements.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.ApiClient = new Elements.Client.ApiClient(this.Configuration.BasePath);
            this.Client = this.ApiClient;
            this.AsynchronousClient = this.ApiClient;
            ExceptionFactory = Elements.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public DefaultApi(Elements.Client.ISynchronousClient client, Elements.Client.IAsynchronousClient asyncClient, Elements.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Elements.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Disposes resources if they were created by us
        /// </summary>
        public void Dispose()
        {
            this.ApiClient?.Dispose();
        }

        /// <summary>
        /// Holds the ApiClient if created
        /// </summary>
        public Elements.Client.ApiClient ApiClient { get; set; } = null;

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Elements.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Elements.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Elements.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Elements.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Adjust the quantity of the inventory item for the specified item. Adjust the quantity of the first (primary) inventory item for the specified item.  This implicitly will create the InventoryItem if it does not exist.  The inventory item value
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="advancedInventoryItemQuantityAdjustment"> (optional)</param>
        /// <returns>InventoryItem</returns>
        public InventoryItem AdjustAdvancedInventoryItemQuantity(string inventoryItemId, AdvancedInventoryItemQuantityAdjustment advancedInventoryItemQuantityAdjustment = default(AdvancedInventoryItemQuantityAdjustment))
        {
            Elements.Client.ApiResponse<InventoryItem> localVarResponse = AdjustAdvancedInventoryItemQuantityWithHttpInfo(inventoryItemId, advancedInventoryItemQuantityAdjustment);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Adjust the quantity of the inventory item for the specified item. Adjust the quantity of the first (primary) inventory item for the specified item.  This implicitly will create the InventoryItem if it does not exist.  The inventory item value
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="advancedInventoryItemQuantityAdjustment"> (optional)</param>
        /// <returns>ApiResponse of InventoryItem</returns>
        public Elements.Client.ApiResponse<InventoryItem> AdjustAdvancedInventoryItemQuantityWithHttpInfo(string inventoryItemId, AdvancedInventoryItemQuantityAdjustment advancedInventoryItemQuantityAdjustment = default(AdvancedInventoryItemQuantityAdjustment))
        {
            // verify the required parameter 'inventoryItemId' is set
            if (inventoryItemId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'inventoryItemId' when calling DefaultApi->AdjustAdvancedInventoryItemQuantity");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("inventoryItemId", Elements.Client.ClientUtils.ParameterToString(inventoryItemId)); // path parameter
            localVarRequestOptions.Data = advancedInventoryItemQuantityAdjustment;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Patch<InventoryItem>("/inventory/advanced/{inventoryItemId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AdjustAdvancedInventoryItemQuantity", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Adjust the quantity of the inventory item for the specified item. Adjust the quantity of the first (primary) inventory item for the specified item.  This implicitly will create the InventoryItem if it does not exist.  The inventory item value
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="advancedInventoryItemQuantityAdjustment"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InventoryItem</returns>
        public async System.Threading.Tasks.Task<InventoryItem> AdjustAdvancedInventoryItemQuantityAsync(string inventoryItemId, AdvancedInventoryItemQuantityAdjustment advancedInventoryItemQuantityAdjustment = default(AdvancedInventoryItemQuantityAdjustment), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = AdjustAdvancedInventoryItemQuantityWithHttpInfoAsync(inventoryItemId, advancedInventoryItemQuantityAdjustment, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<InventoryItem> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<InventoryItem> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Adjust the quantity of the inventory item for the specified item. Adjust the quantity of the first (primary) inventory item for the specified item.  This implicitly will create the InventoryItem if it does not exist.  The inventory item value
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="advancedInventoryItemQuantityAdjustment"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InventoryItem)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<InventoryItem>> AdjustAdvancedInventoryItemQuantityWithHttpInfoAsync(string inventoryItemId, AdvancedInventoryItemQuantityAdjustment advancedInventoryItemQuantityAdjustment = default(AdvancedInventoryItemQuantityAdjustment), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'inventoryItemId' is set
            if (inventoryItemId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'inventoryItemId' when calling DefaultApi->AdjustAdvancedInventoryItemQuantity");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("inventoryItemId", Elements.Client.ClientUtils.ParameterToString(inventoryItemId)); // path parameter
            localVarRequestOptions.Data = advancedInventoryItemQuantityAdjustment;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PatchAsync<InventoryItem>("/inventory/advanced/{inventoryItemId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AdjustAdvancedInventoryItemQuantity", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Adjust the quantity of the inventory item for the specified item. Adjust the quantity of the first (primary) inventory item for the specified item.  This implicitly will create the InventoryItem if it does not exist.  The inventory item value
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="simpleInventoryItemQuantityAdjustment"> (optional)</param>
        /// <returns>InventoryItem</returns>
        public InventoryItem AdjustSimpleInventoryItemQuantity(string inventoryItemId, SimpleInventoryItemQuantityAdjustment simpleInventoryItemQuantityAdjustment = default(SimpleInventoryItemQuantityAdjustment))
        {
            Elements.Client.ApiResponse<InventoryItem> localVarResponse = AdjustSimpleInventoryItemQuantityWithHttpInfo(inventoryItemId, simpleInventoryItemQuantityAdjustment);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Adjust the quantity of the inventory item for the specified item. Adjust the quantity of the first (primary) inventory item for the specified item.  This implicitly will create the InventoryItem if it does not exist.  The inventory item value
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="simpleInventoryItemQuantityAdjustment"> (optional)</param>
        /// <returns>ApiResponse of InventoryItem</returns>
        public Elements.Client.ApiResponse<InventoryItem> AdjustSimpleInventoryItemQuantityWithHttpInfo(string inventoryItemId, SimpleInventoryItemQuantityAdjustment simpleInventoryItemQuantityAdjustment = default(SimpleInventoryItemQuantityAdjustment))
        {
            // verify the required parameter 'inventoryItemId' is set
            if (inventoryItemId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'inventoryItemId' when calling DefaultApi->AdjustSimpleInventoryItemQuantity");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("inventoryItemId", Elements.Client.ClientUtils.ParameterToString(inventoryItemId)); // path parameter
            localVarRequestOptions.Data = simpleInventoryItemQuantityAdjustment;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Patch<InventoryItem>("/inventory/simple/{inventoryItemId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AdjustSimpleInventoryItemQuantity", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Adjust the quantity of the inventory item for the specified item. Adjust the quantity of the first (primary) inventory item for the specified item.  This implicitly will create the InventoryItem if it does not exist.  The inventory item value
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="simpleInventoryItemQuantityAdjustment"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InventoryItem</returns>
        public async System.Threading.Tasks.Task<InventoryItem> AdjustSimpleInventoryItemQuantityAsync(string inventoryItemId, SimpleInventoryItemQuantityAdjustment simpleInventoryItemQuantityAdjustment = default(SimpleInventoryItemQuantityAdjustment), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = AdjustSimpleInventoryItemQuantityWithHttpInfoAsync(inventoryItemId, simpleInventoryItemQuantityAdjustment, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<InventoryItem> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<InventoryItem> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Adjust the quantity of the inventory item for the specified item. Adjust the quantity of the first (primary) inventory item for the specified item.  This implicitly will create the InventoryItem if it does not exist.  The inventory item value
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="simpleInventoryItemQuantityAdjustment"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InventoryItem)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<InventoryItem>> AdjustSimpleInventoryItemQuantityWithHttpInfoAsync(string inventoryItemId, SimpleInventoryItemQuantityAdjustment simpleInventoryItemQuantityAdjustment = default(SimpleInventoryItemQuantityAdjustment), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'inventoryItemId' is set
            if (inventoryItemId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'inventoryItemId' when calling DefaultApi->AdjustSimpleInventoryItemQuantity");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("inventoryItemId", Elements.Client.ClientUtils.ParameterToString(inventoryItemId)); // path parameter
            localVarRequestOptions.Data = simpleInventoryItemQuantityAdjustment;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PatchAsync<InventoryItem>("/inventory/simple/{inventoryItemId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AdjustSimpleInventoryItemQuantity", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Destroys the Session 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionSecret"></param>
        /// <returns></returns>
        public void BlacklistSession(string sessionSecret)
        {
            BlacklistSessionWithHttpInfo(sessionSecret);
        }

        /// <summary>
        /// Destroys the Session 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionSecret"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> BlacklistSessionWithHttpInfo(string sessionSecret)
        {
            // verify the required parameter 'sessionSecret' is set
            if (sessionSecret == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'sessionSecret' when calling DefaultApi->BlacklistSession");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*",
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("sessionSecret", Elements.Client.ClientUtils.ParameterToString(sessionSecret)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/session/{sessionSecret}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("BlacklistSession", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Destroys the Session 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionSecret"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task BlacklistSessionAsync(string sessionSecret, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = BlacklistSessionWithHttpInfoAsync(sessionSecret, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Destroys the Session 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionSecret"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> BlacklistSessionWithHttpInfoAsync(string sessionSecret, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'sessionSecret' is set
            if (sessionSecret == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'sessionSecret' when calling DefaultApi->BlacklistSession");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*",
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("sessionSecret", Elements.Client.ClientUtils.ParameterToString(sessionSecret)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/session/{sessionSecret}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("BlacklistSession", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Builds all indexes. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="buildIndexRequest"> (optional)</param>
        /// <returns></returns>
        public void BuildIndexes(BuildIndexRequest buildIndexRequest = default(BuildIndexRequest))
        {
            BuildIndexesWithHttpInfo(buildIndexRequest);
        }

        /// <summary>
        /// Builds all indexes. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="buildIndexRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> BuildIndexesWithHttpInfo(BuildIndexRequest buildIndexRequest = default(BuildIndexRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = buildIndexRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/index/build", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("BuildIndexes", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Builds all indexes. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="buildIndexRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task BuildIndexesAsync(BuildIndexRequest buildIndexRequest = default(BuildIndexRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = BuildIndexesWithHttpInfoAsync(buildIndexRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Builds all indexes. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="buildIndexRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> BuildIndexesWithHttpInfoAsync(BuildIndexRequest buildIndexRequest = default(BuildIndexRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = buildIndexRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<Object>("/index/build", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("BuildIndexes", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create an inventory item for the specified item Create an inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAdvancedInventoryItemRequest"> (optional)</param>
        /// <returns>InventoryItem</returns>
        public InventoryItem CreateAdvancedInventoryItem(CreateAdvancedInventoryItemRequest createAdvancedInventoryItemRequest = default(CreateAdvancedInventoryItemRequest))
        {
            Elements.Client.ApiResponse<InventoryItem> localVarResponse = CreateAdvancedInventoryItemWithHttpInfo(createAdvancedInventoryItemRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create an inventory item for the specified item Create an inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAdvancedInventoryItemRequest"> (optional)</param>
        /// <returns>ApiResponse of InventoryItem</returns>
        public Elements.Client.ApiResponse<InventoryItem> CreateAdvancedInventoryItemWithHttpInfo(CreateAdvancedInventoryItemRequest createAdvancedInventoryItemRequest = default(CreateAdvancedInventoryItemRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createAdvancedInventoryItemRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<InventoryItem>("/inventory/advanced", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateAdvancedInventoryItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create an inventory item for the specified item Create an inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAdvancedInventoryItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InventoryItem</returns>
        public async System.Threading.Tasks.Task<InventoryItem> CreateAdvancedInventoryItemAsync(CreateAdvancedInventoryItemRequest createAdvancedInventoryItemRequest = default(CreateAdvancedInventoryItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateAdvancedInventoryItemWithHttpInfoAsync(createAdvancedInventoryItemRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<InventoryItem> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<InventoryItem> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create an inventory item for the specified item Create an inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAdvancedInventoryItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InventoryItem)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<InventoryItem>> CreateAdvancedInventoryItemWithHttpInfoAsync(CreateAdvancedInventoryItemRequest createAdvancedInventoryItemRequest = default(CreateAdvancedInventoryItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createAdvancedInventoryItemRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<InventoryItem>("/inventory/advanced", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateAdvancedInventoryItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a New Application Gets the metadata for a single application.  This may include more specific details not available in the bulk-get or fetch operation.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createApplicationRequest"> (optional)</param>
        /// <returns>Application</returns>
        public Application CreateApplication(CreateApplicationRequest createApplicationRequest = default(CreateApplicationRequest))
        {
            Elements.Client.ApiResponse<Application> localVarResponse = CreateApplicationWithHttpInfo(createApplicationRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a New Application Gets the metadata for a single application.  This may include more specific details not available in the bulk-get or fetch operation.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createApplicationRequest"> (optional)</param>
        /// <returns>ApiResponse of Application</returns>
        public Elements.Client.ApiResponse<Application> CreateApplicationWithHttpInfo(CreateApplicationRequest createApplicationRequest = default(CreateApplicationRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createApplicationRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Application>("/application", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateApplication", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a New Application Gets the metadata for a single application.  This may include more specific details not available in the bulk-get or fetch operation.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createApplicationRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Application</returns>
        public async System.Threading.Tasks.Task<Application> CreateApplicationAsync(CreateApplicationRequest createApplicationRequest = default(CreateApplicationRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateApplicationWithHttpInfoAsync(createApplicationRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Application> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Application> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a New Application Gets the metadata for a single application.  This may include more specific details not available in the bulk-get or fetch operation.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createApplicationRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Application)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Application>> CreateApplicationWithHttpInfoAsync(CreateApplicationRequest createApplicationRequest = default(CreateApplicationRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createApplicationRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<Application>("/application", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateApplication", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new Auth Scheme Creates a new Auth Scheme, from the data in the given auth scheme request
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAuthSchemeRequest"> (optional)</param>
        /// <returns>CreateAuthSchemeResponse</returns>
        public CreateAuthSchemeResponse CreateAuthScheme(CreateAuthSchemeRequest createAuthSchemeRequest = default(CreateAuthSchemeRequest))
        {
            Elements.Client.ApiResponse<CreateAuthSchemeResponse> localVarResponse = CreateAuthSchemeWithHttpInfo(createAuthSchemeRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new Auth Scheme Creates a new Auth Scheme, from the data in the given auth scheme request
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAuthSchemeRequest"> (optional)</param>
        /// <returns>ApiResponse of CreateAuthSchemeResponse</returns>
        public Elements.Client.ApiResponse<CreateAuthSchemeResponse> CreateAuthSchemeWithHttpInfo(CreateAuthSchemeRequest createAuthSchemeRequest = default(CreateAuthSchemeRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createAuthSchemeRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<CreateAuthSchemeResponse>("/auth_scheme/custom", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateAuthScheme", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new Auth Scheme Creates a new Auth Scheme, from the data in the given auth scheme request
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAuthSchemeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CreateAuthSchemeResponse</returns>
        public async System.Threading.Tasks.Task<CreateAuthSchemeResponse> CreateAuthSchemeAsync(CreateAuthSchemeRequest createAuthSchemeRequest = default(CreateAuthSchemeRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateAuthSchemeWithHttpInfoAsync(createAuthSchemeRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<CreateAuthSchemeResponse> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<CreateAuthSchemeResponse> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new Auth Scheme Creates a new Auth Scheme, from the data in the given auth scheme request
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAuthSchemeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CreateAuthSchemeResponse)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<CreateAuthSchemeResponse>> CreateAuthSchemeWithHttpInfoAsync(CreateAuthSchemeRequest createAuthSchemeRequest = default(CreateAuthSchemeRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createAuthSchemeRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<CreateAuthSchemeResponse>("/auth_scheme/custom", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateAuthScheme", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new Auth Scheme Creates a new Auth Scheme, from the data in the given auth scheme request
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createOrUpdateOAuth2AuthSchemeRequest"> (optional)</param>
        /// <returns>CreateOrUpdateOAuth2AuthSchemeResponse</returns>
        public CreateOrUpdateOAuth2AuthSchemeResponse CreateAuthScheme1(CreateOrUpdateOAuth2AuthSchemeRequest createOrUpdateOAuth2AuthSchemeRequest = default(CreateOrUpdateOAuth2AuthSchemeRequest))
        {
            Elements.Client.ApiResponse<CreateOrUpdateOAuth2AuthSchemeResponse> localVarResponse = CreateAuthScheme1WithHttpInfo(createOrUpdateOAuth2AuthSchemeRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new Auth Scheme Creates a new Auth Scheme, from the data in the given auth scheme request
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createOrUpdateOAuth2AuthSchemeRequest"> (optional)</param>
        /// <returns>ApiResponse of CreateOrUpdateOAuth2AuthSchemeResponse</returns>
        public Elements.Client.ApiResponse<CreateOrUpdateOAuth2AuthSchemeResponse> CreateAuthScheme1WithHttpInfo(CreateOrUpdateOAuth2AuthSchemeRequest createOrUpdateOAuth2AuthSchemeRequest = default(CreateOrUpdateOAuth2AuthSchemeRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createOrUpdateOAuth2AuthSchemeRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<CreateOrUpdateOAuth2AuthSchemeResponse>("/auth_scheme/oauth2", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateAuthScheme1", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new Auth Scheme Creates a new Auth Scheme, from the data in the given auth scheme request
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createOrUpdateOAuth2AuthSchemeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CreateOrUpdateOAuth2AuthSchemeResponse</returns>
        public async System.Threading.Tasks.Task<CreateOrUpdateOAuth2AuthSchemeResponse> CreateAuthScheme1Async(CreateOrUpdateOAuth2AuthSchemeRequest createOrUpdateOAuth2AuthSchemeRequest = default(CreateOrUpdateOAuth2AuthSchemeRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateAuthScheme1WithHttpInfoAsync(createOrUpdateOAuth2AuthSchemeRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<CreateOrUpdateOAuth2AuthSchemeResponse> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<CreateOrUpdateOAuth2AuthSchemeResponse> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new Auth Scheme Creates a new Auth Scheme, from the data in the given auth scheme request
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createOrUpdateOAuth2AuthSchemeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CreateOrUpdateOAuth2AuthSchemeResponse)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<CreateOrUpdateOAuth2AuthSchemeResponse>> CreateAuthScheme1WithHttpInfoAsync(CreateOrUpdateOAuth2AuthSchemeRequest createOrUpdateOAuth2AuthSchemeRequest = default(CreateOrUpdateOAuth2AuthSchemeRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createOrUpdateOAuth2AuthSchemeRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<CreateOrUpdateOAuth2AuthSchemeResponse>("/auth_scheme/oauth2", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateAuthScheme1", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new Auth Scheme Creates a new Auth Scheme, from the data in the given auth scheme request
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createOrUpdateOidcAuthSchemeRequest"> (optional)</param>
        /// <returns>CreateOrUpdateOidcAuthSchemeResponse</returns>
        public CreateOrUpdateOidcAuthSchemeResponse CreateAuthScheme2(CreateOrUpdateOidcAuthSchemeRequest createOrUpdateOidcAuthSchemeRequest = default(CreateOrUpdateOidcAuthSchemeRequest))
        {
            Elements.Client.ApiResponse<CreateOrUpdateOidcAuthSchemeResponse> localVarResponse = CreateAuthScheme2WithHttpInfo(createOrUpdateOidcAuthSchemeRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new Auth Scheme Creates a new Auth Scheme, from the data in the given auth scheme request
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createOrUpdateOidcAuthSchemeRequest"> (optional)</param>
        /// <returns>ApiResponse of CreateOrUpdateOidcAuthSchemeResponse</returns>
        public Elements.Client.ApiResponse<CreateOrUpdateOidcAuthSchemeResponse> CreateAuthScheme2WithHttpInfo(CreateOrUpdateOidcAuthSchemeRequest createOrUpdateOidcAuthSchemeRequest = default(CreateOrUpdateOidcAuthSchemeRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createOrUpdateOidcAuthSchemeRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<CreateOrUpdateOidcAuthSchemeResponse>("/auth_scheme/oidc", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateAuthScheme2", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new Auth Scheme Creates a new Auth Scheme, from the data in the given auth scheme request
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createOrUpdateOidcAuthSchemeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CreateOrUpdateOidcAuthSchemeResponse</returns>
        public async System.Threading.Tasks.Task<CreateOrUpdateOidcAuthSchemeResponse> CreateAuthScheme2Async(CreateOrUpdateOidcAuthSchemeRequest createOrUpdateOidcAuthSchemeRequest = default(CreateOrUpdateOidcAuthSchemeRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateAuthScheme2WithHttpInfoAsync(createOrUpdateOidcAuthSchemeRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<CreateOrUpdateOidcAuthSchemeResponse> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<CreateOrUpdateOidcAuthSchemeResponse> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new Auth Scheme Creates a new Auth Scheme, from the data in the given auth scheme request
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createOrUpdateOidcAuthSchemeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CreateOrUpdateOidcAuthSchemeResponse)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<CreateOrUpdateOidcAuthSchemeResponse>> CreateAuthScheme2WithHttpInfoAsync(CreateOrUpdateOidcAuthSchemeRequest createOrUpdateOidcAuthSchemeRequest = default(CreateOrUpdateOidcAuthSchemeRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createOrUpdateOidcAuthSchemeRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<CreateOrUpdateOidcAuthSchemeResponse>("/auth_scheme/oidc", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateAuthScheme2", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create an inventory item for the specified item Create an inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createDistinctInventoryItemRequest"> (optional)</param>
        /// <returns>DistinctInventoryItem</returns>
        public DistinctInventoryItem CreateDistinctInventoryItem(CreateDistinctInventoryItemRequest createDistinctInventoryItemRequest = default(CreateDistinctInventoryItemRequest))
        {
            Elements.Client.ApiResponse<DistinctInventoryItem> localVarResponse = CreateDistinctInventoryItemWithHttpInfo(createDistinctInventoryItemRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create an inventory item for the specified item Create an inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createDistinctInventoryItemRequest"> (optional)</param>
        /// <returns>ApiResponse of DistinctInventoryItem</returns>
        public Elements.Client.ApiResponse<DistinctInventoryItem> CreateDistinctInventoryItemWithHttpInfo(CreateDistinctInventoryItemRequest createDistinctInventoryItemRequest = default(CreateDistinctInventoryItemRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createDistinctInventoryItemRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<DistinctInventoryItem>("/inventory/distinct", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateDistinctInventoryItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create an inventory item for the specified item Create an inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createDistinctInventoryItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of DistinctInventoryItem</returns>
        public async System.Threading.Tasks.Task<DistinctInventoryItem> CreateDistinctInventoryItemAsync(CreateDistinctInventoryItemRequest createDistinctInventoryItemRequest = default(CreateDistinctInventoryItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateDistinctInventoryItemWithHttpInfoAsync(createDistinctInventoryItemRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<DistinctInventoryItem> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<DistinctInventoryItem> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create an inventory item for the specified item Create an inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createDistinctInventoryItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (DistinctInventoryItem)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<DistinctInventoryItem>> CreateDistinctInventoryItemWithHttpInfoAsync(CreateDistinctInventoryItemRequest createDistinctInventoryItemRequest = default(CreateDistinctInventoryItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createDistinctInventoryItemRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<DistinctInventoryItem>("/inventory/distinct", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateDistinctInventoryItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates an FCM Registration Token Supplying FCM registration token, this will create a new token based on the information supplied to the endpoint.  The response will contain the token as it was written to the database.  Clients may subsequently update the token string with new values as they are issued by Firebase.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fCMRegistration"> (optional)</param>
        /// <returns>FCMRegistration</returns>
        public FCMRegistration CreateFCMRegistration(FCMRegistration fCMRegistration = default(FCMRegistration))
        {
            Elements.Client.ApiResponse<FCMRegistration> localVarResponse = CreateFCMRegistrationWithHttpInfo(fCMRegistration);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates an FCM Registration Token Supplying FCM registration token, this will create a new token based on the information supplied to the endpoint.  The response will contain the token as it was written to the database.  Clients may subsequently update the token string with new values as they are issued by Firebase.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fCMRegistration"> (optional)</param>
        /// <returns>ApiResponse of FCMRegistration</returns>
        public Elements.Client.ApiResponse<FCMRegistration> CreateFCMRegistrationWithHttpInfo(FCMRegistration fCMRegistration = default(FCMRegistration))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = fCMRegistration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<FCMRegistration>("/notification/fcm", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateFCMRegistration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates an FCM Registration Token Supplying FCM registration token, this will create a new token based on the information supplied to the endpoint.  The response will contain the token as it was written to the database.  Clients may subsequently update the token string with new values as they are issued by Firebase.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fCMRegistration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FCMRegistration</returns>
        public async System.Threading.Tasks.Task<FCMRegistration> CreateFCMRegistrationAsync(FCMRegistration fCMRegistration = default(FCMRegistration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateFCMRegistrationWithHttpInfoAsync(fCMRegistration, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<FCMRegistration> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<FCMRegistration> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates an FCM Registration Token Supplying FCM registration token, this will create a new token based on the information supplied to the endpoint.  The response will contain the token as it was written to the database.  Clients may subsequently update the token string with new values as they are issued by Firebase.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fCMRegistration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FCMRegistration)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<FCMRegistration>> CreateFCMRegistrationWithHttpInfoAsync(FCMRegistration fCMRegistration = default(FCMRegistration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = fCMRegistration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<FCMRegistration>("/notification/fcm", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateFCMRegistration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new Facebook ApplicationConfiguration Creates a new Facebook ApplicationConfiguration with the specific ID or application.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="facebookApplicationConfiguration"> (optional)</param>
        /// <returns>FacebookApplicationConfiguration</returns>
        public FacebookApplicationConfiguration CreateFacebookApplicationConfiguration(string applicationNameOrId, FacebookApplicationConfiguration facebookApplicationConfiguration = default(FacebookApplicationConfiguration))
        {
            Elements.Client.ApiResponse<FacebookApplicationConfiguration> localVarResponse = CreateFacebookApplicationConfigurationWithHttpInfo(applicationNameOrId, facebookApplicationConfiguration);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new Facebook ApplicationConfiguration Creates a new Facebook ApplicationConfiguration with the specific ID or application.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="facebookApplicationConfiguration"> (optional)</param>
        /// <returns>ApiResponse of FacebookApplicationConfiguration</returns>
        public Elements.Client.ApiResponse<FacebookApplicationConfiguration> CreateFacebookApplicationConfigurationWithHttpInfo(string applicationNameOrId, FacebookApplicationConfiguration facebookApplicationConfiguration = default(FacebookApplicationConfiguration))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->CreateFacebookApplicationConfiguration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.Data = facebookApplicationConfiguration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<FacebookApplicationConfiguration>("/application/{applicationNameOrId}/configuration/facebook", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateFacebookApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new Facebook ApplicationConfiguration Creates a new Facebook ApplicationConfiguration with the specific ID or application.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="facebookApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FacebookApplicationConfiguration</returns>
        public async System.Threading.Tasks.Task<FacebookApplicationConfiguration> CreateFacebookApplicationConfigurationAsync(string applicationNameOrId, FacebookApplicationConfiguration facebookApplicationConfiguration = default(FacebookApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateFacebookApplicationConfigurationWithHttpInfoAsync(applicationNameOrId, facebookApplicationConfiguration, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<FacebookApplicationConfiguration> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<FacebookApplicationConfiguration> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new Facebook ApplicationConfiguration Creates a new Facebook ApplicationConfiguration with the specific ID or application.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="facebookApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FacebookApplicationConfiguration)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<FacebookApplicationConfiguration>> CreateFacebookApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, FacebookApplicationConfiguration facebookApplicationConfiguration = default(FacebookApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->CreateFacebookApplicationConfiguration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.Data = facebookApplicationConfiguration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<FacebookApplicationConfiguration>("/application/{applicationNameOrId}/configuration/facebook", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateFacebookApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new Firebase ApplicationConfiguration Creates a new Firebase ApplicationConfiguration with the specific ID or application.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="firebaseApplicationConfiguration"> (optional)</param>
        /// <returns>FirebaseApplicationConfiguration</returns>
        public FirebaseApplicationConfiguration CreateFirebaseApplicationConfiguration(string applicationNameOrId, FirebaseApplicationConfiguration firebaseApplicationConfiguration = default(FirebaseApplicationConfiguration))
        {
            Elements.Client.ApiResponse<FirebaseApplicationConfiguration> localVarResponse = CreateFirebaseApplicationConfigurationWithHttpInfo(applicationNameOrId, firebaseApplicationConfiguration);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new Firebase ApplicationConfiguration Creates a new Firebase ApplicationConfiguration with the specific ID or application.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="firebaseApplicationConfiguration"> (optional)</param>
        /// <returns>ApiResponse of FirebaseApplicationConfiguration</returns>
        public Elements.Client.ApiResponse<FirebaseApplicationConfiguration> CreateFirebaseApplicationConfigurationWithHttpInfo(string applicationNameOrId, FirebaseApplicationConfiguration firebaseApplicationConfiguration = default(FirebaseApplicationConfiguration))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->CreateFirebaseApplicationConfiguration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.Data = firebaseApplicationConfiguration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<FirebaseApplicationConfiguration>("/application/{applicationNameOrId}/configuration/firebase", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateFirebaseApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new Firebase ApplicationConfiguration Creates a new Firebase ApplicationConfiguration with the specific ID or application.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="firebaseApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FirebaseApplicationConfiguration</returns>
        public async System.Threading.Tasks.Task<FirebaseApplicationConfiguration> CreateFirebaseApplicationConfigurationAsync(string applicationNameOrId, FirebaseApplicationConfiguration firebaseApplicationConfiguration = default(FirebaseApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateFirebaseApplicationConfigurationWithHttpInfoAsync(applicationNameOrId, firebaseApplicationConfiguration, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<FirebaseApplicationConfiguration> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<FirebaseApplicationConfiguration> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new Firebase ApplicationConfiguration Creates a new Firebase ApplicationConfiguration with the specific ID or application.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="firebaseApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FirebaseApplicationConfiguration)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<FirebaseApplicationConfiguration>> CreateFirebaseApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, FirebaseApplicationConfiguration firebaseApplicationConfiguration = default(FirebaseApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->CreateFirebaseApplicationConfiguration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.Data = firebaseApplicationConfiguration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<FirebaseApplicationConfiguration>("/application/{applicationNameOrId}/configuration/firebase", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateFirebaseApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a Follower relationship between two profiles. Supplying the follower object, this will store the information supplied in the body of the request.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="createFollowerRequest"> (optional)</param>
        /// <returns></returns>
        public void CreateFollower(string profileId, CreateFollowerRequest createFollowerRequest = default(CreateFollowerRequest))
        {
            CreateFollowerWithHttpInfo(profileId, createFollowerRequest);
        }

        /// <summary>
        /// Creates a Follower relationship between two profiles. Supplying the follower object, this will store the information supplied in the body of the request.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="createFollowerRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> CreateFollowerWithHttpInfo(string profileId, CreateFollowerRequest createFollowerRequest = default(CreateFollowerRequest))
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'profileId' when calling DefaultApi->CreateFollower");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("profileId", Elements.Client.ClientUtils.ParameterToString(profileId)); // path parameter
            localVarRequestOptions.Data = createFollowerRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/follower/{profileId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateFollower", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a Follower relationship between two profiles. Supplying the follower object, this will store the information supplied in the body of the request.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="createFollowerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task CreateFollowerAsync(string profileId, CreateFollowerRequest createFollowerRequest = default(CreateFollowerRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateFollowerWithHttpInfoAsync(profileId, createFollowerRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Creates a Follower relationship between two profiles. Supplying the follower object, this will store the information supplied in the body of the request.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="createFollowerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> CreateFollowerWithHttpInfoAsync(string profileId, CreateFollowerRequest createFollowerRequest = default(CreateFollowerRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'profileId' when calling DefaultApi->CreateFollower");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("profileId", Elements.Client.ClientUtils.ParameterToString(profileId)); // path parameter
            localVarRequestOptions.Data = createFollowerRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<Object>("/follower/{profileId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateFollower", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new Google Play ApplicationConfiguration Creates a new GooglePlay ApplicationConfiguration with the specific ID or application.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="googlePlayApplicationConfiguration"> (optional)</param>
        /// <returns>GooglePlayApplicationConfiguration</returns>
        public GooglePlayApplicationConfiguration CreateGooglePlayApplicationConfiguration(string applicationNameOrId, GooglePlayApplicationConfiguration googlePlayApplicationConfiguration = default(GooglePlayApplicationConfiguration))
        {
            Elements.Client.ApiResponse<GooglePlayApplicationConfiguration> localVarResponse = CreateGooglePlayApplicationConfigurationWithHttpInfo(applicationNameOrId, googlePlayApplicationConfiguration);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new Google Play ApplicationConfiguration Creates a new GooglePlay ApplicationConfiguration with the specific ID or application.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="googlePlayApplicationConfiguration"> (optional)</param>
        /// <returns>ApiResponse of GooglePlayApplicationConfiguration</returns>
        public Elements.Client.ApiResponse<GooglePlayApplicationConfiguration> CreateGooglePlayApplicationConfigurationWithHttpInfo(string applicationNameOrId, GooglePlayApplicationConfiguration googlePlayApplicationConfiguration = default(GooglePlayApplicationConfiguration))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->CreateGooglePlayApplicationConfiguration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.Data = googlePlayApplicationConfiguration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<GooglePlayApplicationConfiguration>("/application/{applicationNameOrId}/configuration/google_play", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateGooglePlayApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new Google Play ApplicationConfiguration Creates a new GooglePlay ApplicationConfiguration with the specific ID or application.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="googlePlayApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GooglePlayApplicationConfiguration</returns>
        public async System.Threading.Tasks.Task<GooglePlayApplicationConfiguration> CreateGooglePlayApplicationConfigurationAsync(string applicationNameOrId, GooglePlayApplicationConfiguration googlePlayApplicationConfiguration = default(GooglePlayApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateGooglePlayApplicationConfigurationWithHttpInfoAsync(applicationNameOrId, googlePlayApplicationConfiguration, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<GooglePlayApplicationConfiguration> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<GooglePlayApplicationConfiguration> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new Google Play ApplicationConfiguration Creates a new GooglePlay ApplicationConfiguration with the specific ID or application.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="googlePlayApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GooglePlayApplicationConfiguration)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<GooglePlayApplicationConfiguration>> CreateGooglePlayApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, GooglePlayApplicationConfiguration googlePlayApplicationConfiguration = default(GooglePlayApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->CreateGooglePlayApplicationConfiguration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.Data = googlePlayApplicationConfiguration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<GooglePlayApplicationConfiguration>("/application/{applicationNameOrId}/configuration/google_play", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateGooglePlayApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new iOS ApplicationConfiguration Creates a new iOS ApplicationConfiguration with the specific ID or application.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="iosApplicationConfiguration"> (optional)</param>
        /// <returns>IosApplicationConfiguration</returns>
        public IosApplicationConfiguration CreateIosApplicationConfiguration(string applicationNameOrId, IosApplicationConfiguration iosApplicationConfiguration = default(IosApplicationConfiguration))
        {
            Elements.Client.ApiResponse<IosApplicationConfiguration> localVarResponse = CreateIosApplicationConfigurationWithHttpInfo(applicationNameOrId, iosApplicationConfiguration);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new iOS ApplicationConfiguration Creates a new iOS ApplicationConfiguration with the specific ID or application.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="iosApplicationConfiguration"> (optional)</param>
        /// <returns>ApiResponse of IosApplicationConfiguration</returns>
        public Elements.Client.ApiResponse<IosApplicationConfiguration> CreateIosApplicationConfigurationWithHttpInfo(string applicationNameOrId, IosApplicationConfiguration iosApplicationConfiguration = default(IosApplicationConfiguration))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->CreateIosApplicationConfiguration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.Data = iosApplicationConfiguration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<IosApplicationConfiguration>("/application/{applicationNameOrId}/configuration/ios", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateIosApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new iOS ApplicationConfiguration Creates a new iOS ApplicationConfiguration with the specific ID or application.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="iosApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IosApplicationConfiguration</returns>
        public async System.Threading.Tasks.Task<IosApplicationConfiguration> CreateIosApplicationConfigurationAsync(string applicationNameOrId, IosApplicationConfiguration iosApplicationConfiguration = default(IosApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateIosApplicationConfigurationWithHttpInfoAsync(applicationNameOrId, iosApplicationConfiguration, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<IosApplicationConfiguration> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<IosApplicationConfiguration> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new iOS ApplicationConfiguration Creates a new iOS ApplicationConfiguration with the specific ID or application.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="iosApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IosApplicationConfiguration)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<IosApplicationConfiguration>> CreateIosApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, IosApplicationConfiguration iosApplicationConfiguration = default(IosApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->CreateIosApplicationConfiguration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.Data = iosApplicationConfiguration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<IosApplicationConfiguration>("/application/{applicationNameOrId}/configuration/ios", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateIosApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new digital Item Supplying an item object, this will create a new item with a newly assigned unique id.  The Item representation returned in the response body is a representation of the Item as persisted with a unique identifier signed and with its fields properly normalized.  The supplied item object submitted with the request must have a name property that is unique across all items.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createItemRequest"> (optional)</param>
        /// <returns>Item</returns>
        public Item CreateItem(CreateItemRequest createItemRequest = default(CreateItemRequest))
        {
            Elements.Client.ApiResponse<Item> localVarResponse = CreateItemWithHttpInfo(createItemRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new digital Item Supplying an item object, this will create a new item with a newly assigned unique id.  The Item representation returned in the response body is a representation of the Item as persisted with a unique identifier signed and with its fields properly normalized.  The supplied item object submitted with the request must have a name property that is unique across all items.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createItemRequest"> (optional)</param>
        /// <returns>ApiResponse of Item</returns>
        public Elements.Client.ApiResponse<Item> CreateItemWithHttpInfo(CreateItemRequest createItemRequest = default(CreateItemRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createItemRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Item>("/item", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new digital Item Supplying an item object, this will create a new item with a newly assigned unique id.  The Item representation returned in the response body is a representation of the Item as persisted with a unique identifier signed and with its fields properly normalized.  The supplied item object submitted with the request must have a name property that is unique across all items.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Item</returns>
        public async System.Threading.Tasks.Task<Item> CreateItemAsync(CreateItemRequest createItemRequest = default(CreateItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateItemWithHttpInfoAsync(createItemRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Item> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Item> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new digital Item Supplying an item object, this will create a new item with a newly assigned unique id.  The Item representation returned in the response body is a representation of the Item as persisted with a unique identifier signed and with its fields properly normalized.  The supplied item object submitted with the request must have a name property that is unique across all items.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Item)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Item>> CreateItemWithHttpInfoAsync(CreateItemRequest createItemRequest = default(CreateItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createItemRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<Item>("/item", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a LargeObject with content 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="varObject"> (optional)</param>
        /// <param name="metadata"> (optional)</param>
        /// <returns>LargeObject</returns>
        public LargeObject CreateLargeObject(FormDataBodyPart varObject = default(FormDataBodyPart), CreateLargeObjectRequest metadata = default(CreateLargeObjectRequest))
        {
            Elements.Client.ApiResponse<LargeObject> localVarResponse = CreateLargeObjectWithHttpInfo(varObject, metadata);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a LargeObject with content 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="varObject"> (optional)</param>
        /// <param name="metadata"> (optional)</param>
        /// <returns>ApiResponse of LargeObject</returns>
        public Elements.Client.ApiResponse<LargeObject> CreateLargeObjectWithHttpInfo(FormDataBodyPart varObject = default(FormDataBodyPart), CreateLargeObjectRequest metadata = default(CreateLargeObjectRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "multipart/form-data"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (varObject != null)
            {
                localVarRequestOptions.FormParameters.Add("object", Elements.Client.ClientUtils.ParameterToString(varObject)); // form parameter
            }
            if (metadata != null)
            {
                localVarRequestOptions.FormParameters.Add("metadata", Elements.Client.ClientUtils.ParameterToString(metadata)); // form parameter
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<LargeObject>("/large_object_mp", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateLargeObject", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a LargeObject with content 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="varObject"> (optional)</param>
        /// <param name="metadata"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LargeObject</returns>
        public async System.Threading.Tasks.Task<LargeObject> CreateLargeObjectAsync(FormDataBodyPart varObject = default(FormDataBodyPart), CreateLargeObjectRequest metadata = default(CreateLargeObjectRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateLargeObjectWithHttpInfoAsync(varObject, metadata, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<LargeObject> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<LargeObject> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a LargeObject with content 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="varObject"> (optional)</param>
        /// <param name="metadata"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LargeObject)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<LargeObject>> CreateLargeObjectWithHttpInfoAsync(FormDataBodyPart varObject = default(FormDataBodyPart), CreateLargeObjectRequest metadata = default(CreateLargeObjectRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "multipart/form-data"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (varObject != null)
            {
                localVarRequestOptions.FormParameters.Add("object", Elements.Client.ClientUtils.ParameterToString(varObject)); // form parameter
            }
            if (metadata != null)
            {
                localVarRequestOptions.FormParameters.Add("metadata", Elements.Client.ClientUtils.ParameterToString(metadata)); // form parameter
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<LargeObject>("/large_object_mp", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateLargeObject", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a LargeObject 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createLargeObjectRequest"> (optional)</param>
        /// <returns>LargeObject</returns>
        public LargeObject CreateLargeObject1(CreateLargeObjectRequest createLargeObjectRequest = default(CreateLargeObjectRequest))
        {
            Elements.Client.ApiResponse<LargeObject> localVarResponse = CreateLargeObject1WithHttpInfo(createLargeObjectRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a LargeObject 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createLargeObjectRequest"> (optional)</param>
        /// <returns>ApiResponse of LargeObject</returns>
        public Elements.Client.ApiResponse<LargeObject> CreateLargeObject1WithHttpInfo(CreateLargeObjectRequest createLargeObjectRequest = default(CreateLargeObjectRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createLargeObjectRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<LargeObject>("/large_object", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateLargeObject1", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a LargeObject 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createLargeObjectRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LargeObject</returns>
        public async System.Threading.Tasks.Task<LargeObject> CreateLargeObject1Async(CreateLargeObjectRequest createLargeObjectRequest = default(CreateLargeObjectRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateLargeObject1WithHttpInfoAsync(createLargeObjectRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<LargeObject> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<LargeObject> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a LargeObject 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createLargeObjectRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LargeObject)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<LargeObject>> CreateLargeObject1WithHttpInfoAsync(CreateLargeObjectRequest createLargeObjectRequest = default(CreateLargeObjectRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createLargeObjectRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<LargeObject>("/large_object", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateLargeObject1", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a LargeObject from provided URL 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createLargeObjectFromUrlRequest"> (optional)</param>
        /// <returns>LargeObject</returns>
        public LargeObject CreateLargeObjectFromUrl(CreateLargeObjectFromUrlRequest createLargeObjectFromUrlRequest = default(CreateLargeObjectFromUrlRequest))
        {
            Elements.Client.ApiResponse<LargeObject> localVarResponse = CreateLargeObjectFromUrlWithHttpInfo(createLargeObjectFromUrlRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a LargeObject from provided URL 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createLargeObjectFromUrlRequest"> (optional)</param>
        /// <returns>ApiResponse of LargeObject</returns>
        public Elements.Client.ApiResponse<LargeObject> CreateLargeObjectFromUrlWithHttpInfo(CreateLargeObjectFromUrlRequest createLargeObjectFromUrlRequest = default(CreateLargeObjectFromUrlRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createLargeObjectFromUrlRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<LargeObject>("/large_object/from_url", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateLargeObjectFromUrl", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a LargeObject from provided URL 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createLargeObjectFromUrlRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LargeObject</returns>
        public async System.Threading.Tasks.Task<LargeObject> CreateLargeObjectFromUrlAsync(CreateLargeObjectFromUrlRequest createLargeObjectFromUrlRequest = default(CreateLargeObjectFromUrlRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateLargeObjectFromUrlWithHttpInfoAsync(createLargeObjectFromUrlRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<LargeObject> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<LargeObject> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a LargeObject from provided URL 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createLargeObjectFromUrlRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LargeObject)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<LargeObject>> CreateLargeObjectFromUrlWithHttpInfoAsync(CreateLargeObjectFromUrlRequest createLargeObjectFromUrlRequest = default(CreateLargeObjectFromUrlRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createLargeObjectFromUrlRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<LargeObject>("/large_object/from_url", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateLargeObjectFromUrl", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a New Leaderboard Gets the metadata for a single leaderboard.  This may include more specific details not available in the bulk-get or fetch operation.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboard"> (optional)</param>
        /// <returns>Leaderboard</returns>
        public Leaderboard CreateLeaderboard(Leaderboard leaderboard = default(Leaderboard))
        {
            Elements.Client.ApiResponse<Leaderboard> localVarResponse = CreateLeaderboardWithHttpInfo(leaderboard);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a New Leaderboard Gets the metadata for a single leaderboard.  This may include more specific details not available in the bulk-get or fetch operation.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboard"> (optional)</param>
        /// <returns>ApiResponse of Leaderboard</returns>
        public Elements.Client.ApiResponse<Leaderboard> CreateLeaderboardWithHttpInfo(Leaderboard leaderboard = default(Leaderboard))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = leaderboard;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Leaderboard>("/leaderboard", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateLeaderboard", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a New Leaderboard Gets the metadata for a single leaderboard.  This may include more specific details not available in the bulk-get or fetch operation.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboard"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Leaderboard</returns>
        public async System.Threading.Tasks.Task<Leaderboard> CreateLeaderboardAsync(Leaderboard leaderboard = default(Leaderboard), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateLeaderboardWithHttpInfoAsync(leaderboard, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Leaderboard> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Leaderboard> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a New Leaderboard Gets the metadata for a single leaderboard.  This may include more specific details not available in the bulk-get or fetch operation.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboard"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Leaderboard)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Leaderboard>> CreateLeaderboardWithHttpInfoAsync(Leaderboard leaderboard = default(Leaderboard), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = leaderboard;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<Leaderboard>("/leaderboard", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateLeaderboard", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a Match This method accepts an instance of Match, effectively requesting that the server find a suitable opponent for a game.  As other suitable players create matches the created match object may be updated as a suitable opponent is found.  The client must poll matches for updates and react accordingly.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="match"> (optional)</param>
        /// <returns>Match</returns>
        public Match CreateMatch(Match match = default(Match))
        {
            Elements.Client.ApiResponse<Match> localVarResponse = CreateMatchWithHttpInfo(match);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a Match This method accepts an instance of Match, effectively requesting that the server find a suitable opponent for a game.  As other suitable players create matches the created match object may be updated as a suitable opponent is found.  The client must poll matches for updates and react accordingly.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="match"> (optional)</param>
        /// <returns>ApiResponse of Match</returns>
        public Elements.Client.ApiResponse<Match> CreateMatchWithHttpInfo(Match match = default(Match))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = match;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Match>("/match", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateMatch", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a Match This method accepts an instance of Match, effectively requesting that the server find a suitable opponent for a game.  As other suitable players create matches the created match object may be updated as a suitable opponent is found.  The client must poll matches for updates and react accordingly.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="match"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Match</returns>
        public async System.Threading.Tasks.Task<Match> CreateMatchAsync(Match match = default(Match), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateMatchWithHttpInfoAsync(match, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Match> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Match> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a Match This method accepts an instance of Match, effectively requesting that the server find a suitable opponent for a game.  As other suitable players create matches the created match object may be updated as a suitable opponent is found.  The client must poll matches for updates and react accordingly.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="match"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Match)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Match>> CreateMatchWithHttpInfoAsync(Match match = default(Match), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = match;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<Match>("/match", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateMatch", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new iOS ApplicationConfiguration Creates a new iOS ApplicationConfiguration with the specific ID or application.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="matchmakingApplicationConfiguration"> (optional)</param>
        /// <returns>MatchmakingApplicationConfiguration</returns>
        public MatchmakingApplicationConfiguration CreateMatchmakingApplicationConfiguration(string applicationNameOrId, MatchmakingApplicationConfiguration matchmakingApplicationConfiguration = default(MatchmakingApplicationConfiguration))
        {
            Elements.Client.ApiResponse<MatchmakingApplicationConfiguration> localVarResponse = CreateMatchmakingApplicationConfigurationWithHttpInfo(applicationNameOrId, matchmakingApplicationConfiguration);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new iOS ApplicationConfiguration Creates a new iOS ApplicationConfiguration with the specific ID or application.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="matchmakingApplicationConfiguration"> (optional)</param>
        /// <returns>ApiResponse of MatchmakingApplicationConfiguration</returns>
        public Elements.Client.ApiResponse<MatchmakingApplicationConfiguration> CreateMatchmakingApplicationConfigurationWithHttpInfo(string applicationNameOrId, MatchmakingApplicationConfiguration matchmakingApplicationConfiguration = default(MatchmakingApplicationConfiguration))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->CreateMatchmakingApplicationConfiguration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.Data = matchmakingApplicationConfiguration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<MatchmakingApplicationConfiguration>("/application/{applicationNameOrId}/configuration/matchmaking", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateMatchmakingApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new iOS ApplicationConfiguration Creates a new iOS ApplicationConfiguration with the specific ID or application.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="matchmakingApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MatchmakingApplicationConfiguration</returns>
        public async System.Threading.Tasks.Task<MatchmakingApplicationConfiguration> CreateMatchmakingApplicationConfigurationAsync(string applicationNameOrId, MatchmakingApplicationConfiguration matchmakingApplicationConfiguration = default(MatchmakingApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateMatchmakingApplicationConfigurationWithHttpInfoAsync(applicationNameOrId, matchmakingApplicationConfiguration, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<MatchmakingApplicationConfiguration> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<MatchmakingApplicationConfiguration> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new iOS ApplicationConfiguration Creates a new iOS ApplicationConfiguration with the specific ID or application.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="matchmakingApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MatchmakingApplicationConfiguration)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<MatchmakingApplicationConfiguration>> CreateMatchmakingApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, MatchmakingApplicationConfiguration matchmakingApplicationConfiguration = default(MatchmakingApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->CreateMatchmakingApplicationConfiguration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.Data = matchmakingApplicationConfiguration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<MatchmakingApplicationConfiguration>("/application/{applicationNameOrId}/configuration/matchmaking", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateMatchmakingApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new Metadata object Creates a new Metadata object with the provided details.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createMetadataRequest"> (optional)</param>
        /// <returns>Metadata</returns>
        public Metadata CreateMetadata(CreateMetadataRequest createMetadataRequest = default(CreateMetadataRequest))
        {
            Elements.Client.ApiResponse<Metadata> localVarResponse = CreateMetadataWithHttpInfo(createMetadataRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new Metadata object Creates a new Metadata object with the provided details.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createMetadataRequest"> (optional)</param>
        /// <returns>ApiResponse of Metadata</returns>
        public Elements.Client.ApiResponse<Metadata> CreateMetadataWithHttpInfo(CreateMetadataRequest createMetadataRequest = default(CreateMetadataRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createMetadataRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Metadata>("/metadata", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateMetadata", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new Metadata object Creates a new Metadata object with the provided details.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createMetadataRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Metadata</returns>
        public async System.Threading.Tasks.Task<Metadata> CreateMetadataAsync(CreateMetadataRequest createMetadataRequest = default(CreateMetadataRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateMetadataWithHttpInfoAsync(createMetadataRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Metadata> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Metadata> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new Metadata object Creates a new Metadata object with the provided details.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createMetadataRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Metadata)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Metadata>> CreateMetadataWithHttpInfoAsync(CreateMetadataRequest createMetadataRequest = default(CreateMetadataRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createMetadataRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<Metadata>("/metadata", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateMetadata", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new Metadata Spec definition Creates a new Metadata Spec definition.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createMetadataSpecRequest"> (optional)</param>
        /// <returns>MetadataSpec</returns>
        public MetadataSpec CreateMetadataSpec(CreateMetadataSpecRequest createMetadataSpecRequest = default(CreateMetadataSpecRequest))
        {
            Elements.Client.ApiResponse<MetadataSpec> localVarResponse = CreateMetadataSpecWithHttpInfo(createMetadataSpecRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new Metadata Spec definition Creates a new Metadata Spec definition.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createMetadataSpecRequest"> (optional)</param>
        /// <returns>ApiResponse of MetadataSpec</returns>
        public Elements.Client.ApiResponse<MetadataSpec> CreateMetadataSpecWithHttpInfo(CreateMetadataSpecRequest createMetadataSpecRequest = default(CreateMetadataSpecRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createMetadataSpecRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<MetadataSpec>("/metadata_spec", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateMetadataSpec", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new Metadata Spec definition Creates a new Metadata Spec definition.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createMetadataSpecRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MetadataSpec</returns>
        public async System.Threading.Tasks.Task<MetadataSpec> CreateMetadataSpecAsync(CreateMetadataSpecRequest createMetadataSpecRequest = default(CreateMetadataSpecRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateMetadataSpecWithHttpInfoAsync(createMetadataSpecRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<MetadataSpec> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<MetadataSpec> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new Metadata Spec definition Creates a new Metadata Spec definition.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createMetadataSpecRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MetadataSpec)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<MetadataSpec>> CreateMetadataSpecWithHttpInfoAsync(CreateMetadataSpecRequest createMetadataSpecRequest = default(CreateMetadataSpecRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createMetadataSpecRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<MetadataSpec>("/metadata_spec", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateMetadataSpec", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new mission Supplying a mission object, this will create a new mission with a newly assigned unique id.  The Mission representation returned in the response body is a representation of the Mission as persisted with a unique identifier assigned and with its fields properly normalized.  The supplied mission object submitted with the request must have a name property that is unique across all items.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mission"> (optional)</param>
        /// <returns>Mission</returns>
        public Mission CreateMission(Mission mission = default(Mission))
        {
            Elements.Client.ApiResponse<Mission> localVarResponse = CreateMissionWithHttpInfo(mission);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new mission Supplying a mission object, this will create a new mission with a newly assigned unique id.  The Mission representation returned in the response body is a representation of the Mission as persisted with a unique identifier assigned and with its fields properly normalized.  The supplied mission object submitted with the request must have a name property that is unique across all items.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mission"> (optional)</param>
        /// <returns>ApiResponse of Mission</returns>
        public Elements.Client.ApiResponse<Mission> CreateMissionWithHttpInfo(Mission mission = default(Mission))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = mission;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Mission>("/mission", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateMission", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new mission Supplying a mission object, this will create a new mission with a newly assigned unique id.  The Mission representation returned in the response body is a representation of the Mission as persisted with a unique identifier assigned and with its fields properly normalized.  The supplied mission object submitted with the request must have a name property that is unique across all items.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mission"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Mission</returns>
        public async System.Threading.Tasks.Task<Mission> CreateMissionAsync(Mission mission = default(Mission), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateMissionWithHttpInfoAsync(mission, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Mission> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Mission> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new mission Supplying a mission object, this will create a new mission with a newly assigned unique id.  The Mission representation returned in the response body is a representation of the Mission as persisted with a unique identifier assigned and with its fields properly normalized.  The supplied mission object submitted with the request must have a name property that is unique across all items.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mission"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Mission)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Mission>> CreateMissionWithHttpInfoAsync(Mission mission = default(Mission), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = mission;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<Mission>("/mission", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateMission", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a Mock Session Begins a session by accepting a mock session request.  The request must be made with an authenticated super-user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mockSessionRequest"> (optional)</param>
        /// <returns>MockSessionCreation</returns>
        public MockSessionCreation CreateMockSession(MockSessionRequest mockSessionRequest = default(MockSessionRequest))
        {
            Elements.Client.ApiResponse<MockSessionCreation> localVarResponse = CreateMockSessionWithHttpInfo(mockSessionRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a Mock Session Begins a session by accepting a mock session request.  The request must be made with an authenticated super-user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mockSessionRequest"> (optional)</param>
        /// <returns>ApiResponse of MockSessionCreation</returns>
        public Elements.Client.ApiResponse<MockSessionCreation> CreateMockSessionWithHttpInfo(MockSessionRequest mockSessionRequest = default(MockSessionRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = mockSessionRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<MockSessionCreation>("/mock_session", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateMockSession", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a Mock Session Begins a session by accepting a mock session request.  The request must be made with an authenticated super-user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mockSessionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MockSessionCreation</returns>
        public async System.Threading.Tasks.Task<MockSessionCreation> CreateMockSessionAsync(MockSessionRequest mockSessionRequest = default(MockSessionRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateMockSessionWithHttpInfoAsync(mockSessionRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<MockSessionCreation> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<MockSessionCreation> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a Mock Session Begins a session by accepting a mock session request.  The request must be made with an authenticated super-user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mockSessionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MockSessionCreation)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<MockSessionCreation>> CreateMockSessionWithHttpInfoAsync(MockSessionRequest mockSessionRequest = default(MockSessionRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = mockSessionRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<MockSessionCreation>("/mock_session", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateMockSession", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="createDeploymentRequest"> (optional)</param>
        /// <returns>Deployment</returns>
        public Deployment CreateNewDeployment(string applicationId, CreateDeploymentRequest createDeploymentRequest = default(CreateDeploymentRequest))
        {
            Elements.Client.ApiResponse<Deployment> localVarResponse = CreateNewDeploymentWithHttpInfo(applicationId, createDeploymentRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="createDeploymentRequest"> (optional)</param>
        /// <returns>ApiResponse of Deployment</returns>
        public Elements.Client.ApiResponse<Deployment> CreateNewDeploymentWithHttpInfo(string applicationId, CreateDeploymentRequest createDeploymentRequest = default(CreateDeploymentRequest))
        {
            // verify the required parameter 'applicationId' is set
            if (applicationId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationId' when calling DefaultApi->CreateNewDeployment");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationId", Elements.Client.ClientUtils.ParameterToString(applicationId)); // path parameter
            localVarRequestOptions.Data = createDeploymentRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Deployment>("/deployment/{applicationId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateNewDeployment", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="createDeploymentRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Deployment</returns>
        public async System.Threading.Tasks.Task<Deployment> CreateNewDeploymentAsync(string applicationId, CreateDeploymentRequest createDeploymentRequest = default(CreateDeploymentRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateNewDeploymentWithHttpInfoAsync(applicationId, createDeploymentRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Deployment> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Deployment> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="createDeploymentRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Deployment)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Deployment>> CreateNewDeploymentWithHttpInfoAsync(string applicationId, CreateDeploymentRequest createDeploymentRequest = default(CreateDeploymentRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationId' is set
            if (applicationId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationId' when calling DefaultApi->CreateNewDeployment");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationId", Elements.Client.ClientUtils.ParameterToString(applicationId)); // path parameter
            localVarRequestOptions.Data = createDeploymentRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<Deployment>("/deployment/{applicationId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateNewDeployment", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a Session using OAuth2 Begins a session by accepting a session request with parameters matching the specified OAuth2 Scheme. Upon successful validation against the scheme provided in the path, this will return a Session which can be used for authentication. If there is no User associated with the supplied credentials, this will implicitly create a new account and will include that account information in the response. If there is an account, or this method receives an existing session key, this will link to the existing scheme if the account was not previously linked.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2SessionRequest"> (optional)</param>
        /// <returns>SessionCreation</returns>
        public SessionCreation CreateOAuth2Session(OAuth2SessionRequest oAuth2SessionRequest = default(OAuth2SessionRequest))
        {
            Elements.Client.ApiResponse<SessionCreation> localVarResponse = CreateOAuth2SessionWithHttpInfo(oAuth2SessionRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a Session using OAuth2 Begins a session by accepting a session request with parameters matching the specified OAuth2 Scheme. Upon successful validation against the scheme provided in the path, this will return a Session which can be used for authentication. If there is no User associated with the supplied credentials, this will implicitly create a new account and will include that account information in the response. If there is an account, or this method receives an existing session key, this will link to the existing scheme if the account was not previously linked.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2SessionRequest"> (optional)</param>
        /// <returns>ApiResponse of SessionCreation</returns>
        public Elements.Client.ApiResponse<SessionCreation> CreateOAuth2SessionWithHttpInfo(OAuth2SessionRequest oAuth2SessionRequest = default(OAuth2SessionRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = oAuth2SessionRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SessionCreation>("/auth/oauth2", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateOAuth2Session", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a Session using OAuth2 Begins a session by accepting a session request with parameters matching the specified OAuth2 Scheme. Upon successful validation against the scheme provided in the path, this will return a Session which can be used for authentication. If there is no User associated with the supplied credentials, this will implicitly create a new account and will include that account information in the response. If there is an account, or this method receives an existing session key, this will link to the existing scheme if the account was not previously linked.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2SessionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SessionCreation</returns>
        public async System.Threading.Tasks.Task<SessionCreation> CreateOAuth2SessionAsync(OAuth2SessionRequest oAuth2SessionRequest = default(OAuth2SessionRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateOAuth2SessionWithHttpInfoAsync(oAuth2SessionRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<SessionCreation> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<SessionCreation> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a Session using OAuth2 Begins a session by accepting a session request with parameters matching the specified OAuth2 Scheme. Upon successful validation against the scheme provided in the path, this will return a Session which can be used for authentication. If there is no User associated with the supplied credentials, this will implicitly create a new account and will include that account information in the response. If there is an account, or this method receives an existing session key, this will link to the existing scheme if the account was not previously linked.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2SessionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SessionCreation)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<SessionCreation>> CreateOAuth2SessionWithHttpInfoAsync(OAuth2SessionRequest oAuth2SessionRequest = default(OAuth2SessionRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = oAuth2SessionRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<SessionCreation>("/auth/oauth2", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateOAuth2Session", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a Session using OIDC Begins a session by accepting a JWT. Upon successful validation against the scheme provided in the path, this will return a Session which can be used for authentication. If there is no User associated with the supplied credentials, this will implicitly create a new account and will include that account information in the response. If there is an account, or this method receives an existing session key, this will link to the existing scheme if the account was not previously linked.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcSessionRequest"> (optional)</param>
        /// <returns>SessionCreation</returns>
        public SessionCreation CreateOidcSession(OidcSessionRequest oidcSessionRequest = default(OidcSessionRequest))
        {
            Elements.Client.ApiResponse<SessionCreation> localVarResponse = CreateOidcSessionWithHttpInfo(oidcSessionRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a Session using OIDC Begins a session by accepting a JWT. Upon successful validation against the scheme provided in the path, this will return a Session which can be used for authentication. If there is no User associated with the supplied credentials, this will implicitly create a new account and will include that account information in the response. If there is an account, or this method receives an existing session key, this will link to the existing scheme if the account was not previously linked.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcSessionRequest"> (optional)</param>
        /// <returns>ApiResponse of SessionCreation</returns>
        public Elements.Client.ApiResponse<SessionCreation> CreateOidcSessionWithHttpInfo(OidcSessionRequest oidcSessionRequest = default(OidcSessionRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = oidcSessionRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SessionCreation>("/auth/oidc", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateOidcSession", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a Session using OIDC Begins a session by accepting a JWT. Upon successful validation against the scheme provided in the path, this will return a Session which can be used for authentication. If there is no User associated with the supplied credentials, this will implicitly create a new account and will include that account information in the response. If there is an account, or this method receives an existing session key, this will link to the existing scheme if the account was not previously linked.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcSessionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SessionCreation</returns>
        public async System.Threading.Tasks.Task<SessionCreation> CreateOidcSessionAsync(OidcSessionRequest oidcSessionRequest = default(OidcSessionRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateOidcSessionWithHttpInfoAsync(oidcSessionRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<SessionCreation> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<SessionCreation> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a Session using OIDC Begins a session by accepting a JWT. Upon successful validation against the scheme provided in the path, this will return a Session which can be used for authentication. If there is no User associated with the supplied credentials, this will implicitly create a new account and will include that account information in the response. If there is an account, or this method receives an existing session key, this will link to the existing scheme if the account was not previously linked.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcSessionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SessionCreation)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<SessionCreation>> CreateOidcSessionWithHttpInfoAsync(OidcSessionRequest oidcSessionRequest = default(OidcSessionRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = oidcSessionRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<SessionCreation>("/auth/oidc", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateOidcSession", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new PSN ApplicationConfiguration Creates a new PSN ApplicationConfiguration with the specific ID or application.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="pSNApplicationConfiguration"> (optional)</param>
        /// <returns>PSNApplicationConfiguration</returns>
        public PSNApplicationConfiguration CreatePSNApplicationConfiguration(string applicationNameOrId, PSNApplicationConfiguration pSNApplicationConfiguration = default(PSNApplicationConfiguration))
        {
            Elements.Client.ApiResponse<PSNApplicationConfiguration> localVarResponse = CreatePSNApplicationConfigurationWithHttpInfo(applicationNameOrId, pSNApplicationConfiguration);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new PSN ApplicationConfiguration Creates a new PSN ApplicationConfiguration with the specific ID or application.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="pSNApplicationConfiguration"> (optional)</param>
        /// <returns>ApiResponse of PSNApplicationConfiguration</returns>
        public Elements.Client.ApiResponse<PSNApplicationConfiguration> CreatePSNApplicationConfigurationWithHttpInfo(string applicationNameOrId, PSNApplicationConfiguration pSNApplicationConfiguration = default(PSNApplicationConfiguration))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->CreatePSNApplicationConfiguration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.Data = pSNApplicationConfiguration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<PSNApplicationConfiguration>("/application/{applicationNameOrId}/configuration/psn", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreatePSNApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new PSN ApplicationConfiguration Creates a new PSN ApplicationConfiguration with the specific ID or application.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="pSNApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PSNApplicationConfiguration</returns>
        public async System.Threading.Tasks.Task<PSNApplicationConfiguration> CreatePSNApplicationConfigurationAsync(string applicationNameOrId, PSNApplicationConfiguration pSNApplicationConfiguration = default(PSNApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreatePSNApplicationConfigurationWithHttpInfoAsync(applicationNameOrId, pSNApplicationConfiguration, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PSNApplicationConfiguration> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PSNApplicationConfiguration> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new PSN ApplicationConfiguration Creates a new PSN ApplicationConfiguration with the specific ID or application.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="pSNApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PSNApplicationConfiguration)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PSNApplicationConfiguration>> CreatePSNApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, PSNApplicationConfiguration pSNApplicationConfiguration = default(PSNApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->CreatePSNApplicationConfiguration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.Data = pSNApplicationConfiguration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<PSNApplicationConfiguration>("/application/{applicationNameOrId}/configuration/psn", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreatePSNApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a Profile Supplying the create profile request, this will update the profile with the new information supplied in the body of the request. This will fire an event, dev.getelements.elements.service.profile.created, from the event manifest.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createProfileRequest"> (optional)</param>
        /// <returns>Profile</returns>
        public Profile CreateProfile(CreateProfileRequest createProfileRequest = default(CreateProfileRequest))
        {
            Elements.Client.ApiResponse<Profile> localVarResponse = CreateProfileWithHttpInfo(createProfileRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a Profile Supplying the create profile request, this will update the profile with the new information supplied in the body of the request. This will fire an event, dev.getelements.elements.service.profile.created, from the event manifest.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createProfileRequest"> (optional)</param>
        /// <returns>ApiResponse of Profile</returns>
        public Elements.Client.ApiResponse<Profile> CreateProfileWithHttpInfo(CreateProfileRequest createProfileRequest = default(CreateProfileRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createProfileRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Profile>("/profile", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateProfile", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a Profile Supplying the create profile request, this will update the profile with the new information supplied in the body of the request. This will fire an event, dev.getelements.elements.service.profile.created, from the event manifest.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createProfileRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Profile</returns>
        public async System.Threading.Tasks.Task<Profile> CreateProfileAsync(CreateProfileRequest createProfileRequest = default(CreateProfileRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateProfileWithHttpInfoAsync(createProfileRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Profile> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Profile> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a Profile Supplying the create profile request, this will update the profile with the new information supplied in the body of the request. This will fire an event, dev.getelements.elements.service.profile.created, from the event manifest.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createProfileRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Profile)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Profile>> CreateProfileWithHttpInfoAsync(CreateProfileRequest createProfileRequest = default(CreateProfileRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createProfileRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<Profile>("/profile", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateProfile", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new progress Supplying a progress object, this will create a new progress with a newly assigned unique id.  The Progress representation returned in the response body is a representation of the Progress as persisted with a unique identifier assigned and with its fields properly normalized.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progress"> (optional)</param>
        /// <returns>Progress</returns>
        public Progress CreateProgress(Progress progress = default(Progress))
        {
            Elements.Client.ApiResponse<Progress> localVarResponse = CreateProgressWithHttpInfo(progress);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new progress Supplying a progress object, this will create a new progress with a newly assigned unique id.  The Progress representation returned in the response body is a representation of the Progress as persisted with a unique identifier assigned and with its fields properly normalized.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progress"> (optional)</param>
        /// <returns>ApiResponse of Progress</returns>
        public Elements.Client.ApiResponse<Progress> CreateProgressWithHttpInfo(Progress progress = default(Progress))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = progress;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Progress>("/progress", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateProgress", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new progress Supplying a progress object, this will create a new progress with a newly assigned unique id.  The Progress representation returned in the response body is a representation of the Progress as persisted with a unique identifier assigned and with its fields properly normalized.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progress"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Progress</returns>
        public async System.Threading.Tasks.Task<Progress> CreateProgressAsync(Progress progress = default(Progress), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateProgressWithHttpInfoAsync(progress, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Progress> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Progress> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new progress Supplying a progress object, this will create a new progress with a newly assigned unique id.  The Progress representation returned in the response body is a representation of the Progress as persisted with a unique identifier assigned and with its fields properly normalized.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progress"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Progress)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Progress>> CreateProgressWithHttpInfoAsync(Progress progress = default(Progress), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = progress;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<Progress>("/progress", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateProgress", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a save data document. Gets a single save data document.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createSaveDataDocumentRequest"> (optional)</param>
        /// <returns>SaveDataDocument</returns>
        public SaveDataDocument CreateSaveDocument(CreateSaveDataDocumentRequest createSaveDataDocumentRequest = default(CreateSaveDataDocumentRequest))
        {
            Elements.Client.ApiResponse<SaveDataDocument> localVarResponse = CreateSaveDocumentWithHttpInfo(createSaveDataDocumentRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a save data document. Gets a single save data document.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createSaveDataDocumentRequest"> (optional)</param>
        /// <returns>ApiResponse of SaveDataDocument</returns>
        public Elements.Client.ApiResponse<SaveDataDocument> CreateSaveDocumentWithHttpInfo(CreateSaveDataDocumentRequest createSaveDataDocumentRequest = default(CreateSaveDataDocumentRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createSaveDataDocumentRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SaveDataDocument>("/save_data", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateSaveDocument", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a save data document. Gets a single save data document.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createSaveDataDocumentRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SaveDataDocument</returns>
        public async System.Threading.Tasks.Task<SaveDataDocument> CreateSaveDocumentAsync(CreateSaveDataDocumentRequest createSaveDataDocumentRequest = default(CreateSaveDataDocumentRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateSaveDocumentWithHttpInfoAsync(createSaveDataDocumentRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<SaveDataDocument> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<SaveDataDocument> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a save data document. Gets a single save data document.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createSaveDataDocumentRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SaveDataDocument)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<SaveDataDocument>> CreateSaveDocumentWithHttpInfoAsync(CreateSaveDataDocumentRequest createSaveDataDocumentRequest = default(CreateSaveDataDocumentRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createSaveDataDocumentRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<SaveDataDocument>("/save_data", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateSaveDocument", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new schedule Supplying a schedule object, this will create a new schedule with a newly assigned unique id.  The Schedule representation returned in the response body is a representation of the Schedule as persisted with a unique identifier assigned and with its fields properly normalized.  The supplied schedule object submitted with the request must have a name property that is unique across all items.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createScheduleRequest"> (optional)</param>
        /// <returns>Schedule</returns>
        public Schedule CreateSchedule(CreateScheduleRequest createScheduleRequest = default(CreateScheduleRequest))
        {
            Elements.Client.ApiResponse<Schedule> localVarResponse = CreateScheduleWithHttpInfo(createScheduleRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new schedule Supplying a schedule object, this will create a new schedule with a newly assigned unique id.  The Schedule representation returned in the response body is a representation of the Schedule as persisted with a unique identifier assigned and with its fields properly normalized.  The supplied schedule object submitted with the request must have a name property that is unique across all items.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createScheduleRequest"> (optional)</param>
        /// <returns>ApiResponse of Schedule</returns>
        public Elements.Client.ApiResponse<Schedule> CreateScheduleWithHttpInfo(CreateScheduleRequest createScheduleRequest = default(CreateScheduleRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createScheduleRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Schedule>("/schedule", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateSchedule", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new schedule Supplying a schedule object, this will create a new schedule with a newly assigned unique id.  The Schedule representation returned in the response body is a representation of the Schedule as persisted with a unique identifier assigned and with its fields properly normalized.  The supplied schedule object submitted with the request must have a name property that is unique across all items.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createScheduleRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Schedule</returns>
        public async System.Threading.Tasks.Task<Schedule> CreateScheduleAsync(CreateScheduleRequest createScheduleRequest = default(CreateScheduleRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateScheduleWithHttpInfoAsync(createScheduleRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Schedule> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Schedule> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new schedule Supplying a schedule object, this will create a new schedule with a newly assigned unique id.  The Schedule representation returned in the response body is a representation of the Schedule as persisted with a unique identifier assigned and with its fields properly normalized.  The supplied schedule object submitted with the request must have a name property that is unique across all items.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createScheduleRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Schedule)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Schedule>> CreateScheduleWithHttpInfoAsync(CreateScheduleRequest createScheduleRequest = default(CreateScheduleRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createScheduleRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<Schedule>("/schedule", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateSchedule", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new schedule Supplying a schedule object, this will create a new schedule with a newly assigned unique id.  The ScheduleEvent representation returned in the response body is a representation of the ScheduleEvent as persisted with a unique identifier assigned and with its fields properly normalized.  The supplied schedule object submitted with the request must have a name property that is unique across all items.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="createScheduleEventRequest"> (optional)</param>
        /// <returns>ScheduleEvent</returns>
        public ScheduleEvent CreateScheduleEvent(string scheduleNameOrId, CreateScheduleEventRequest createScheduleEventRequest = default(CreateScheduleEventRequest))
        {
            Elements.Client.ApiResponse<ScheduleEvent> localVarResponse = CreateScheduleEventWithHttpInfo(scheduleNameOrId, createScheduleEventRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new schedule Supplying a schedule object, this will create a new schedule with a newly assigned unique id.  The ScheduleEvent representation returned in the response body is a representation of the ScheduleEvent as persisted with a unique identifier assigned and with its fields properly normalized.  The supplied schedule object submitted with the request must have a name property that is unique across all items.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="createScheduleEventRequest"> (optional)</param>
        /// <returns>ApiResponse of ScheduleEvent</returns>
        public Elements.Client.ApiResponse<ScheduleEvent> CreateScheduleEventWithHttpInfo(string scheduleNameOrId, CreateScheduleEventRequest createScheduleEventRequest = default(CreateScheduleEventRequest))
        {
            // verify the required parameter 'scheduleNameOrId' is set
            if (scheduleNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'scheduleNameOrId' when calling DefaultApi->CreateScheduleEvent");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("scheduleNameOrId", Elements.Client.ClientUtils.ParameterToString(scheduleNameOrId)); // path parameter
            localVarRequestOptions.Data = createScheduleEventRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<ScheduleEvent>("/schedule/{scheduleNameOrId}/event", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateScheduleEvent", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new schedule Supplying a schedule object, this will create a new schedule with a newly assigned unique id.  The ScheduleEvent representation returned in the response body is a representation of the ScheduleEvent as persisted with a unique identifier assigned and with its fields properly normalized.  The supplied schedule object submitted with the request must have a name property that is unique across all items.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="createScheduleEventRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ScheduleEvent</returns>
        public async System.Threading.Tasks.Task<ScheduleEvent> CreateScheduleEventAsync(string scheduleNameOrId, CreateScheduleEventRequest createScheduleEventRequest = default(CreateScheduleEventRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateScheduleEventWithHttpInfoAsync(scheduleNameOrId, createScheduleEventRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<ScheduleEvent> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<ScheduleEvent> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new schedule Supplying a schedule object, this will create a new schedule with a newly assigned unique id.  The ScheduleEvent representation returned in the response body is a representation of the ScheduleEvent as persisted with a unique identifier assigned and with its fields properly normalized.  The supplied schedule object submitted with the request must have a name property that is unique across all items.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="createScheduleEventRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ScheduleEvent)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<ScheduleEvent>> CreateScheduleEventWithHttpInfoAsync(string scheduleNameOrId, CreateScheduleEventRequest createScheduleEventRequest = default(CreateScheduleEventRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'scheduleNameOrId' is set
            if (scheduleNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'scheduleNameOrId' when calling DefaultApi->CreateScheduleEvent");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("scheduleNameOrId", Elements.Client.ClientUtils.ParameterToString(scheduleNameOrId)); // path parameter
            localVarRequestOptions.Data = createScheduleEventRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<ScheduleEvent>("/schedule/{scheduleNameOrId}/event", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateScheduleEvent", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a New Score Posts a single score for the currently logged-in profile. Conceptually, this is creationg a new resource, however the server may opt to overwrite the existing identifier if it sees fit.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">The name or id of the leaderboard.</param>
        /// <param name="score"> (optional)</param>
        /// <returns>Score</returns>
        public Score CreateScore(string leaderboardNameOrId, Score score = default(Score))
        {
            Elements.Client.ApiResponse<Score> localVarResponse = CreateScoreWithHttpInfo(leaderboardNameOrId, score);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a New Score Posts a single score for the currently logged-in profile. Conceptually, this is creationg a new resource, however the server may opt to overwrite the existing identifier if it sees fit.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">The name or id of the leaderboard.</param>
        /// <param name="score"> (optional)</param>
        /// <returns>ApiResponse of Score</returns>
        public Elements.Client.ApiResponse<Score> CreateScoreWithHttpInfo(string leaderboardNameOrId, Score score = default(Score))
        {
            // verify the required parameter 'leaderboardNameOrId' is set
            if (leaderboardNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'leaderboardNameOrId' when calling DefaultApi->CreateScore");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("leaderboardNameOrId", Elements.Client.ClientUtils.ParameterToString(leaderboardNameOrId)); // path parameter
            localVarRequestOptions.Data = score;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Score>("/score/{leaderboardNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateScore", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a New Score Posts a single score for the currently logged-in profile. Conceptually, this is creationg a new resource, however the server may opt to overwrite the existing identifier if it sees fit.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">The name or id of the leaderboard.</param>
        /// <param name="score"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Score</returns>
        public async System.Threading.Tasks.Task<Score> CreateScoreAsync(string leaderboardNameOrId, Score score = default(Score), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateScoreWithHttpInfoAsync(leaderboardNameOrId, score, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Score> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Score> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a New Score Posts a single score for the currently logged-in profile. Conceptually, this is creationg a new resource, however the server may opt to overwrite the existing identifier if it sees fit.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">The name or id of the leaderboard.</param>
        /// <param name="score"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Score)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Score>> CreateScoreWithHttpInfoAsync(string leaderboardNameOrId, Score score = default(Score), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'leaderboardNameOrId' is set
            if (leaderboardNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'leaderboardNameOrId' when calling DefaultApi->CreateScore");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("leaderboardNameOrId", Elements.Client.ClientUtils.ParameterToString(leaderboardNameOrId)); // path parameter
            localVarRequestOptions.Data = score;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<Score>("/score/{leaderboardNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateScore", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create an inventory item for the specified item Create an inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createSimpleInventoryItemRequest"> (optional)</param>
        /// <returns>InventoryItem</returns>
        public InventoryItem CreateSimpleInventoryItem(CreateSimpleInventoryItemRequest createSimpleInventoryItemRequest = default(CreateSimpleInventoryItemRequest))
        {
            Elements.Client.ApiResponse<InventoryItem> localVarResponse = CreateSimpleInventoryItemWithHttpInfo(createSimpleInventoryItemRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create an inventory item for the specified item Create an inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createSimpleInventoryItemRequest"> (optional)</param>
        /// <returns>ApiResponse of InventoryItem</returns>
        public Elements.Client.ApiResponse<InventoryItem> CreateSimpleInventoryItemWithHttpInfo(CreateSimpleInventoryItemRequest createSimpleInventoryItemRequest = default(CreateSimpleInventoryItemRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createSimpleInventoryItemRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<InventoryItem>("/inventory/simple", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateSimpleInventoryItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create an inventory item for the specified item Create an inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createSimpleInventoryItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InventoryItem</returns>
        public async System.Threading.Tasks.Task<InventoryItem> CreateSimpleInventoryItemAsync(CreateSimpleInventoryItemRequest createSimpleInventoryItemRequest = default(CreateSimpleInventoryItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateSimpleInventoryItemWithHttpInfoAsync(createSimpleInventoryItemRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<InventoryItem> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<InventoryItem> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create an inventory item for the specified item Create an inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createSimpleInventoryItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InventoryItem)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<InventoryItem>> CreateSimpleInventoryItemWithHttpInfoAsync(CreateSimpleInventoryItemRequest createSimpleInventoryItemRequest = default(CreateSimpleInventoryItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createSimpleInventoryItemRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<InventoryItem>("/inventory/simple", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateSimpleInventoryItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Patches a  Smart Contract Patches a  Smart Contract entry, associated with the specified deployed script hash.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createSmartContractRequest"> (optional)</param>
        /// <returns>SmartContract</returns>
        public SmartContract CreateSmartContract(CreateSmartContractRequest createSmartContractRequest = default(CreateSmartContractRequest))
        {
            Elements.Client.ApiResponse<SmartContract> localVarResponse = CreateSmartContractWithHttpInfo(createSmartContractRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Patches a  Smart Contract Patches a  Smart Contract entry, associated with the specified deployed script hash.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createSmartContractRequest"> (optional)</param>
        /// <returns>ApiResponse of SmartContract</returns>
        public Elements.Client.ApiResponse<SmartContract> CreateSmartContractWithHttpInfo(CreateSmartContractRequest createSmartContractRequest = default(CreateSmartContractRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createSmartContractRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SmartContract>("/blockchain/omni/smart_contract", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateSmartContract", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Patches a  Smart Contract Patches a  Smart Contract entry, associated with the specified deployed script hash.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createSmartContractRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SmartContract</returns>
        public async System.Threading.Tasks.Task<SmartContract> CreateSmartContractAsync(CreateSmartContractRequest createSmartContractRequest = default(CreateSmartContractRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateSmartContractWithHttpInfoAsync(createSmartContractRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<SmartContract> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<SmartContract> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Patches a  Smart Contract Patches a  Smart Contract entry, associated with the specified deployed script hash.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createSmartContractRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SmartContract)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<SmartContract>> CreateSmartContractWithHttpInfoAsync(CreateSmartContractRequest createSmartContractRequest = default(CreateSmartContractRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createSmartContractRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<SmartContract>("/blockchain/omni/smart_contract", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateSmartContract", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a User Supplying the user object, this will update the user with the new information supplied in the body of the request.  Optionally, the user&#39;s password may be provided in the User object.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userCreateRequest"> (optional)</param>
        /// <returns>UserCreateResponse</returns>
        public UserCreateResponse CreateUser(UserCreateRequest userCreateRequest = default(UserCreateRequest))
        {
            Elements.Client.ApiResponse<UserCreateResponse> localVarResponse = CreateUserWithHttpInfo(userCreateRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a User Supplying the user object, this will update the user with the new information supplied in the body of the request.  Optionally, the user&#39;s password may be provided in the User object.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userCreateRequest"> (optional)</param>
        /// <returns>ApiResponse of UserCreateResponse</returns>
        public Elements.Client.ApiResponse<UserCreateResponse> CreateUserWithHttpInfo(UserCreateRequest userCreateRequest = default(UserCreateRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = userCreateRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<UserCreateResponse>("/user", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateUser", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a User Supplying the user object, this will update the user with the new information supplied in the body of the request.  Optionally, the user&#39;s password may be provided in the User object.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userCreateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UserCreateResponse</returns>
        public async System.Threading.Tasks.Task<UserCreateResponse> CreateUserAsync(UserCreateRequest userCreateRequest = default(UserCreateRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateUserWithHttpInfoAsync(userCreateRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<UserCreateResponse> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<UserCreateResponse> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a User Supplying the user object, this will update the user with the new information supplied in the body of the request.  Optionally, the user&#39;s password may be provided in the User object.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userCreateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UserCreateResponse)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<UserCreateResponse>> CreateUserWithHttpInfoAsync(UserCreateRequest userCreateRequest = default(UserCreateRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = userCreateRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<UserCreateResponse>("/user", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateUser", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a Session Begins a session by accepting both the UserID and the Passoword.  Upon successful completion of this call, the user will be added to the current HTTP session.  If the session expires, the user will have to reestablish the session by supplying credentials again.  This is most useful for applications delivered in a web page.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="usernamePasswordSessionRequest"> (optional)</param>
        /// <returns>SessionCreation</returns>
        public SessionCreation CreateUsernamePasswordSession(UsernamePasswordSessionRequest usernamePasswordSessionRequest = default(UsernamePasswordSessionRequest))
        {
            Elements.Client.ApiResponse<SessionCreation> localVarResponse = CreateUsernamePasswordSessionWithHttpInfo(usernamePasswordSessionRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a Session Begins a session by accepting both the UserID and the Passoword.  Upon successful completion of this call, the user will be added to the current HTTP session.  If the session expires, the user will have to reestablish the session by supplying credentials again.  This is most useful for applications delivered in a web page.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="usernamePasswordSessionRequest"> (optional)</param>
        /// <returns>ApiResponse of SessionCreation</returns>
        public Elements.Client.ApiResponse<SessionCreation> CreateUsernamePasswordSessionWithHttpInfo(UsernamePasswordSessionRequest usernamePasswordSessionRequest = default(UsernamePasswordSessionRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = usernamePasswordSessionRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SessionCreation>("/session", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateUsernamePasswordSession", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a Session Begins a session by accepting both the UserID and the Passoword.  Upon successful completion of this call, the user will be added to the current HTTP session.  If the session expires, the user will have to reestablish the session by supplying credentials again.  This is most useful for applications delivered in a web page.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="usernamePasswordSessionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SessionCreation</returns>
        public async System.Threading.Tasks.Task<SessionCreation> CreateUsernamePasswordSessionAsync(UsernamePasswordSessionRequest usernamePasswordSessionRequest = default(UsernamePasswordSessionRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateUsernamePasswordSessionWithHttpInfoAsync(usernamePasswordSessionRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<SessionCreation> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<SessionCreation> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a Session Begins a session by accepting both the UserID and the Passoword.  Upon successful completion of this call, the user will be added to the current HTTP session.  If the session expires, the user will have to reestablish the session by supplying credentials again.  This is most useful for applications delivered in a web page.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="usernamePasswordSessionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SessionCreation)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<SessionCreation>> CreateUsernamePasswordSessionWithHttpInfoAsync(UsernamePasswordSessionRequest usernamePasswordSessionRequest = default(UsernamePasswordSessionRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = usernamePasswordSessionRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<SessionCreation>("/session", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateUsernamePasswordSession", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new  Vault Creates a new  Vault, associated with the given user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createVaultRequest"> (optional)</param>
        /// <returns>Vault</returns>
        public Vault CreateVault(CreateVaultRequest createVaultRequest = default(CreateVaultRequest))
        {
            Elements.Client.ApiResponse<Vault> localVarResponse = CreateVaultWithHttpInfo(createVaultRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new  Vault Creates a new  Vault, associated with the given user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createVaultRequest"> (optional)</param>
        /// <returns>ApiResponse of Vault</returns>
        public Elements.Client.ApiResponse<Vault> CreateVaultWithHttpInfo(CreateVaultRequest createVaultRequest = default(CreateVaultRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createVaultRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Vault>("/blockchain/omni/vault", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateVault", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new  Vault Creates a new  Vault, associated with the given user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createVaultRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Vault</returns>
        public async System.Threading.Tasks.Task<Vault> CreateVaultAsync(CreateVaultRequest createVaultRequest = default(CreateVaultRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateVaultWithHttpInfoAsync(createVaultRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Vault> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Vault> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new  Vault Creates a new  Vault, associated with the given user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createVaultRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Vault)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Vault>> CreateVaultWithHttpInfoAsync(CreateVaultRequest createVaultRequest = default(CreateVaultRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createVaultRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<Vault>("/blockchain/omni/vault", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateVault", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new  Wallet Creates a new  Wallet, associated with the given user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="createWalletRequest"> (optional)</param>
        /// <returns>Wallet</returns>
        public Wallet CreateWallet(string vaultId, CreateWalletRequest createWalletRequest = default(CreateWalletRequest))
        {
            Elements.Client.ApiResponse<Wallet> localVarResponse = CreateWalletWithHttpInfo(vaultId, createWalletRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new  Wallet Creates a new  Wallet, associated with the given user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="createWalletRequest"> (optional)</param>
        /// <returns>ApiResponse of Wallet</returns>
        public Elements.Client.ApiResponse<Wallet> CreateWalletWithHttpInfo(string vaultId, CreateWalletRequest createWalletRequest = default(CreateWalletRequest))
        {
            // verify the required parameter 'vaultId' is set
            if (vaultId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'vaultId' when calling DefaultApi->CreateWallet");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("vaultId", Elements.Client.ClientUtils.ParameterToString(vaultId)); // path parameter
            localVarRequestOptions.Data = createWalletRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Wallet>("/blockchain/omni/vault/{vaultId}/wallet", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateWallet", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a new  Wallet Creates a new  Wallet, associated with the given user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="createWalletRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Wallet</returns>
        public async System.Threading.Tasks.Task<Wallet> CreateWalletAsync(string vaultId, CreateWalletRequest createWalletRequest = default(CreateWalletRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = CreateWalletWithHttpInfoAsync(vaultId, createWalletRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Wallet> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Wallet> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a new  Wallet Creates a new  Wallet, associated with the given user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="createWalletRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Wallet)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Wallet>> CreateWalletWithHttpInfoAsync(string vaultId, CreateWalletRequest createWalletRequest = default(CreateWalletRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'vaultId' is set
            if (vaultId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'vaultId' when calling DefaultApi->CreateWallet");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("vaultId", Elements.Client.ClientUtils.ParameterToString(vaultId)); // path parameter
            localVarRequestOptions.Data = createWalletRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<Wallet>("/blockchain/omni/vault/{vaultId}/wallet", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateWallet", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a Profile Deletes and permanently removes the Profile from the server.  The server maykeep some record around to preserve relationships and references, but this profile will not be accessible again until it is recreated.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <returns></returns>
        public void DeactivateProfile(string profileId)
        {
            DeactivateProfileWithHttpInfo(profileId);
        }

        /// <summary>
        /// Deletes a Profile Deletes and permanently removes the Profile from the server.  The server maykeep some record around to preserve relationships and references, but this profile will not be accessible again until it is recreated.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeactivateProfileWithHttpInfo(string profileId)
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'profileId' when calling DefaultApi->DeactivateProfile");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*",
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("profileId", Elements.Client.ClientUtils.ParameterToString(profileId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/profile/{profileId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeactivateProfile", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a Profile Deletes and permanently removes the Profile from the server.  The server maykeep some record around to preserve relationships and references, but this profile will not be accessible again until it is recreated.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeactivateProfileAsync(string profileId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeactivateProfileWithHttpInfoAsync(profileId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes a Profile Deletes and permanently removes the Profile from the server.  The server maykeep some record around to preserve relationships and references, but this profile will not be accessible again until it is recreated.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeactivateProfileWithHttpInfoAsync(string profileId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'profileId' when calling DefaultApi->DeactivateProfile");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*",
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("profileId", Elements.Client.ClientUtils.ParameterToString(profileId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/profile/{profileId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeactivateProfile", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a User Deletes and permanently removes the user from the server.  The server may keep some metadata as necessary to avoid data inconsistency.  However, the user has been deleted from the client standpoint and will not be accessible through any of the existing APIs.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <returns></returns>
        public void DeactivateUser(string name)
        {
            DeactivateUserWithHttpInfo(name);
        }

        /// <summary>
        /// Deletes a User Deletes and permanently removes the user from the server.  The server may keep some metadata as necessary to avoid data inconsistency.  However, the user has been deleted from the client standpoint and will not be accessible through any of the existing APIs.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeactivateUserWithHttpInfo(string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'name' when calling DefaultApi->DeactivateUser");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*",
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("name", Elements.Client.ClientUtils.ParameterToString(name)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/user/{name}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeactivateUser", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a User Deletes and permanently removes the user from the server.  The server may keep some metadata as necessary to avoid data inconsistency.  However, the user has been deleted from the client standpoint and will not be accessible through any of the existing APIs.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeactivateUserAsync(string name, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeactivateUserWithHttpInfoAsync(name, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes a User Deletes and permanently removes the user from the server.  The server may keep some metadata as necessary to avoid data inconsistency.  However, the user has been deleted from the client standpoint and will not be accessible through any of the existing APIs.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeactivateUserWithHttpInfoAsync(string name, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'name' when calling DefaultApi->DeactivateUser");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*",
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("name", Elements.Client.ClientUtils.ParameterToString(name)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/user/{name}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeactivateUser", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete the inventory item as identified by the given item name/id Delete the inventory item as identified by the given item name/id
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <returns></returns>
        public void DeleteAdvancedInventoryItem(string inventoryItemId)
        {
            DeleteAdvancedInventoryItemWithHttpInfo(inventoryItemId);
        }

        /// <summary>
        /// Delete the inventory item as identified by the given item name/id Delete the inventory item as identified by the given item name/id
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteAdvancedInventoryItemWithHttpInfo(string inventoryItemId)
        {
            // verify the required parameter 'inventoryItemId' is set
            if (inventoryItemId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'inventoryItemId' when calling DefaultApi->DeleteAdvancedInventoryItem");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("inventoryItemId", Elements.Client.ClientUtils.ParameterToString(inventoryItemId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/inventory/advanced/{inventoryItemId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAdvancedInventoryItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete the inventory item as identified by the given item name/id Delete the inventory item as identified by the given item name/id
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteAdvancedInventoryItemAsync(string inventoryItemId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteAdvancedInventoryItemWithHttpInfoAsync(inventoryItemId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Delete the inventory item as identified by the given item name/id Delete the inventory item as identified by the given item name/id
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteAdvancedInventoryItemWithHttpInfoAsync(string inventoryItemId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'inventoryItemId' is set
            if (inventoryItemId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'inventoryItemId' when calling DefaultApi->DeleteAdvancedInventoryItem");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("inventoryItemId", Elements.Client.ClientUtils.ParameterToString(inventoryItemId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/inventory/advanced/{inventoryItemId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAdvancedInventoryItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes an Application Deletes a specific application known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <returns></returns>
        public void DeleteApplication(string nameOrId)
        {
            DeleteApplicationWithHttpInfo(nameOrId);
        }

        /// <summary>
        /// Deletes an Application Deletes a specific application known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteApplicationWithHttpInfo(string nameOrId)
        {
            // verify the required parameter 'nameOrId' is set
            if (nameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'nameOrId' when calling DefaultApi->DeleteApplication");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*",
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("nameOrId", Elements.Client.ClientUtils.ParameterToString(nameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/application/{nameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApplication", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes an Application Deletes a specific application known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteApplicationAsync(string nameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteApplicationWithHttpInfoAsync(nameOrId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes an Application Deletes a specific application known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteApplicationWithHttpInfoAsync(string nameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'nameOrId' is set
            if (nameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'nameOrId' when calling DefaultApi->DeleteApplication");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*",
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("nameOrId", Elements.Client.ClientUtils.ParameterToString(nameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/application/{nameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApplication", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes an Auth Scheme Deletes an Auth Scheme with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSchemeId"></param>
        /// <returns></returns>
        public void DeleteAuthScheme(string authSchemeId)
        {
            DeleteAuthSchemeWithHttpInfo(authSchemeId);
        }

        /// <summary>
        /// Deletes an Auth Scheme Deletes an Auth Scheme with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSchemeId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteAuthSchemeWithHttpInfo(string authSchemeId)
        {
            // verify the required parameter 'authSchemeId' is set
            if (authSchemeId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'authSchemeId' when calling DefaultApi->DeleteAuthScheme");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("authSchemeId", Elements.Client.ClientUtils.ParameterToString(authSchemeId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/auth_scheme/custom/{authSchemeId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAuthScheme", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes an Auth Scheme Deletes an Auth Scheme with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSchemeId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteAuthSchemeAsync(string authSchemeId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteAuthSchemeWithHttpInfoAsync(authSchemeId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes an Auth Scheme Deletes an Auth Scheme with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSchemeId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteAuthSchemeWithHttpInfoAsync(string authSchemeId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'authSchemeId' is set
            if (authSchemeId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'authSchemeId' when calling DefaultApi->DeleteAuthScheme");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("authSchemeId", Elements.Client.ClientUtils.ParameterToString(authSchemeId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/auth_scheme/custom/{authSchemeId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAuthScheme", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes an Auth Scheme Deletes an Auth Scheme with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2AuthSchemeId"></param>
        /// <returns></returns>
        public void DeleteAuthScheme1(string oAuth2AuthSchemeId)
        {
            DeleteAuthScheme1WithHttpInfo(oAuth2AuthSchemeId);
        }

        /// <summary>
        /// Deletes an Auth Scheme Deletes an Auth Scheme with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2AuthSchemeId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteAuthScheme1WithHttpInfo(string oAuth2AuthSchemeId)
        {
            // verify the required parameter 'oAuth2AuthSchemeId' is set
            if (oAuth2AuthSchemeId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'oAuth2AuthSchemeId' when calling DefaultApi->DeleteAuthScheme1");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("oAuth2AuthSchemeId", Elements.Client.ClientUtils.ParameterToString(oAuth2AuthSchemeId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/auth_scheme/oauth2/{oAuth2AuthSchemeId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAuthScheme1", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes an Auth Scheme Deletes an Auth Scheme with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2AuthSchemeId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteAuthScheme1Async(string oAuth2AuthSchemeId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteAuthScheme1WithHttpInfoAsync(oAuth2AuthSchemeId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes an Auth Scheme Deletes an Auth Scheme with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2AuthSchemeId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteAuthScheme1WithHttpInfoAsync(string oAuth2AuthSchemeId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'oAuth2AuthSchemeId' is set
            if (oAuth2AuthSchemeId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'oAuth2AuthSchemeId' when calling DefaultApi->DeleteAuthScheme1");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("oAuth2AuthSchemeId", Elements.Client.ClientUtils.ParameterToString(oAuth2AuthSchemeId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/auth_scheme/oauth2/{oAuth2AuthSchemeId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAuthScheme1", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes an Auth Scheme Deletes an Auth Scheme with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcAuthSchemeId"></param>
        /// <returns></returns>
        public void DeleteAuthScheme2(string oidcAuthSchemeId)
        {
            DeleteAuthScheme2WithHttpInfo(oidcAuthSchemeId);
        }

        /// <summary>
        /// Deletes an Auth Scheme Deletes an Auth Scheme with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcAuthSchemeId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteAuthScheme2WithHttpInfo(string oidcAuthSchemeId)
        {
            // verify the required parameter 'oidcAuthSchemeId' is set
            if (oidcAuthSchemeId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'oidcAuthSchemeId' when calling DefaultApi->DeleteAuthScheme2");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("oidcAuthSchemeId", Elements.Client.ClientUtils.ParameterToString(oidcAuthSchemeId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/auth_scheme/oidc/{oidcAuthSchemeId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAuthScheme2", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes an Auth Scheme Deletes an Auth Scheme with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcAuthSchemeId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteAuthScheme2Async(string oidcAuthSchemeId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteAuthScheme2WithHttpInfoAsync(oidcAuthSchemeId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes an Auth Scheme Deletes an Auth Scheme with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcAuthSchemeId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteAuthScheme2WithHttpInfoAsync(string oidcAuthSchemeId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'oidcAuthSchemeId' is set
            if (oidcAuthSchemeId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'oidcAuthSchemeId' when calling DefaultApi->DeleteAuthScheme2");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("oidcAuthSchemeId", Elements.Client.ClientUtils.ParameterToString(oidcAuthSchemeId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/auth_scheme/oidc/{oidcAuthSchemeId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAuthScheme2", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a  Smart Contract Deletes a  Smart Contract with the specified contractId.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractId"></param>
        /// <returns></returns>
        public void DeleteContract(string contractId)
        {
            DeleteContractWithHttpInfo(contractId);
        }

        /// <summary>
        /// Deletes a  Smart Contract Deletes a  Smart Contract with the specified contractId.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteContractWithHttpInfo(string contractId)
        {
            // verify the required parameter 'contractId' is set
            if (contractId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'contractId' when calling DefaultApi->DeleteContract");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("contractId", Elements.Client.ClientUtils.ParameterToString(contractId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/blockchain/omni/smart_contract/{contractId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteContract", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a  Smart Contract Deletes a  Smart Contract with the specified contractId.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteContractAsync(string contractId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteContractWithHttpInfoAsync(contractId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes a  Smart Contract Deletes a  Smart Contract with the specified contractId.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteContractWithHttpInfoAsync(string contractId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'contractId' is set
            if (contractId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'contractId' when calling DefaultApi->DeleteContract");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("contractId", Elements.Client.ClientUtils.ParameterToString(contractId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/blockchain/omni/smart_contract/{contractId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteContract", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="deploymentId"></param>
        /// <returns></returns>
        public void DeleteDeployment(string applicationId, string deploymentId)
        {
            DeleteDeploymentWithHttpInfo(applicationId, deploymentId);
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="deploymentId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteDeploymentWithHttpInfo(string applicationId, string deploymentId)
        {
            // verify the required parameter 'applicationId' is set
            if (applicationId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationId' when calling DefaultApi->DeleteDeployment");

            // verify the required parameter 'deploymentId' is set
            if (deploymentId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'deploymentId' when calling DefaultApi->DeleteDeployment");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*",
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationId", Elements.Client.ClientUtils.ParameterToString(applicationId)); // path parameter
            localVarRequestOptions.PathParameters.Add("deploymentId", Elements.Client.ClientUtils.ParameterToString(deploymentId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/deployment/{applicationId}/{deploymentId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteDeployment", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="deploymentId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteDeploymentAsync(string applicationId, string deploymentId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteDeploymentWithHttpInfoAsync(applicationId, deploymentId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="deploymentId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteDeploymentWithHttpInfoAsync(string applicationId, string deploymentId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationId' is set
            if (applicationId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationId' when calling DefaultApi->DeleteDeployment");

            // verify the required parameter 'deploymentId' is set
            if (deploymentId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'deploymentId' when calling DefaultApi->DeleteDeployment");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*",
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationId", Elements.Client.ClientUtils.ParameterToString(applicationId)); // path parameter
            localVarRequestOptions.PathParameters.Add("deploymentId", Elements.Client.ClientUtils.ParameterToString(deploymentId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/deployment/{applicationId}/{deploymentId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteDeployment", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete the inventory item as identified by the given item name/id Delete the inventory item as identified by the given item name/id
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="distinctInventoryItemId"></param>
        /// <returns></returns>
        public void DeleteDistinctInventoryItem(string distinctInventoryItemId)
        {
            DeleteDistinctInventoryItemWithHttpInfo(distinctInventoryItemId);
        }

        /// <summary>
        /// Delete the inventory item as identified by the given item name/id Delete the inventory item as identified by the given item name/id
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="distinctInventoryItemId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteDistinctInventoryItemWithHttpInfo(string distinctInventoryItemId)
        {
            // verify the required parameter 'distinctInventoryItemId' is set
            if (distinctInventoryItemId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'distinctInventoryItemId' when calling DefaultApi->DeleteDistinctInventoryItem");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("distinctInventoryItemId", Elements.Client.ClientUtils.ParameterToString(distinctInventoryItemId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/inventory/distinct/{distinctInventoryItemId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteDistinctInventoryItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete the inventory item as identified by the given item name/id Delete the inventory item as identified by the given item name/id
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="distinctInventoryItemId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteDistinctInventoryItemAsync(string distinctInventoryItemId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteDistinctInventoryItemWithHttpInfoAsync(distinctInventoryItemId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Delete the inventory item as identified by the given item name/id Delete the inventory item as identified by the given item name/id
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="distinctInventoryItemId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteDistinctInventoryItemWithHttpInfoAsync(string distinctInventoryItemId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'distinctInventoryItemId' is set
            if (distinctInventoryItemId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'distinctInventoryItemId' when calling DefaultApi->DeleteDistinctInventoryItem");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("distinctInventoryItemId", Elements.Client.ClientUtils.ParameterToString(distinctInventoryItemId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/inventory/distinct/{distinctInventoryItemId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteDistinctInventoryItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fcmRegistrationId"></param>
        /// <returns></returns>
        public void DeleteFCMRegistration(string fcmRegistrationId)
        {
            DeleteFCMRegistrationWithHttpInfo(fcmRegistrationId);
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fcmRegistrationId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteFCMRegistrationWithHttpInfo(string fcmRegistrationId)
        {
            // verify the required parameter 'fcmRegistrationId' is set
            if (fcmRegistrationId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'fcmRegistrationId' when calling DefaultApi->DeleteFCMRegistration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("fcmRegistrationId", Elements.Client.ClientUtils.ParameterToString(fcmRegistrationId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/notification/fcm/{fcmRegistrationId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteFCMRegistration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fcmRegistrationId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteFCMRegistrationAsync(string fcmRegistrationId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteFCMRegistrationWithHttpInfoAsync(fcmRegistrationId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fcmRegistrationId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteFCMRegistrationWithHttpInfoAsync(string fcmRegistrationId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'fcmRegistrationId' is set
            if (fcmRegistrationId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'fcmRegistrationId' when calling DefaultApi->DeleteFCMRegistration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("fcmRegistrationId", Elements.Client.ClientUtils.ParameterToString(fcmRegistrationId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/notification/fcm/{fcmRegistrationId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteFCMRegistration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a Facebook ApplicationConfiguration Deletes an existing Facebook Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns></returns>
        public void DeleteFacebookApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId)
        {
            DeleteFacebookApplicationConfigurationWithHttpInfo(applicationNameOrId, applicationConfigurationNameOrId);
        }

        /// <summary>
        /// Deletes a Facebook ApplicationConfiguration Deletes an existing Facebook Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteFacebookApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId)
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->DeleteFacebookApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->DeleteFacebookApplicationConfiguration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/application/{applicationNameOrId}/configuration/facebook/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteFacebookApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a Facebook ApplicationConfiguration Deletes an existing Facebook Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteFacebookApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteFacebookApplicationConfigurationWithHttpInfoAsync(applicationNameOrId, applicationConfigurationNameOrId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes a Facebook ApplicationConfiguration Deletes an existing Facebook Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteFacebookApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->DeleteFacebookApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->DeleteFacebookApplicationConfiguration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/application/{applicationNameOrId}/configuration/facebook/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteFacebookApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a Firebase ApplicationConfiguration Deletes an existing Firebase Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns></returns>
        public void DeleteFirebaseApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId)
        {
            DeleteFirebaseApplicationConfigurationWithHttpInfo(applicationNameOrId, applicationConfigurationNameOrId);
        }

        /// <summary>
        /// Deletes a Firebase ApplicationConfiguration Deletes an existing Firebase Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteFirebaseApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId)
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->DeleteFirebaseApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->DeleteFirebaseApplicationConfiguration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/application/{applicationNameOrId}/configuration/firebase/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteFirebaseApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a Firebase ApplicationConfiguration Deletes an existing Firebase Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteFirebaseApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteFirebaseApplicationConfigurationWithHttpInfoAsync(applicationNameOrId, applicationConfigurationNameOrId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes a Firebase ApplicationConfiguration Deletes an existing Firebase Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteFirebaseApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->DeleteFirebaseApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->DeleteFirebaseApplicationConfiguration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/application/{applicationNameOrId}/configuration/firebase/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteFirebaseApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a Follower relationship 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="profileToUnfollowId"></param>
        /// <returns></returns>
        public void DeleteFollower(string profileId, string profileToUnfollowId)
        {
            DeleteFollowerWithHttpInfo(profileId, profileToUnfollowId);
        }

        /// <summary>
        /// Deletes a Follower relationship 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="profileToUnfollowId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteFollowerWithHttpInfo(string profileId, string profileToUnfollowId)
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'profileId' when calling DefaultApi->DeleteFollower");

            // verify the required parameter 'profileToUnfollowId' is set
            if (profileToUnfollowId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'profileToUnfollowId' when calling DefaultApi->DeleteFollower");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("profileId", Elements.Client.ClientUtils.ParameterToString(profileId)); // path parameter
            localVarRequestOptions.PathParameters.Add("profileToUnfollowId", Elements.Client.ClientUtils.ParameterToString(profileToUnfollowId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/follower/{profileId}/{profileToUnfollowId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteFollower", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a Follower relationship 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="profileToUnfollowId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteFollowerAsync(string profileId, string profileToUnfollowId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteFollowerWithHttpInfoAsync(profileId, profileToUnfollowId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes a Follower relationship 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="profileToUnfollowId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteFollowerWithHttpInfoAsync(string profileId, string profileToUnfollowId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'profileId' when calling DefaultApi->DeleteFollower");

            // verify the required parameter 'profileToUnfollowId' is set
            if (profileToUnfollowId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'profileToUnfollowId' when calling DefaultApi->DeleteFollower");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("profileId", Elements.Client.ClientUtils.ParameterToString(profileId)); // path parameter
            localVarRequestOptions.PathParameters.Add("profileToUnfollowId", Elements.Client.ClientUtils.ParameterToString(profileToUnfollowId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/follower/{profileId}/{profileToUnfollowId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteFollower", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a Friend Once a friend is deleted, re-creating a friend will set the friendship status to outgoing.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="friendId"></param>
        /// <returns></returns>
        public void DeleteFriendRegistration(string friendId)
        {
            DeleteFriendRegistrationWithHttpInfo(friendId);
        }

        /// <summary>
        /// Deletes a Friend Once a friend is deleted, re-creating a friend will set the friendship status to outgoing.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="friendId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteFriendRegistrationWithHttpInfo(string friendId)
        {
            // verify the required parameter 'friendId' is set
            if (friendId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'friendId' when calling DefaultApi->DeleteFriendRegistration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("friendId", Elements.Client.ClientUtils.ParameterToString(friendId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/friend/{friendId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteFriendRegistration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a Friend Once a friend is deleted, re-creating a friend will set the friendship status to outgoing.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="friendId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteFriendRegistrationAsync(string friendId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteFriendRegistrationWithHttpInfoAsync(friendId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes a Friend Once a friend is deleted, re-creating a friend will set the friendship status to outgoing.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="friendId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteFriendRegistrationWithHttpInfoAsync(string friendId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'friendId' is set
            if (friendId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'friendId' when calling DefaultApi->DeleteFriendRegistration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("friendId", Elements.Client.ClientUtils.ParameterToString(friendId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/friend/{friendId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteFriendRegistration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a Google Play ApplicationConfiguration Deletes an existing Google Play Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns></returns>
        public void DeleteGooglePlayApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId)
        {
            DeleteGooglePlayApplicationConfigurationWithHttpInfo(applicationNameOrId, applicationConfigurationNameOrId);
        }

        /// <summary>
        /// Deletes a Google Play ApplicationConfiguration Deletes an existing Google Play Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteGooglePlayApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId)
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->DeleteGooglePlayApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->DeleteGooglePlayApplicationConfiguration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/application/{applicationNameOrId}/configuration/google_play/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteGooglePlayApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a Google Play ApplicationConfiguration Deletes an existing Google Play Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteGooglePlayApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteGooglePlayApplicationConfigurationWithHttpInfoAsync(applicationNameOrId, applicationConfigurationNameOrId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes a Google Play ApplicationConfiguration Deletes an existing Google Play Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteGooglePlayApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->DeleteGooglePlayApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->DeleteGooglePlayApplicationConfiguration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/application/{applicationNameOrId}/configuration/google_play/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteGooglePlayApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a iOS ApplicationConfiguration Deletes an existing iOS Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns></returns>
        public void DeleteIosApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId)
        {
            DeleteIosApplicationConfigurationWithHttpInfo(applicationNameOrId, applicationConfigurationNameOrId);
        }

        /// <summary>
        /// Deletes a iOS ApplicationConfiguration Deletes an existing iOS Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteIosApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId)
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->DeleteIosApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->DeleteIosApplicationConfiguration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/application/{applicationNameOrId}/configuration/ios/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteIosApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a iOS ApplicationConfiguration Deletes an existing iOS Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteIosApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteIosApplicationConfigurationWithHttpInfoAsync(applicationNameOrId, applicationConfigurationNameOrId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes a iOS ApplicationConfiguration Deletes an existing iOS Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteIosApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->DeleteIosApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->DeleteIosApplicationConfiguration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/application/{applicationNameOrId}/configuration/ios/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteIosApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a LargeObject 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <returns></returns>
        public void DeleteLargeObject(string largeObjectId)
        {
            DeleteLargeObjectWithHttpInfo(largeObjectId);
        }

        /// <summary>
        /// Deletes a LargeObject 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteLargeObjectWithHttpInfo(string largeObjectId)
        {
            // verify the required parameter 'largeObjectId' is set
            if (largeObjectId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'largeObjectId' when calling DefaultApi->DeleteLargeObject");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("largeObjectId", Elements.Client.ClientUtils.ParameterToString(largeObjectId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/large_object/{largeObjectId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteLargeObject", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a LargeObject 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteLargeObjectAsync(string largeObjectId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteLargeObjectWithHttpInfoAsync(largeObjectId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes a LargeObject 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteLargeObjectWithHttpInfoAsync(string largeObjectId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'largeObjectId' is set
            if (largeObjectId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'largeObjectId' when calling DefaultApi->DeleteLargeObject");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("largeObjectId", Elements.Client.ClientUtils.ParameterToString(largeObjectId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/large_object/{largeObjectId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteLargeObject", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes an Leaderboard Deletes a specific leaderboard known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <returns></returns>
        public void DeleteLeaderboard(string nameOrId)
        {
            DeleteLeaderboardWithHttpInfo(nameOrId);
        }

        /// <summary>
        /// Deletes an Leaderboard Deletes a specific leaderboard known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteLeaderboardWithHttpInfo(string nameOrId)
        {
            // verify the required parameter 'nameOrId' is set
            if (nameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'nameOrId' when calling DefaultApi->DeleteLeaderboard");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*",
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("nameOrId", Elements.Client.ClientUtils.ParameterToString(nameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/leaderboard/{nameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteLeaderboard", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes an Leaderboard Deletes a specific leaderboard known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteLeaderboardAsync(string nameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteLeaderboardWithHttpInfoAsync(nameOrId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes an Leaderboard Deletes a specific leaderboard known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteLeaderboardWithHttpInfoAsync(string nameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'nameOrId' is set
            if (nameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'nameOrId' when calling DefaultApi->DeleteLeaderboard");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*",
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("nameOrId", Elements.Client.ClientUtils.ParameterToString(nameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/leaderboard/{nameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteLeaderboard", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a Match Deletes and permanently removes the Match fromt he server.  This effectively will cancel any pending request for a match.  If a game is currently being played agaist the match, the server may reject the request to delete the match until the game concludes.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchId"></param>
        /// <returns></returns>
        public void DeleteMatch(string matchId)
        {
            DeleteMatchWithHttpInfo(matchId);
        }

        /// <summary>
        /// Deletes a Match Deletes and permanently removes the Match fromt he server.  This effectively will cancel any pending request for a match.  If a game is currently being played agaist the match, the server may reject the request to delete the match until the game concludes.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteMatchWithHttpInfo(string matchId)
        {
            // verify the required parameter 'matchId' is set
            if (matchId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'matchId' when calling DefaultApi->DeleteMatch");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("matchId", Elements.Client.ClientUtils.ParameterToString(matchId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/match/{matchId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteMatch", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a Match Deletes and permanently removes the Match fromt he server.  This effectively will cancel any pending request for a match.  If a game is currently being played agaist the match, the server may reject the request to delete the match until the game concludes.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteMatchAsync(string matchId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteMatchWithHttpInfoAsync(matchId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes a Match Deletes and permanently removes the Match fromt he server.  This effectively will cancel any pending request for a match.  If a game is currently being played agaist the match, the server may reject the request to delete the match until the game concludes.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteMatchWithHttpInfoAsync(string matchId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'matchId' is set
            if (matchId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'matchId' when calling DefaultApi->DeleteMatch");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("matchId", Elements.Client.ClientUtils.ParameterToString(matchId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/match/{matchId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteMatch", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a iOS ApplicationConfiguration Deletes an existing iOS Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns></returns>
        public void DeleteMatchmakingApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId)
        {
            DeleteMatchmakingApplicationConfigurationWithHttpInfo(applicationNameOrId, applicationConfigurationNameOrId);
        }

        /// <summary>
        /// Deletes a iOS ApplicationConfiguration Deletes an existing iOS Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteMatchmakingApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId)
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->DeleteMatchmakingApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->DeleteMatchmakingApplicationConfiguration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/application/{applicationNameOrId}/configuration/matchmaking/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteMatchmakingApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a iOS ApplicationConfiguration Deletes an existing iOS Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteMatchmakingApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteMatchmakingApplicationConfigurationWithHttpInfoAsync(applicationNameOrId, applicationConfigurationNameOrId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes a iOS ApplicationConfiguration Deletes an existing iOS Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteMatchmakingApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->DeleteMatchmakingApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->DeleteMatchmakingApplicationConfiguration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/application/{applicationNameOrId}/configuration/matchmaking/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteMatchmakingApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a specific Metadata object Deletes a specific metadata object by name or id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns></returns>
        public void DeleteMetadata(string id)
        {
            DeleteMetadataWithHttpInfo(id);
        }

        /// <summary>
        /// Deletes a specific Metadata object Deletes a specific metadata object by name or id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteMetadataWithHttpInfo(string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'id' when calling DefaultApi->DeleteMetadata");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Elements.Client.ClientUtils.ParameterToString(id)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/metadata/{id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteMetadata", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a specific Metadata object Deletes a specific metadata object by name or id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteMetadataAsync(string id, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteMetadataWithHttpInfoAsync(id, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes a specific Metadata object Deletes a specific metadata object by name or id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteMetadataWithHttpInfoAsync(string id, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'id' when calling DefaultApi->DeleteMetadata");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Elements.Client.ClientUtils.ParameterToString(id)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/metadata/{id}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteMetadata", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a MetadataSpec Deletes a MetadataSpec with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecId"></param>
        /// <returns></returns>
        public void DeleteMetadataSpec(string metadataSpecId)
        {
            DeleteMetadataSpecWithHttpInfo(metadataSpecId);
        }

        /// <summary>
        /// Deletes a MetadataSpec Deletes a MetadataSpec with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteMetadataSpecWithHttpInfo(string metadataSpecId)
        {
            // verify the required parameter 'metadataSpecId' is set
            if (metadataSpecId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'metadataSpecId' when calling DefaultApi->DeleteMetadataSpec");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("metadataSpecId", Elements.Client.ClientUtils.ParameterToString(metadataSpecId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/metadata_spec/{metadataSpecId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteMetadataSpec", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a MetadataSpec Deletes a MetadataSpec with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteMetadataSpecAsync(string metadataSpecId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteMetadataSpecWithHttpInfoAsync(metadataSpecId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes a MetadataSpec Deletes a MetadataSpec with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteMetadataSpecWithHttpInfoAsync(string metadataSpecId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'metadataSpecId' is set
            if (metadataSpecId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'metadataSpecId' when calling DefaultApi->DeleteMetadataSpec");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("metadataSpecId", Elements.Client.ClientUtils.ParameterToString(metadataSpecId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/metadata_spec/{metadataSpecId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteMetadataSpec", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes the Mission identified by id or by name Deletes a mission by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="missionNameOrId"></param>
        /// <returns></returns>
        public void DeleteMission(string missionNameOrId)
        {
            DeleteMissionWithHttpInfo(missionNameOrId);
        }

        /// <summary>
        /// Deletes the Mission identified by id or by name Deletes a mission by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="missionNameOrId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteMissionWithHttpInfo(string missionNameOrId)
        {
            // verify the required parameter 'missionNameOrId' is set
            if (missionNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'missionNameOrId' when calling DefaultApi->DeleteMission");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("missionNameOrId", Elements.Client.ClientUtils.ParameterToString(missionNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/mission/{missionNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteMission", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes the Mission identified by id or by name Deletes a mission by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="missionNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteMissionAsync(string missionNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteMissionWithHttpInfoAsync(missionNameOrId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes the Mission identified by id or by name Deletes a mission by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="missionNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteMissionWithHttpInfoAsync(string missionNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'missionNameOrId' is set
            if (missionNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'missionNameOrId' when calling DefaultApi->DeleteMission");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("missionNameOrId", Elements.Client.ClientUtils.ParameterToString(missionNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/mission/{missionNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteMission", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a PSN ApplicationConfiguration Deletes an existing PSN Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns></returns>
        public void DeletePSNApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId)
        {
            DeletePSNApplicationConfigurationWithHttpInfo(applicationNameOrId, applicationConfigurationNameOrId);
        }

        /// <summary>
        /// Deletes a PSN ApplicationConfiguration Deletes an existing PSN Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeletePSNApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId)
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->DeletePSNApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->DeletePSNApplicationConfiguration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/application/{applicationNameOrId}/configuration/psn/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeletePSNApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a PSN ApplicationConfiguration Deletes an existing PSN Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeletePSNApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeletePSNApplicationConfigurationWithHttpInfoAsync(applicationNameOrId, applicationConfigurationNameOrId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes a PSN ApplicationConfiguration Deletes an existing PSN Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeletePSNApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->DeletePSNApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->DeletePSNApplicationConfiguration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/application/{applicationNameOrId}/configuration/psn/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeletePSNApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes the Progress identified by id Deletes a progress by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progressId"></param>
        /// <returns></returns>
        public void DeleteProgress(string progressId)
        {
            DeleteProgressWithHttpInfo(progressId);
        }

        /// <summary>
        /// Deletes the Progress identified by id Deletes a progress by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progressId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteProgressWithHttpInfo(string progressId)
        {
            // verify the required parameter 'progressId' is set
            if (progressId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'progressId' when calling DefaultApi->DeleteProgress");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("progressId", Elements.Client.ClientUtils.ParameterToString(progressId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/progress/progress/{progressId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteProgress", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes the Progress identified by id Deletes a progress by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progressId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteProgressAsync(string progressId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteProgressWithHttpInfoAsync(progressId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes the Progress identified by id Deletes a progress by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progressId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteProgressWithHttpInfoAsync(string progressId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'progressId' is set
            if (progressId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'progressId' when calling DefaultApi->DeleteProgress");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("progressId", Elements.Client.ClientUtils.ParameterToString(progressId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/progress/progress/{progressId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteProgress", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a save data document 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="saveDataDocumentId"></param>
        /// <returns></returns>
        public void DeleteSaveDocument(string saveDataDocumentId)
        {
            DeleteSaveDocumentWithHttpInfo(saveDataDocumentId);
        }

        /// <summary>
        /// Deletes a save data document 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="saveDataDocumentId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteSaveDocumentWithHttpInfo(string saveDataDocumentId)
        {
            // verify the required parameter 'saveDataDocumentId' is set
            if (saveDataDocumentId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'saveDataDocumentId' when calling DefaultApi->DeleteSaveDocument");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*",
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("saveDataDocumentId", Elements.Client.ClientUtils.ParameterToString(saveDataDocumentId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/save_data/{saveDataDocumentId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteSaveDocument", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a save data document 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="saveDataDocumentId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteSaveDocumentAsync(string saveDataDocumentId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteSaveDocumentWithHttpInfoAsync(saveDataDocumentId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes a save data document 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="saveDataDocumentId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteSaveDocumentWithHttpInfoAsync(string saveDataDocumentId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'saveDataDocumentId' is set
            if (saveDataDocumentId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'saveDataDocumentId' when calling DefaultApi->DeleteSaveDocument");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*",
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("saveDataDocumentId", Elements.Client.ClientUtils.ParameterToString(saveDataDocumentId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/save_data/{saveDataDocumentId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteSaveDocument", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes the Schedule identified by id or by name Deletes a schedule by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <returns></returns>
        public void DeleteSchedule(string scheduleNameOrId)
        {
            DeleteScheduleWithHttpInfo(scheduleNameOrId);
        }

        /// <summary>
        /// Deletes the Schedule identified by id or by name Deletes a schedule by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteScheduleWithHttpInfo(string scheduleNameOrId)
        {
            // verify the required parameter 'scheduleNameOrId' is set
            if (scheduleNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'scheduleNameOrId' when calling DefaultApi->DeleteSchedule");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("scheduleNameOrId", Elements.Client.ClientUtils.ParameterToString(scheduleNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/schedule/{scheduleNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteSchedule", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes the Schedule identified by id or by name Deletes a schedule by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteScheduleAsync(string scheduleNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteScheduleWithHttpInfoAsync(scheduleNameOrId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes the Schedule identified by id or by name Deletes a schedule by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteScheduleWithHttpInfoAsync(string scheduleNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'scheduleNameOrId' is set
            if (scheduleNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'scheduleNameOrId' when calling DefaultApi->DeleteSchedule");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("scheduleNameOrId", Elements.Client.ClientUtils.ParameterToString(scheduleNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/schedule/{scheduleNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteSchedule", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes the ScheduleEvent identified by id or by name Deletes a schedule by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="scheduleEventId"></param>
        /// <returns></returns>
        public void DeleteScheduleEvent(string scheduleNameOrId, string scheduleEventId)
        {
            DeleteScheduleEventWithHttpInfo(scheduleNameOrId, scheduleEventId);
        }

        /// <summary>
        /// Deletes the ScheduleEvent identified by id or by name Deletes a schedule by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="scheduleEventId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteScheduleEventWithHttpInfo(string scheduleNameOrId, string scheduleEventId)
        {
            // verify the required parameter 'scheduleNameOrId' is set
            if (scheduleNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'scheduleNameOrId' when calling DefaultApi->DeleteScheduleEvent");

            // verify the required parameter 'scheduleEventId' is set
            if (scheduleEventId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'scheduleEventId' when calling DefaultApi->DeleteScheduleEvent");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("scheduleNameOrId", Elements.Client.ClientUtils.ParameterToString(scheduleNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("scheduleEventId", Elements.Client.ClientUtils.ParameterToString(scheduleEventId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/schedule/{scheduleNameOrId}/event/{scheduleEventId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteScheduleEvent", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes the ScheduleEvent identified by id or by name Deletes a schedule by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="scheduleEventId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteScheduleEventAsync(string scheduleNameOrId, string scheduleEventId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteScheduleEventWithHttpInfoAsync(scheduleNameOrId, scheduleEventId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes the ScheduleEvent identified by id or by name Deletes a schedule by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="scheduleEventId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteScheduleEventWithHttpInfoAsync(string scheduleNameOrId, string scheduleEventId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'scheduleNameOrId' is set
            if (scheduleNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'scheduleNameOrId' when calling DefaultApi->DeleteScheduleEvent");

            // verify the required parameter 'scheduleEventId' is set
            if (scheduleEventId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'scheduleEventId' when calling DefaultApi->DeleteScheduleEvent");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("scheduleNameOrId", Elements.Client.ClientUtils.ParameterToString(scheduleNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("scheduleEventId", Elements.Client.ClientUtils.ParameterToString(scheduleEventId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/schedule/{scheduleNameOrId}/event/{scheduleEventId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteScheduleEvent", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete the inventory item as identified by the given item name/id Delete the inventory item as identified by the given item name/id
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <returns></returns>
        public void DeleteSimpleInventoryItem(string inventoryItemId)
        {
            DeleteSimpleInventoryItemWithHttpInfo(inventoryItemId);
        }

        /// <summary>
        /// Delete the inventory item as identified by the given item name/id Delete the inventory item as identified by the given item name/id
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteSimpleInventoryItemWithHttpInfo(string inventoryItemId)
        {
            // verify the required parameter 'inventoryItemId' is set
            if (inventoryItemId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'inventoryItemId' when calling DefaultApi->DeleteSimpleInventoryItem");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("inventoryItemId", Elements.Client.ClientUtils.ParameterToString(inventoryItemId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/inventory/simple/{inventoryItemId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteSimpleInventoryItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete the inventory item as identified by the given item name/id Delete the inventory item as identified by the given item name/id
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteSimpleInventoryItemAsync(string inventoryItemId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteSimpleInventoryItemWithHttpInfoAsync(inventoryItemId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Delete the inventory item as identified by the given item name/id Delete the inventory item as identified by the given item name/id
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteSimpleInventoryItemWithHttpInfoAsync(string inventoryItemId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'inventoryItemId' is set
            if (inventoryItemId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'inventoryItemId' when calling DefaultApi->DeleteSimpleInventoryItem");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("inventoryItemId", Elements.Client.ClientUtils.ParameterToString(inventoryItemId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/inventory/simple/{inventoryItemId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteSimpleInventoryItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a  Vault Deletes a  Vault with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <returns></returns>
        public void DeleteVault(string vaultId)
        {
            DeleteVaultWithHttpInfo(vaultId);
        }

        /// <summary>
        /// Deletes a  Vault Deletes a  Vault with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteVaultWithHttpInfo(string vaultId)
        {
            // verify the required parameter 'vaultId' is set
            if (vaultId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'vaultId' when calling DefaultApi->DeleteVault");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("vaultId", Elements.Client.ClientUtils.ParameterToString(vaultId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/blockchain/omni/vault/{vaultId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteVault", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a  Vault Deletes a  Vault with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteVaultAsync(string vaultId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteVaultWithHttpInfoAsync(vaultId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes a  Vault Deletes a  Vault with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteVaultWithHttpInfoAsync(string vaultId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'vaultId' is set
            if (vaultId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'vaultId' when calling DefaultApi->DeleteVault");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("vaultId", Elements.Client.ClientUtils.ParameterToString(vaultId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/blockchain/omni/vault/{vaultId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteVault", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a  Wallet Deletes a  Wallet with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="walletId"></param>
        /// <returns></returns>
        public void DeleteWallet(string vaultId, string walletId)
        {
            DeleteWalletWithHttpInfo(vaultId, walletId);
        }

        /// <summary>
        /// Deletes a  Wallet Deletes a  Wallet with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="walletId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> DeleteWalletWithHttpInfo(string vaultId, string walletId)
        {
            // verify the required parameter 'vaultId' is set
            if (vaultId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'vaultId' when calling DefaultApi->DeleteWallet");

            // verify the required parameter 'walletId' is set
            if (walletId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'walletId' when calling DefaultApi->DeleteWallet");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("vaultId", Elements.Client.ClientUtils.ParameterToString(vaultId)); // path parameter
            localVarRequestOptions.PathParameters.Add("walletId", Elements.Client.ClientUtils.ParameterToString(walletId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/blockchain/omni/vault/{vaultId}/wallet/{walletId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteWallet", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes a  Wallet Deletes a  Wallet with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="walletId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteWalletAsync(string vaultId, string walletId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = DeleteWalletWithHttpInfoAsync(vaultId, walletId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Deletes a  Wallet Deletes a  Wallet with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="walletId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> DeleteWalletWithHttpInfoAsync(string vaultId, string walletId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'vaultId' is set
            if (vaultId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'vaultId' when calling DefaultApi->DeleteWallet");

            // verify the required parameter 'walletId' is set
            if (walletId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'walletId' when calling DefaultApi->DeleteWallet");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("vaultId", Elements.Client.ClientUtils.ParameterToString(vaultId)); // path parameter
            localVarRequestOptions.PathParameters.Add("walletId", Elements.Client.ClientUtils.ParameterToString(walletId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.DeleteAsync<Object>("/blockchain/omni/vault/{vaultId}/wallet/{walletId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteWallet", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Generate Client API Code Generates API code for use on the client. Will generate Elements core if no application is specified in the request body.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="codegenRequest"> (optional)</param>
        /// <returns></returns>
        public void GenerateCode(CodegenRequest codegenRequest = default(CodegenRequest))
        {
            GenerateCodeWithHttpInfo(codegenRequest);
        }

        /// <summary>
        /// Generate Client API Code Generates API code for use on the client. Will generate Elements core if no application is specified in the request body.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="codegenRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Elements.Client.ApiResponse<Object> GenerateCodeWithHttpInfo(CodegenRequest codegenRequest = default(CodegenRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/octet-stream",
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = codegenRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/codegen", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GenerateCode", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Generate Client API Code Generates API code for use on the client. Will generate Elements core if no application is specified in the request body.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="codegenRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task GenerateCodeAsync(CodegenRequest codegenRequest = default(CodegenRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GenerateCodeWithHttpInfoAsync(codegenRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            await task.ConfigureAwait(false);
#else
            await task;
#endif
        }

        /// <summary>
        /// Generate Client API Code Generates API code for use on the client. Will generate Elements core if no application is specified in the request body.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="codegenRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Object>> GenerateCodeWithHttpInfoAsync(CodegenRequest codegenRequest = default(CodegenRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/octet-stream",
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = codegenRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<Object>("/codegen", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GenerateCode", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets inventory item for the specified item Gets the first (primary) inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <returns>InventoryItem</returns>
        public InventoryItem GetAdvancedInventoryItem(string inventoryItemId)
        {
            Elements.Client.ApiResponse<InventoryItem> localVarResponse = GetAdvancedInventoryItemWithHttpInfo(inventoryItemId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets inventory item for the specified item Gets the first (primary) inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <returns>ApiResponse of InventoryItem</returns>
        public Elements.Client.ApiResponse<InventoryItem> GetAdvancedInventoryItemWithHttpInfo(string inventoryItemId)
        {
            // verify the required parameter 'inventoryItemId' is set
            if (inventoryItemId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'inventoryItemId' when calling DefaultApi->GetAdvancedInventoryItem");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("inventoryItemId", Elements.Client.ClientUtils.ParameterToString(inventoryItemId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<InventoryItem>("/inventory/advanced/{inventoryItemId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAdvancedInventoryItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets inventory item for the specified item Gets the first (primary) inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InventoryItem</returns>
        public async System.Threading.Tasks.Task<InventoryItem> GetAdvancedInventoryItemAsync(string inventoryItemId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetAdvancedInventoryItemWithHttpInfoAsync(inventoryItemId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<InventoryItem> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<InventoryItem> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets inventory item for the specified item Gets the first (primary) inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InventoryItem)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<InventoryItem>> GetAdvancedInventoryItemWithHttpInfoAsync(string inventoryItemId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'inventoryItemId' is set
            if (inventoryItemId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'inventoryItemId' when calling DefaultApi->GetAdvancedInventoryItem");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("inventoryItemId", Elements.Client.ClientUtils.ParameterToString(inventoryItemId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<InventoryItem>("/inventory/advanced/{inventoryItemId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAdvancedInventoryItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search inventory items Searches all inventory items in the system and returns the metadata for all matches against the given search filter.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationInventoryItem</returns>
        public PaginationInventoryItem GetAdvancedInventoryItems(int? offset = default(int?), int? count = default(int?), string userId = default(string), string search = default(string))
        {
            Elements.Client.ApiResponse<PaginationInventoryItem> localVarResponse = GetAdvancedInventoryItemsWithHttpInfo(offset, count, userId, search);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search inventory items Searches all inventory items in the system and returns the metadata for all matches against the given search filter.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationInventoryItem</returns>
        public Elements.Client.ApiResponse<PaginationInventoryItem> GetAdvancedInventoryItemsWithHttpInfo(int? offset = default(int?), int? count = default(int?), string userId = default(string), string search = default(string))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (userId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "userId", userId));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationInventoryItem>("/inventory/advanced", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAdvancedInventoryItems", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search inventory items Searches all inventory items in the system and returns the metadata for all matches against the given search filter.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationInventoryItem</returns>
        public async System.Threading.Tasks.Task<PaginationInventoryItem> GetAdvancedInventoryItemsAsync(int? offset = default(int?), int? count = default(int?), string userId = default(string), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetAdvancedInventoryItemsWithHttpInfoAsync(offset, count, userId, search, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationInventoryItem> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationInventoryItem> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search inventory items Searches all inventory items in the system and returns the metadata for all matches against the given search filter.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationInventoryItem)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationInventoryItem>> GetAdvancedInventoryItemsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), string userId = default(string), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (userId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "userId", userId));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationInventoryItem>("/inventory/advanced", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAdvancedInventoryItems", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get an Application Gets the metadata for a single application.  This may include more specific details not available in the bulk-get or fetch operation.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <returns>Application</returns>
        public Application GetApplication(string nameOrId)
        {
            Elements.Client.ApiResponse<Application> localVarResponse = GetApplicationWithHttpInfo(nameOrId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get an Application Gets the metadata for a single application.  This may include more specific details not available in the bulk-get or fetch operation.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <returns>ApiResponse of Application</returns>
        public Elements.Client.ApiResponse<Application> GetApplicationWithHttpInfo(string nameOrId)
        {
            // verify the required parameter 'nameOrId' is set
            if (nameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'nameOrId' when calling DefaultApi->GetApplication");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("nameOrId", Elements.Client.ClientUtils.ParameterToString(nameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Application>("/application/{nameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetApplication", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get an Application Gets the metadata for a single application.  This may include more specific details not available in the bulk-get or fetch operation.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Application</returns>
        public async System.Threading.Tasks.Task<Application> GetApplicationAsync(string nameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetApplicationWithHttpInfoAsync(nameOrId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Application> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Application> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get an Application Gets the metadata for a single application.  This may include more specific details not available in the bulk-get or fetch operation.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Application)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Application>> GetApplicationWithHttpInfoAsync(string nameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'nameOrId' is set
            if (nameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'nameOrId' when calling DefaultApi->GetApplication");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("nameOrId", Elements.Client.ClientUtils.ParameterToString(nameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<Application>("/application/{nameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetApplication", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Searches application profiles Searches all instances of ApplicationProfiles associated with  the application.  The search query may be a full text search.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationApplicationConfiguration</returns>
        public PaginationApplicationConfiguration GetApplicationProfiles(string applicationNameOrId, int? offset = default(int?), int? count = default(int?), string search = default(string))
        {
            Elements.Client.ApiResponse<PaginationApplicationConfiguration> localVarResponse = GetApplicationProfilesWithHttpInfo(applicationNameOrId, offset, count, search);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Searches application profiles Searches all instances of ApplicationProfiles associated with  the application.  The search query may be a full text search.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationApplicationConfiguration</returns>
        public Elements.Client.ApiResponse<PaginationApplicationConfiguration> GetApplicationProfilesWithHttpInfo(string applicationNameOrId, int? offset = default(int?), int? count = default(int?), string search = default(string))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->GetApplicationProfiles");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationApplicationConfiguration>("/application/{applicationNameOrId}/configuration", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetApplicationProfiles", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Searches application profiles Searches all instances of ApplicationProfiles associated with  the application.  The search query may be a full text search.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationApplicationConfiguration</returns>
        public async System.Threading.Tasks.Task<PaginationApplicationConfiguration> GetApplicationProfilesAsync(string applicationNameOrId, int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetApplicationProfilesWithHttpInfoAsync(applicationNameOrId, offset, count, search, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationApplicationConfiguration> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationApplicationConfiguration> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Searches application profiles Searches all instances of ApplicationProfiles associated with  the application.  The search query may be a full text search.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationApplicationConfiguration)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationApplicationConfiguration>> GetApplicationProfilesWithHttpInfoAsync(string applicationNameOrId, int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->GetApplicationProfiles");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationApplicationConfiguration>("/application/{applicationNameOrId}/configuration", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetApplicationProfiles", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search Applications Performs a full-text search of all applications known to the server.  As with other full-text endpoints this allows for pagination and offset.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationApplication</returns>
        public PaginationApplication GetApplications(int? offset = default(int?), int? count = default(int?), string search = default(string))
        {
            Elements.Client.ApiResponse<PaginationApplication> localVarResponse = GetApplicationsWithHttpInfo(offset, count, search);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search Applications Performs a full-text search of all applications known to the server.  As with other full-text endpoints this allows for pagination and offset.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationApplication</returns>
        public Elements.Client.ApiResponse<PaginationApplication> GetApplicationsWithHttpInfo(int? offset = default(int?), int? count = default(int?), string search = default(string))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationApplication>("/application", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetApplications", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search Applications Performs a full-text search of all applications known to the server.  As with other full-text endpoints this allows for pagination and offset.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationApplication</returns>
        public async System.Threading.Tasks.Task<PaginationApplication> GetApplicationsAsync(int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetApplicationsWithHttpInfoAsync(offset, count, search, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationApplication> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationApplication> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search Applications Performs a full-text search of all applications known to the server.  As with other full-text endpoints this allows for pagination and offset.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationApplication)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationApplication>> GetApplicationsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationApplication>("/application", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetApplications", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a specific Auth Scheme Gets a specific Auth Scheme by the authSchemeId.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSchemeId"></param>
        /// <returns>AuthScheme</returns>
        public AuthScheme GetAuthScheme(string authSchemeId)
        {
            Elements.Client.ApiResponse<AuthScheme> localVarResponse = GetAuthSchemeWithHttpInfo(authSchemeId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a specific Auth Scheme Gets a specific Auth Scheme by the authSchemeId.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSchemeId"></param>
        /// <returns>ApiResponse of AuthScheme</returns>
        public Elements.Client.ApiResponse<AuthScheme> GetAuthSchemeWithHttpInfo(string authSchemeId)
        {
            // verify the required parameter 'authSchemeId' is set
            if (authSchemeId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'authSchemeId' when calling DefaultApi->GetAuthScheme");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("authSchemeId", Elements.Client.ClientUtils.ParameterToString(authSchemeId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<AuthScheme>("/auth_scheme/custom/{authSchemeId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAuthScheme", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a specific Auth Scheme Gets a specific Auth Scheme by the authSchemeId.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSchemeId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of AuthScheme</returns>
        public async System.Threading.Tasks.Task<AuthScheme> GetAuthSchemeAsync(string authSchemeId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetAuthSchemeWithHttpInfoAsync(authSchemeId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<AuthScheme> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<AuthScheme> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a specific Auth Scheme Gets a specific Auth Scheme by the authSchemeId.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSchemeId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (AuthScheme)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<AuthScheme>> GetAuthSchemeWithHttpInfoAsync(string authSchemeId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'authSchemeId' is set
            if (authSchemeId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'authSchemeId' when calling DefaultApi->GetAuthScheme");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("authSchemeId", Elements.Client.ClientUtils.ParameterToString(authSchemeId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<AuthScheme>("/auth_scheme/custom/{authSchemeId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAuthScheme", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a specific Auth Scheme Gets a specific Auth Scheme by the oAuth2AuthSchemeId.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2AuthSchemeId"></param>
        /// <returns>OAuth2AuthScheme</returns>
        public OAuth2AuthScheme GetAuthScheme1(string oAuth2AuthSchemeId)
        {
            Elements.Client.ApiResponse<OAuth2AuthScheme> localVarResponse = GetAuthScheme1WithHttpInfo(oAuth2AuthSchemeId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a specific Auth Scheme Gets a specific Auth Scheme by the oAuth2AuthSchemeId.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2AuthSchemeId"></param>
        /// <returns>ApiResponse of OAuth2AuthScheme</returns>
        public Elements.Client.ApiResponse<OAuth2AuthScheme> GetAuthScheme1WithHttpInfo(string oAuth2AuthSchemeId)
        {
            // verify the required parameter 'oAuth2AuthSchemeId' is set
            if (oAuth2AuthSchemeId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'oAuth2AuthSchemeId' when calling DefaultApi->GetAuthScheme1");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("oAuth2AuthSchemeId", Elements.Client.ClientUtils.ParameterToString(oAuth2AuthSchemeId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<OAuth2AuthScheme>("/auth_scheme/oauth2/{oAuth2AuthSchemeId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAuthScheme1", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a specific Auth Scheme Gets a specific Auth Scheme by the oAuth2AuthSchemeId.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2AuthSchemeId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of OAuth2AuthScheme</returns>
        public async System.Threading.Tasks.Task<OAuth2AuthScheme> GetAuthScheme1Async(string oAuth2AuthSchemeId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetAuthScheme1WithHttpInfoAsync(oAuth2AuthSchemeId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<OAuth2AuthScheme> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<OAuth2AuthScheme> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a specific Auth Scheme Gets a specific Auth Scheme by the oAuth2AuthSchemeId.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2AuthSchemeId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (OAuth2AuthScheme)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<OAuth2AuthScheme>> GetAuthScheme1WithHttpInfoAsync(string oAuth2AuthSchemeId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'oAuth2AuthSchemeId' is set
            if (oAuth2AuthSchemeId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'oAuth2AuthSchemeId' when calling DefaultApi->GetAuthScheme1");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("oAuth2AuthSchemeId", Elements.Client.ClientUtils.ParameterToString(oAuth2AuthSchemeId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<OAuth2AuthScheme>("/auth_scheme/oauth2/{oAuth2AuthSchemeId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAuthScheme1", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a specific Auth Scheme Gets a specific Auth Scheme by the oidcAuthSchemeId.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcAuthSchemeId"></param>
        /// <returns>OidcAuthScheme</returns>
        public OidcAuthScheme GetAuthScheme2(string oidcAuthSchemeId)
        {
            Elements.Client.ApiResponse<OidcAuthScheme> localVarResponse = GetAuthScheme2WithHttpInfo(oidcAuthSchemeId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a specific Auth Scheme Gets a specific Auth Scheme by the oidcAuthSchemeId.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcAuthSchemeId"></param>
        /// <returns>ApiResponse of OidcAuthScheme</returns>
        public Elements.Client.ApiResponse<OidcAuthScheme> GetAuthScheme2WithHttpInfo(string oidcAuthSchemeId)
        {
            // verify the required parameter 'oidcAuthSchemeId' is set
            if (oidcAuthSchemeId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'oidcAuthSchemeId' when calling DefaultApi->GetAuthScheme2");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("oidcAuthSchemeId", Elements.Client.ClientUtils.ParameterToString(oidcAuthSchemeId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<OidcAuthScheme>("/auth_scheme/oidc/{oidcAuthSchemeId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAuthScheme2", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a specific Auth Scheme Gets a specific Auth Scheme by the oidcAuthSchemeId.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcAuthSchemeId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of OidcAuthScheme</returns>
        public async System.Threading.Tasks.Task<OidcAuthScheme> GetAuthScheme2Async(string oidcAuthSchemeId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetAuthScheme2WithHttpInfoAsync(oidcAuthSchemeId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<OidcAuthScheme> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<OidcAuthScheme> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a specific Auth Scheme Gets a specific Auth Scheme by the oidcAuthSchemeId.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcAuthSchemeId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (OidcAuthScheme)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<OidcAuthScheme>> GetAuthScheme2WithHttpInfoAsync(string oidcAuthSchemeId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'oidcAuthSchemeId' is set
            if (oidcAuthSchemeId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'oidcAuthSchemeId' when calling DefaultApi->GetAuthScheme2");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("oidcAuthSchemeId", Elements.Client.ClientUtils.ParameterToString(oidcAuthSchemeId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<OidcAuthScheme>("/auth_scheme/oidc/{oidcAuthSchemeId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAuthScheme2", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Lists all auth schemes in the system Requires SUPERUSER access. Gets a pagination of Auth Schemes for the given query.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <returns>PaginationAuthScheme</returns>
        public PaginationAuthScheme GetAuthSchemes(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>))
        {
            Elements.Client.ApiResponse<PaginationAuthScheme> localVarResponse = GetAuthSchemesWithHttpInfo(offset, count, tags);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Lists all auth schemes in the system Requires SUPERUSER access. Gets a pagination of Auth Schemes for the given query.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <returns>ApiResponse of PaginationAuthScheme</returns>
        public Elements.Client.ApiResponse<PaginationAuthScheme> GetAuthSchemesWithHttpInfo(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (tags != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("multi", "tags", tags));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationAuthScheme>("/auth_scheme/custom", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAuthSchemes", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Lists all auth schemes in the system Requires SUPERUSER access. Gets a pagination of Auth Schemes for the given query.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationAuthScheme</returns>
        public async System.Threading.Tasks.Task<PaginationAuthScheme> GetAuthSchemesAsync(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetAuthSchemesWithHttpInfoAsync(offset, count, tags, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationAuthScheme> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationAuthScheme> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Lists all auth schemes in the system Requires SUPERUSER access. Gets a pagination of Auth Schemes for the given query.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationAuthScheme)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationAuthScheme>> GetAuthSchemesWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (tags != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("multi", "tags", tags));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationAuthScheme>("/auth_scheme/custom", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAuthSchemes", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Lists all auth schemes in the system Requires SUPERUSER access. Gets a pagination of Auth Schemes for the given query.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <returns>PaginationOAuth2AuthScheme</returns>
        public PaginationOAuth2AuthScheme GetAuthSchemes1(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>))
        {
            Elements.Client.ApiResponse<PaginationOAuth2AuthScheme> localVarResponse = GetAuthSchemes1WithHttpInfo(offset, count, tags);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Lists all auth schemes in the system Requires SUPERUSER access. Gets a pagination of Auth Schemes for the given query.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <returns>ApiResponse of PaginationOAuth2AuthScheme</returns>
        public Elements.Client.ApiResponse<PaginationOAuth2AuthScheme> GetAuthSchemes1WithHttpInfo(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (tags != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("multi", "tags", tags));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationOAuth2AuthScheme>("/auth_scheme/oauth2", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAuthSchemes1", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Lists all auth schemes in the system Requires SUPERUSER access. Gets a pagination of Auth Schemes for the given query.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationOAuth2AuthScheme</returns>
        public async System.Threading.Tasks.Task<PaginationOAuth2AuthScheme> GetAuthSchemes1Async(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetAuthSchemes1WithHttpInfoAsync(offset, count, tags, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationOAuth2AuthScheme> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationOAuth2AuthScheme> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Lists all auth schemes in the system Requires SUPERUSER access. Gets a pagination of Auth Schemes for the given query.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationOAuth2AuthScheme)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationOAuth2AuthScheme>> GetAuthSchemes1WithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (tags != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("multi", "tags", tags));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationOAuth2AuthScheme>("/auth_scheme/oauth2", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAuthSchemes1", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Lists all auth schemes in the system Requires SUPERUSER access. Gets a pagination of Auth Schemes for the given query.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <returns>PaginationOidcAuthScheme</returns>
        public PaginationOidcAuthScheme GetAuthSchemes2(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>))
        {
            Elements.Client.ApiResponse<PaginationOidcAuthScheme> localVarResponse = GetAuthSchemes2WithHttpInfo(offset, count, tags);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Lists all auth schemes in the system Requires SUPERUSER access. Gets a pagination of Auth Schemes for the given query.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <returns>ApiResponse of PaginationOidcAuthScheme</returns>
        public Elements.Client.ApiResponse<PaginationOidcAuthScheme> GetAuthSchemes2WithHttpInfo(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (tags != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("multi", "tags", tags));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationOidcAuthScheme>("/auth_scheme/oidc", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAuthSchemes2", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Lists all auth schemes in the system Requires SUPERUSER access. Gets a pagination of Auth Schemes for the given query.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationOidcAuthScheme</returns>
        public async System.Threading.Tasks.Task<PaginationOidcAuthScheme> GetAuthSchemes2Async(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetAuthSchemes2WithHttpInfoAsync(offset, count, tags, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationOidcAuthScheme> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationOidcAuthScheme> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Lists all auth schemes in the system Requires SUPERUSER access. Gets a pagination of Auth Schemes for the given query.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationOidcAuthScheme)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationOidcAuthScheme>> GetAuthSchemes2WithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (tags != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("multi", "tags", tags));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationOidcAuthScheme>("/auth_scheme/oidc", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAuthSchemes2", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <returns>Deployment</returns>
        public Deployment GetCurrentDeployment(string applicationId)
        {
            Elements.Client.ApiResponse<Deployment> localVarResponse = GetCurrentDeploymentWithHttpInfo(applicationId);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <returns>ApiResponse of Deployment</returns>
        public Elements.Client.ApiResponse<Deployment> GetCurrentDeploymentWithHttpInfo(string applicationId)
        {
            // verify the required parameter 'applicationId' is set
            if (applicationId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationId' when calling DefaultApi->GetCurrentDeployment");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationId", Elements.Client.ClientUtils.ParameterToString(applicationId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Deployment>("/deployment/{applicationId}/current", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCurrentDeployment", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Deployment</returns>
        public async System.Threading.Tasks.Task<Deployment> GetCurrentDeploymentAsync(string applicationId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetCurrentDeploymentWithHttpInfoAsync(applicationId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Deployment> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Deployment> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Deployment)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Deployment>> GetCurrentDeploymentWithHttpInfoAsync(string applicationId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationId' is set
            if (applicationId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationId' when calling DefaultApi->GetCurrentDeployment");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationId", Elements.Client.ClientUtils.ParameterToString(applicationId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<Deployment>("/deployment/{applicationId}/current", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCurrentDeployment", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets the current Profile This is a special endpoing which fetches the current Profile based on current auth credentials.  This considers the currently loggged-in Dser as well as the Application or Application Configuration against which the User is operating.  This may not be availble, in which case the appopraite error is rasied.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Profile</returns>
        public Profile GetCurrentProfile()
        {
            Elements.Client.ApiResponse<Profile> localVarResponse = GetCurrentProfileWithHttpInfo();
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets the current Profile This is a special endpoing which fetches the current Profile based on current auth credentials.  This considers the currently loggged-in Dser as well as the Application or Application Configuration against which the User is operating.  This may not be availble, in which case the appopraite error is rasied.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of Profile</returns>
        public Elements.Client.ApiResponse<Profile> GetCurrentProfileWithHttpInfo()
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Profile>("/profile/current", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCurrentProfile", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets the current Profile This is a special endpoing which fetches the current Profile based on current auth credentials.  This considers the currently loggged-in Dser as well as the Application or Application Configuration against which the User is operating.  This may not be availble, in which case the appopraite error is rasied.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Profile</returns>
        public async System.Threading.Tasks.Task<Profile> GetCurrentProfileAsync(System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetCurrentProfileWithHttpInfoAsync(cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Profile> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Profile> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets the current Profile This is a special endpoing which fetches the current Profile based on current auth credentials.  This considers the currently loggged-in Dser as well as the Application or Application Configuration against which the User is operating.  This may not be availble, in which case the appopraite error is rasied.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Profile)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Profile>> GetCurrentProfileWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<Profile>("/profile/current", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCurrentProfile", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets the current User A special endpoint used to get the current user for the request.  The current user is typically associated with the session but may be derived any other way.  This is essentially an alias for using GET /user/myUserId
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>User</returns>
        public User GetCurrentUser()
        {
            Elements.Client.ApiResponse<User> localVarResponse = GetCurrentUserWithHttpInfo();
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets the current User A special endpoint used to get the current user for the request.  The current user is typically associated with the session but may be derived any other way.  This is essentially an alias for using GET /user/myUserId
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of User</returns>
        public Elements.Client.ApiResponse<User> GetCurrentUserWithHttpInfo()
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<User>("/user/me", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCurrentUser", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets the current User A special endpoint used to get the current user for the request.  The current user is typically associated with the session but may be derived any other way.  This is essentially an alias for using GET /user/myUserId
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of User</returns>
        public async System.Threading.Tasks.Task<User> GetCurrentUserAsync(System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetCurrentUserWithHttpInfoAsync(cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<User> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<User> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets the current User A special endpoint used to get the current user for the request.  The current user is typically associated with the session but may be derived any other way.  This is essentially an alias for using GET /user/myUserId
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (User)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<User>> GetCurrentUserWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<User>("/user/me", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCurrentUser", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="deploymentId"></param>
        /// <returns>Deployment</returns>
        public Deployment GetDeployment(string applicationId, string deploymentId)
        {
            Elements.Client.ApiResponse<Deployment> localVarResponse = GetDeploymentWithHttpInfo(applicationId, deploymentId);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="deploymentId"></param>
        /// <returns>ApiResponse of Deployment</returns>
        public Elements.Client.ApiResponse<Deployment> GetDeploymentWithHttpInfo(string applicationId, string deploymentId)
        {
            // verify the required parameter 'applicationId' is set
            if (applicationId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationId' when calling DefaultApi->GetDeployment");

            // verify the required parameter 'deploymentId' is set
            if (deploymentId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'deploymentId' when calling DefaultApi->GetDeployment");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationId", Elements.Client.ClientUtils.ParameterToString(applicationId)); // path parameter
            localVarRequestOptions.PathParameters.Add("deploymentId", Elements.Client.ClientUtils.ParameterToString(deploymentId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Deployment>("/deployment/{applicationId}/{deploymentId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDeployment", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="deploymentId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Deployment</returns>
        public async System.Threading.Tasks.Task<Deployment> GetDeploymentAsync(string applicationId, string deploymentId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetDeploymentWithHttpInfoAsync(applicationId, deploymentId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Deployment> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Deployment> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="deploymentId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Deployment)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Deployment>> GetDeploymentWithHttpInfoAsync(string applicationId, string deploymentId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationId' is set
            if (applicationId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationId' when calling DefaultApi->GetDeployment");

            // verify the required parameter 'deploymentId' is set
            if (deploymentId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'deploymentId' when calling DefaultApi->GetDeployment");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationId", Elements.Client.ClientUtils.ParameterToString(applicationId)); // path parameter
            localVarRequestOptions.PathParameters.Add("deploymentId", Elements.Client.ClientUtils.ParameterToString(deploymentId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<Deployment>("/deployment/{applicationId}/{deploymentId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDeployment", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <returns>PaginationDeployment</returns>
        public PaginationDeployment GetDeployments(string applicationId)
        {
            Elements.Client.ApiResponse<PaginationDeployment> localVarResponse = GetDeploymentsWithHttpInfo(applicationId);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <returns>ApiResponse of PaginationDeployment</returns>
        public Elements.Client.ApiResponse<PaginationDeployment> GetDeploymentsWithHttpInfo(string applicationId)
        {
            // verify the required parameter 'applicationId' is set
            if (applicationId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationId' when calling DefaultApi->GetDeployments");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationId", Elements.Client.ClientUtils.ParameterToString(applicationId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationDeployment>("/deployment/{applicationId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDeployments", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationDeployment</returns>
        public async System.Threading.Tasks.Task<PaginationDeployment> GetDeploymentsAsync(string applicationId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetDeploymentsWithHttpInfoAsync(applicationId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationDeployment> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationDeployment> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationDeployment)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationDeployment>> GetDeploymentsWithHttpInfoAsync(string applicationId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationId' is set
            if (applicationId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationId' when calling DefaultApi->GetDeployments");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationId", Elements.Client.ClientUtils.ParameterToString(applicationId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationDeployment>("/deployment/{applicationId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDeployments", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets inventory item for the specified item Gets the first (primary) inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <returns>DistinctInventoryItem</returns>
        public DistinctInventoryItem GetDistinctInventoryItem(string inventoryItemId)
        {
            Elements.Client.ApiResponse<DistinctInventoryItem> localVarResponse = GetDistinctInventoryItemWithHttpInfo(inventoryItemId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets inventory item for the specified item Gets the first (primary) inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <returns>ApiResponse of DistinctInventoryItem</returns>
        public Elements.Client.ApiResponse<DistinctInventoryItem> GetDistinctInventoryItemWithHttpInfo(string inventoryItemId)
        {
            // verify the required parameter 'inventoryItemId' is set
            if (inventoryItemId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'inventoryItemId' when calling DefaultApi->GetDistinctInventoryItem");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("inventoryItemId", Elements.Client.ClientUtils.ParameterToString(inventoryItemId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<DistinctInventoryItem>("/inventory/distinct/{inventoryItemId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDistinctInventoryItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets inventory item for the specified item Gets the first (primary) inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of DistinctInventoryItem</returns>
        public async System.Threading.Tasks.Task<DistinctInventoryItem> GetDistinctInventoryItemAsync(string inventoryItemId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetDistinctInventoryItemWithHttpInfoAsync(inventoryItemId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<DistinctInventoryItem> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<DistinctInventoryItem> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets inventory item for the specified item Gets the first (primary) inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (DistinctInventoryItem)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<DistinctInventoryItem>> GetDistinctInventoryItemWithHttpInfoAsync(string inventoryItemId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'inventoryItemId' is set
            if (inventoryItemId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'inventoryItemId' when calling DefaultApi->GetDistinctInventoryItem");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("inventoryItemId", Elements.Client.ClientUtils.ParameterToString(inventoryItemId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<DistinctInventoryItem>("/inventory/distinct/{inventoryItemId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDistinctInventoryItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search inventory items Searches all inventory items in the system and returns the metadata for all matches against the given search filter.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="profileId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationDistinctInventoryItem</returns>
        public PaginationDistinctInventoryItem GetDistinctInventoryItems(int? offset = default(int?), int? count = default(int?), string userId = default(string), string profileId = default(string), string search = default(string))
        {
            Elements.Client.ApiResponse<PaginationDistinctInventoryItem> localVarResponse = GetDistinctInventoryItemsWithHttpInfo(offset, count, userId, profileId, search);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search inventory items Searches all inventory items in the system and returns the metadata for all matches against the given search filter.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="profileId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationDistinctInventoryItem</returns>
        public Elements.Client.ApiResponse<PaginationDistinctInventoryItem> GetDistinctInventoryItemsWithHttpInfo(int? offset = default(int?), int? count = default(int?), string userId = default(string), string profileId = default(string), string search = default(string))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (userId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "userId", userId));
            }
            if (profileId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationDistinctInventoryItem>("/inventory/distinct", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDistinctInventoryItems", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search inventory items Searches all inventory items in the system and returns the metadata for all matches against the given search filter.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="profileId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationDistinctInventoryItem</returns>
        public async System.Threading.Tasks.Task<PaginationDistinctInventoryItem> GetDistinctInventoryItemsAsync(int? offset = default(int?), int? count = default(int?), string userId = default(string), string profileId = default(string), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetDistinctInventoryItemsWithHttpInfoAsync(offset, count, userId, profileId, search, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationDistinctInventoryItem> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationDistinctInventoryItem> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search inventory items Searches all inventory items in the system and returns the metadata for all matches against the given search filter.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="profileId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationDistinctInventoryItem)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationDistinctInventoryItem>> GetDistinctInventoryItemsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), string userId = default(string), string profileId = default(string), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (userId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "userId", userId));
            }
            if (profileId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationDistinctInventoryItem>("/inventory/distinct", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDistinctInventoryItems", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a specific Metadata Editor Schema Gets a specific Metadata Editor Schema backed by the supplied MetadataSpec by name.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecName"></param>
        /// <returns>EditorSchema</returns>
        public EditorSchema GetEditorSchema(string metadataSpecName)
        {
            Elements.Client.ApiResponse<EditorSchema> localVarResponse = GetEditorSchemaWithHttpInfo(metadataSpecName);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a specific Metadata Editor Schema Gets a specific Metadata Editor Schema backed by the supplied MetadataSpec by name.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecName"></param>
        /// <returns>ApiResponse of EditorSchema</returns>
        public Elements.Client.ApiResponse<EditorSchema> GetEditorSchemaWithHttpInfo(string metadataSpecName)
        {
            // verify the required parameter 'metadataSpecName' is set
            if (metadataSpecName == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'metadataSpecName' when calling DefaultApi->GetEditorSchema");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("metadataSpecName", Elements.Client.ClientUtils.ParameterToString(metadataSpecName)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<EditorSchema>("/metadata_spec/{metadataSpecName}/editor.json", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEditorSchema", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a specific Metadata Editor Schema Gets a specific Metadata Editor Schema backed by the supplied MetadataSpec by name.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecName"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EditorSchema</returns>
        public async System.Threading.Tasks.Task<EditorSchema> GetEditorSchemaAsync(string metadataSpecName, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetEditorSchemaWithHttpInfoAsync(metadataSpecName, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<EditorSchema> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<EditorSchema> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a specific Metadata Editor Schema Gets a specific Metadata Editor Schema backed by the supplied MetadataSpec by name.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecName"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EditorSchema)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<EditorSchema>> GetEditorSchemaWithHttpInfoAsync(string metadataSpecName, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'metadataSpecName' is set
            if (metadataSpecName == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'metadataSpecName' when calling DefaultApi->GetEditorSchema");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("metadataSpecName", Elements.Client.ClientUtils.ParameterToString(metadataSpecName)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<EditorSchema>("/metadata_spec/{metadataSpecName}/editor.json", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEditorSchema", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a Facebook Application Configuration Gets a single Facebook application based on unique name or ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>FacebookApplicationConfiguration</returns>
        public FacebookApplicationConfiguration GetFacebookApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId)
        {
            Elements.Client.ApiResponse<FacebookApplicationConfiguration> localVarResponse = GetFacebookApplicationConfigurationWithHttpInfo(applicationNameOrId, applicationConfigurationNameOrId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a Facebook Application Configuration Gets a single Facebook application based on unique name or ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>ApiResponse of FacebookApplicationConfiguration</returns>
        public Elements.Client.ApiResponse<FacebookApplicationConfiguration> GetFacebookApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId)
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->GetFacebookApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->GetFacebookApplicationConfiguration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<FacebookApplicationConfiguration>("/application/{applicationNameOrId}/configuration/facebook/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFacebookApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a Facebook Application Configuration Gets a single Facebook application based on unique name or ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FacebookApplicationConfiguration</returns>
        public async System.Threading.Tasks.Task<FacebookApplicationConfiguration> GetFacebookApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetFacebookApplicationConfigurationWithHttpInfoAsync(applicationNameOrId, applicationConfigurationNameOrId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<FacebookApplicationConfiguration> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<FacebookApplicationConfiguration> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a Facebook Application Configuration Gets a single Facebook application based on unique name or ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FacebookApplicationConfiguration)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<FacebookApplicationConfiguration>> GetFacebookApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->GetFacebookApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->GetFacebookApplicationConfiguration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<FacebookApplicationConfiguration>("/application/{applicationNameOrId}/configuration/facebook/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFacebookApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a Firebase Application Configuration Gets a single Firebase application based on unique name or ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>FirebaseApplicationConfiguration</returns>
        public FirebaseApplicationConfiguration GetFirebaseApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId)
        {
            Elements.Client.ApiResponse<FirebaseApplicationConfiguration> localVarResponse = GetFirebaseApplicationConfigurationWithHttpInfo(applicationNameOrId, applicationConfigurationNameOrId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a Firebase Application Configuration Gets a single Firebase application based on unique name or ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>ApiResponse of FirebaseApplicationConfiguration</returns>
        public Elements.Client.ApiResponse<FirebaseApplicationConfiguration> GetFirebaseApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId)
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->GetFirebaseApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->GetFirebaseApplicationConfiguration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<FirebaseApplicationConfiguration>("/application/{applicationNameOrId}/configuration/firebase/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFirebaseApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a Firebase Application Configuration Gets a single Firebase application based on unique name or ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FirebaseApplicationConfiguration</returns>
        public async System.Threading.Tasks.Task<FirebaseApplicationConfiguration> GetFirebaseApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetFirebaseApplicationConfigurationWithHttpInfoAsync(applicationNameOrId, applicationConfigurationNameOrId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<FirebaseApplicationConfiguration> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<FirebaseApplicationConfiguration> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a Firebase Application Configuration Gets a single Firebase application based on unique name or ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FirebaseApplicationConfiguration)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<FirebaseApplicationConfiguration>> GetFirebaseApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->GetFirebaseApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->GetFirebaseApplicationConfiguration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<FirebaseApplicationConfiguration>("/application/{applicationNameOrId}/configuration/firebase/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFirebaseApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a specific profile using the ID of the profile and followed id. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="followedId"></param>
        /// <returns>Profile</returns>
        public Profile GetFollower(string profileId, string followedId)
        {
            Elements.Client.ApiResponse<Profile> localVarResponse = GetFollowerWithHttpInfo(profileId, followedId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a specific profile using the ID of the profile and followed id. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="followedId"></param>
        /// <returns>ApiResponse of Profile</returns>
        public Elements.Client.ApiResponse<Profile> GetFollowerWithHttpInfo(string profileId, string followedId)
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'profileId' when calling DefaultApi->GetFollower");

            // verify the required parameter 'followedId' is set
            if (followedId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'followedId' when calling DefaultApi->GetFollower");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("profileId", Elements.Client.ClientUtils.ParameterToString(profileId)); // path parameter
            localVarRequestOptions.PathParameters.Add("followedId", Elements.Client.ClientUtils.ParameterToString(followedId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Profile>("/follower/{profileId}/{followedId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFollower", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a specific profile using the ID of the profile and followed id. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="followedId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Profile</returns>
        public async System.Threading.Tasks.Task<Profile> GetFollowerAsync(string profileId, string followedId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetFollowerWithHttpInfoAsync(profileId, followedId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Profile> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Profile> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a specific profile using the ID of the profile and followed id. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="followedId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Profile)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Profile>> GetFollowerWithHttpInfoAsync(string profileId, string followedId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'profileId' when calling DefaultApi->GetFollower");

            // verify the required parameter 'followedId' is set
            if (followedId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'followedId' when calling DefaultApi->GetFollower");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("profileId", Elements.Client.ClientUtils.ParameterToString(profileId)); // path parameter
            localVarRequestOptions.PathParameters.Add("followedId", Elements.Client.ClientUtils.ParameterToString(followedId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<Profile>("/follower/{profileId}/{followedId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFollower", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search Followers Searches all followers in the system and returning the metadata for all matches against the given profile id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <returns>PaginationProfile</returns>
        public PaginationProfile GetFollowers(string profileId, int? offset = default(int?), int? count = default(int?))
        {
            Elements.Client.ApiResponse<PaginationProfile> localVarResponse = GetFollowersWithHttpInfo(profileId, offset, count);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search Followers Searches all followers in the system and returning the metadata for all matches against the given profile id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <returns>ApiResponse of PaginationProfile</returns>
        public Elements.Client.ApiResponse<PaginationProfile> GetFollowersWithHttpInfo(string profileId, int? offset = default(int?), int? count = default(int?))
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'profileId' when calling DefaultApi->GetFollowers");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("profileId", Elements.Client.ClientUtils.ParameterToString(profileId)); // path parameter
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationProfile>("/followee/{profileId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFollowers", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search Followers Searches all followers in the system and returning the metadata for all matches against the given profile id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationProfile</returns>
        public async System.Threading.Tasks.Task<PaginationProfile> GetFollowersAsync(string profileId, int? offset = default(int?), int? count = default(int?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetFollowersWithHttpInfoAsync(profileId, offset, count, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationProfile> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationProfile> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search Followers Searches all followers in the system and returning the metadata for all matches against the given profile id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationProfile)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationProfile>> GetFollowersWithHttpInfoAsync(string profileId, int? offset = default(int?), int? count = default(int?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'profileId' when calling DefaultApi->GetFollowers");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("profileId", Elements.Client.ClientUtils.ParameterToString(profileId)); // path parameter
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationProfile>("/followee/{profileId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFollowers", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search Followers Searches all followers in the system and returning the metadata for all matches against the given profile id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <returns>PaginationProfile</returns>
        public PaginationProfile GetFollowers1(string profileId, int? offset = default(int?), int? count = default(int?))
        {
            Elements.Client.ApiResponse<PaginationProfile> localVarResponse = GetFollowers1WithHttpInfo(profileId, offset, count);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search Followers Searches all followers in the system and returning the metadata for all matches against the given profile id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <returns>ApiResponse of PaginationProfile</returns>
        public Elements.Client.ApiResponse<PaginationProfile> GetFollowers1WithHttpInfo(string profileId, int? offset = default(int?), int? count = default(int?))
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'profileId' when calling DefaultApi->GetFollowers1");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("profileId", Elements.Client.ClientUtils.ParameterToString(profileId)); // path parameter
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationProfile>("/follower/{profileId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFollowers1", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search Followers Searches all followers in the system and returning the metadata for all matches against the given profile id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationProfile</returns>
        public async System.Threading.Tasks.Task<PaginationProfile> GetFollowers1Async(string profileId, int? offset = default(int?), int? count = default(int?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetFollowers1WithHttpInfoAsync(profileId, offset, count, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationProfile> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationProfile> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search Followers Searches all followers in the system and returning the metadata for all matches against the given profile id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationProfile)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationProfile>> GetFollowers1WithHttpInfoAsync(string profileId, int? offset = default(int?), int? count = default(int?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'profileId' when calling DefaultApi->GetFollowers1");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("profileId", Elements.Client.ClientUtils.ParameterToString(profileId)); // path parameter
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationProfile>("/follower/{profileId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFollowers1", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a Specific Friend Gets a specific friend using the ID of the friend.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="friendId"></param>
        /// <returns>Friend</returns>
        public Friend GetFriend(string friendId)
        {
            Elements.Client.ApiResponse<Friend> localVarResponse = GetFriendWithHttpInfo(friendId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a Specific Friend Gets a specific friend using the ID of the friend.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="friendId"></param>
        /// <returns>ApiResponse of Friend</returns>
        public Elements.Client.ApiResponse<Friend> GetFriendWithHttpInfo(string friendId)
        {
            // verify the required parameter 'friendId' is set
            if (friendId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'friendId' when calling DefaultApi->GetFriend");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("friendId", Elements.Client.ClientUtils.ParameterToString(friendId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Friend>("/friend/{friendId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFriend", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a Specific Friend Gets a specific friend using the ID of the friend.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="friendId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Friend</returns>
        public async System.Threading.Tasks.Task<Friend> GetFriendAsync(string friendId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetFriendWithHttpInfoAsync(friendId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Friend> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Friend> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a Specific Friend Gets a specific friend using the ID of the friend.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="friendId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Friend)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Friend>> GetFriendWithHttpInfoAsync(string friendId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'friendId' is set
            if (friendId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'friendId' when calling DefaultApi->GetFriend");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("friendId", Elements.Client.ClientUtils.ParameterToString(friendId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<Friend>("/friend/{friendId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFriend", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search Friends Searches all friends in the system and returning the metadata for all matches against the given search filter.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationFriend</returns>
        public PaginationFriend GetFriends(int? offset = default(int?), int? count = default(int?), string search = default(string))
        {
            Elements.Client.ApiResponse<PaginationFriend> localVarResponse = GetFriendsWithHttpInfo(offset, count, search);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search Friends Searches all friends in the system and returning the metadata for all matches against the given search filter.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationFriend</returns>
        public Elements.Client.ApiResponse<PaginationFriend> GetFriendsWithHttpInfo(int? offset = default(int?), int? count = default(int?), string search = default(string))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationFriend>("/friend", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFriends", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search Friends Searches all friends in the system and returning the metadata for all matches against the given search filter.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationFriend</returns>
        public async System.Threading.Tasks.Task<PaginationFriend> GetFriendsAsync(int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetFriendsWithHttpInfoAsync(offset, count, search, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationFriend> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationFriend> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search Friends Searches all friends in the system and returning the metadata for all matches against the given search filter.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationFriend)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationFriend>> GetFriendsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationFriend>("/friend", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFriends", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets Rank Among all Players Gets the current Profile&#39;s rank among all players for the particular leaderboard.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">Specifies the leaderboard name or ID.</param>
        /// <param name="leaderboardEpoch">Specifies the epoch for the leaderboard. If not provided, the current epoch will be used by default for epochal leaderboards. This value will be ignored for all-time leaderboards. Set this value to 0 to explicitly reference the current epoch (when applicable). (optional)</param>
        /// <returns>TabulationRankRow</returns>
        public TabulationRankRow GetGlobalRankTabular(string leaderboardNameOrId, long? leaderboardEpoch = default(long?))
        {
            Elements.Client.ApiResponse<TabulationRankRow> localVarResponse = GetGlobalRankTabularWithHttpInfo(leaderboardNameOrId, leaderboardEpoch);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets Rank Among all Players Gets the current Profile&#39;s rank among all players for the particular leaderboard.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">Specifies the leaderboard name or ID.</param>
        /// <param name="leaderboardEpoch">Specifies the epoch for the leaderboard. If not provided, the current epoch will be used by default for epochal leaderboards. This value will be ignored for all-time leaderboards. Set this value to 0 to explicitly reference the current epoch (when applicable). (optional)</param>
        /// <returns>ApiResponse of TabulationRankRow</returns>
        public Elements.Client.ApiResponse<TabulationRankRow> GetGlobalRankTabularWithHttpInfo(string leaderboardNameOrId, long? leaderboardEpoch = default(long?))
        {
            // verify the required parameter 'leaderboardNameOrId' is set
            if (leaderboardNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'leaderboardNameOrId' when calling DefaultApi->GetGlobalRankTabular");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/csv",
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("leaderboardNameOrId", Elements.Client.ClientUtils.ParameterToString(leaderboardNameOrId)); // path parameter
            if (leaderboardEpoch != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "leaderboardEpoch", leaderboardEpoch));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<TabulationRankRow>("/rank/global/{leaderboardNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetGlobalRankTabular", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets Rank Among all Players Gets the current Profile&#39;s rank among all players for the particular leaderboard.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">Specifies the leaderboard name or ID.</param>
        /// <param name="leaderboardEpoch">Specifies the epoch for the leaderboard. If not provided, the current epoch will be used by default for epochal leaderboards. This value will be ignored for all-time leaderboards. Set this value to 0 to explicitly reference the current epoch (when applicable). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TabulationRankRow</returns>
        public async System.Threading.Tasks.Task<TabulationRankRow> GetGlobalRankTabularAsync(string leaderboardNameOrId, long? leaderboardEpoch = default(long?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetGlobalRankTabularWithHttpInfoAsync(leaderboardNameOrId, leaderboardEpoch, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<TabulationRankRow> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<TabulationRankRow> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets Rank Among all Players Gets the current Profile&#39;s rank among all players for the particular leaderboard.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">Specifies the leaderboard name or ID.</param>
        /// <param name="leaderboardEpoch">Specifies the epoch for the leaderboard. If not provided, the current epoch will be used by default for epochal leaderboards. This value will be ignored for all-time leaderboards. Set this value to 0 to explicitly reference the current epoch (when applicable). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TabulationRankRow)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<TabulationRankRow>> GetGlobalRankTabularWithHttpInfoAsync(string leaderboardNameOrId, long? leaderboardEpoch = default(long?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'leaderboardNameOrId' is set
            if (leaderboardNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'leaderboardNameOrId' when calling DefaultApi->GetGlobalRankTabular");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/csv",
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("leaderboardNameOrId", Elements.Client.ClientUtils.ParameterToString(leaderboardNameOrId)); // path parameter
            if (leaderboardEpoch != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "leaderboardEpoch", leaderboardEpoch));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<TabulationRankRow>("/rank/global/{leaderboardNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetGlobalRankTabular", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a Google Play Application Configuration Gets a single Google Play application based on unique name or ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>GooglePlayApplicationConfiguration</returns>
        public GooglePlayApplicationConfiguration GetGooglePlayApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId)
        {
            Elements.Client.ApiResponse<GooglePlayApplicationConfiguration> localVarResponse = GetGooglePlayApplicationConfigurationWithHttpInfo(applicationNameOrId, applicationConfigurationNameOrId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a Google Play Application Configuration Gets a single Google Play application based on unique name or ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>ApiResponse of GooglePlayApplicationConfiguration</returns>
        public Elements.Client.ApiResponse<GooglePlayApplicationConfiguration> GetGooglePlayApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId)
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->GetGooglePlayApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->GetGooglePlayApplicationConfiguration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GooglePlayApplicationConfiguration>("/application/{applicationNameOrId}/configuration/google_play/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetGooglePlayApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a Google Play Application Configuration Gets a single Google Play application based on unique name or ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GooglePlayApplicationConfiguration</returns>
        public async System.Threading.Tasks.Task<GooglePlayApplicationConfiguration> GetGooglePlayApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetGooglePlayApplicationConfigurationWithHttpInfoAsync(applicationNameOrId, applicationConfigurationNameOrId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<GooglePlayApplicationConfiguration> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<GooglePlayApplicationConfiguration> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a Google Play Application Configuration Gets a single Google Play application based on unique name or ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GooglePlayApplicationConfiguration)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<GooglePlayApplicationConfiguration>> GetGooglePlayApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->GetGooglePlayApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->GetGooglePlayApplicationConfiguration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<GooglePlayApplicationConfiguration>("/application/{applicationNameOrId}/configuration/google_play/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetGooglePlayApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a iOS Application Configuration Gets a single iOS application based on unique name or ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>IosApplicationConfiguration</returns>
        public IosApplicationConfiguration GetIosApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId)
        {
            Elements.Client.ApiResponse<IosApplicationConfiguration> localVarResponse = GetIosApplicationConfigurationWithHttpInfo(applicationNameOrId, applicationConfigurationNameOrId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a iOS Application Configuration Gets a single iOS application based on unique name or ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>ApiResponse of IosApplicationConfiguration</returns>
        public Elements.Client.ApiResponse<IosApplicationConfiguration> GetIosApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId)
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->GetIosApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->GetIosApplicationConfiguration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<IosApplicationConfiguration>("/application/{applicationNameOrId}/configuration/ios/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetIosApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a iOS Application Configuration Gets a single iOS application based on unique name or ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IosApplicationConfiguration</returns>
        public async System.Threading.Tasks.Task<IosApplicationConfiguration> GetIosApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetIosApplicationConfigurationWithHttpInfoAsync(applicationNameOrId, applicationConfigurationNameOrId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<IosApplicationConfiguration> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<IosApplicationConfiguration> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a iOS Application Configuration Gets a single iOS application based on unique name or ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IosApplicationConfiguration)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<IosApplicationConfiguration>> GetIosApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->GetIosApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->GetIosApplicationConfiguration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<IosApplicationConfiguration>("/application/{applicationNameOrId}/configuration/ios/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetIosApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieves a single Item by id or by name Looks up an item by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="identifier"></param>
        /// <returns>Item</returns>
        public Item GetItemByIdentifier(string identifier)
        {
            Elements.Client.ApiResponse<Item> localVarResponse = GetItemByIdentifierWithHttpInfo(identifier);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieves a single Item by id or by name Looks up an item by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="identifier"></param>
        /// <returns>ApiResponse of Item</returns>
        public Elements.Client.ApiResponse<Item> GetItemByIdentifierWithHttpInfo(string identifier)
        {
            // verify the required parameter 'identifier' is set
            if (identifier == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'identifier' when calling DefaultApi->GetItemByIdentifier");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("identifier", Elements.Client.ClientUtils.ParameterToString(identifier)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Item>("/item/{identifier}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetItemByIdentifier", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieves a single Item by id or by name Looks up an item by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="identifier"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Item</returns>
        public async System.Threading.Tasks.Task<Item> GetItemByIdentifierAsync(string identifier, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetItemByIdentifierWithHttpInfoAsync(identifier, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Item> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Item> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieves a single Item by id or by name Looks up an item by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="identifier"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Item)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Item>> GetItemByIdentifierWithHttpInfoAsync(string identifier, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'identifier' is set
            if (identifier == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'identifier' when calling DefaultApi->GetItemByIdentifier");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("identifier", Elements.Client.ClientUtils.ParameterToString(identifier)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<Item>("/item/{identifier}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetItemByIdentifier", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieves all Items Searches all items and returns all matching items, filtered by the passed in search parameters.  If multiple tags are specified, then all items that contain at least one of the passed in tags is returned.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="category"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationItem</returns>
        public PaginationItem GetItems(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string category = default(string), string search = default(string))
        {
            Elements.Client.ApiResponse<PaginationItem> localVarResponse = GetItemsWithHttpInfo(offset, count, tags, category, search);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieves all Items Searches all items and returns all matching items, filtered by the passed in search parameters.  If multiple tags are specified, then all items that contain at least one of the passed in tags is returned.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="category"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationItem</returns>
        public Elements.Client.ApiResponse<PaginationItem> GetItemsWithHttpInfo(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string category = default(string), string search = default(string))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (tags != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("multi", "tags", tags));
            }
            if (category != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "category", category));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationItem>("/item", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetItems", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieves all Items Searches all items and returns all matching items, filtered by the passed in search parameters.  If multiple tags are specified, then all items that contain at least one of the passed in tags is returned.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="category"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationItem</returns>
        public async System.Threading.Tasks.Task<PaginationItem> GetItemsAsync(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string category = default(string), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetItemsWithHttpInfoAsync(offset, count, tags, category, search, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationItem> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationItem> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieves all Items Searches all items and returns all matching items, filtered by the passed in search parameters.  If multiple tags are specified, then all items that contain at least one of the passed in tags is returned.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="category"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationItem)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationItem>> GetItemsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string category = default(string), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (tags != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("multi", "tags", tags));
            }
            if (category != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "category", category));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationItem>("/item", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetItems", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a specific JSON Schema Gets a specific JSON Schema backed by the supplied MetadataSpec by name.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecName"></param>
        /// <returns>JsonSchema</returns>
        public JsonSchema GetJsonSchema(string metadataSpecName)
        {
            Elements.Client.ApiResponse<JsonSchema> localVarResponse = GetJsonSchemaWithHttpInfo(metadataSpecName);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a specific JSON Schema Gets a specific JSON Schema backed by the supplied MetadataSpec by name.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecName"></param>
        /// <returns>ApiResponse of JsonSchema</returns>
        public Elements.Client.ApiResponse<JsonSchema> GetJsonSchemaWithHttpInfo(string metadataSpecName)
        {
            // verify the required parameter 'metadataSpecName' is set
            if (metadataSpecName == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'metadataSpecName' when calling DefaultApi->GetJsonSchema");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("metadataSpecName", Elements.Client.ClientUtils.ParameterToString(metadataSpecName)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<JsonSchema>("/metadata_spec/{metadataSpecName}/schema.json", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetJsonSchema", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a specific JSON Schema Gets a specific JSON Schema backed by the supplied MetadataSpec by name.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecName"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of JsonSchema</returns>
        public async System.Threading.Tasks.Task<JsonSchema> GetJsonSchemaAsync(string metadataSpecName, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetJsonSchemaWithHttpInfoAsync(metadataSpecName, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<JsonSchema> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<JsonSchema> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a specific JSON Schema Gets a specific JSON Schema backed by the supplied MetadataSpec by name.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecName"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (JsonSchema)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<JsonSchema>> GetJsonSchemaWithHttpInfoAsync(string metadataSpecName, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'metadataSpecName' is set
            if (metadataSpecName == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'metadataSpecName' when calling DefaultApi->GetJsonSchema");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("metadataSpecName", Elements.Client.ClientUtils.ParameterToString(metadataSpecName)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<JsonSchema>("/metadata_spec/{metadataSpecName}/schema.json", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetJsonSchema", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a LargeObject 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <returns>LargeObject</returns>
        public LargeObject GetLargeObject(string largeObjectId)
        {
            Elements.Client.ApiResponse<LargeObject> localVarResponse = GetLargeObjectWithHttpInfo(largeObjectId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a LargeObject 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <returns>ApiResponse of LargeObject</returns>
        public Elements.Client.ApiResponse<LargeObject> GetLargeObjectWithHttpInfo(string largeObjectId)
        {
            // verify the required parameter 'largeObjectId' is set
            if (largeObjectId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'largeObjectId' when calling DefaultApi->GetLargeObject");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("largeObjectId", Elements.Client.ClientUtils.ParameterToString(largeObjectId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<LargeObject>("/large_object/{largeObjectId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLargeObject", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a LargeObject 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LargeObject</returns>
        public async System.Threading.Tasks.Task<LargeObject> GetLargeObjectAsync(string largeObjectId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetLargeObjectWithHttpInfoAsync(largeObjectId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<LargeObject> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<LargeObject> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a LargeObject 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LargeObject)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<LargeObject>> GetLargeObjectWithHttpInfoAsync(string largeObjectId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'largeObjectId' is set
            if (largeObjectId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'largeObjectId' when calling DefaultApi->GetLargeObject");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("largeObjectId", Elements.Client.ClientUtils.ParameterToString(largeObjectId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<LargeObject>("/large_object/{largeObjectId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLargeObject", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get an Leaderboard Gets the metadata for a single leaderboard.  This may include more specific details not availble in the bulk-get or fetch operation.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <returns>Leaderboard</returns>
        public Leaderboard GetLeaderboard(string nameOrId)
        {
            Elements.Client.ApiResponse<Leaderboard> localVarResponse = GetLeaderboardWithHttpInfo(nameOrId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get an Leaderboard Gets the metadata for a single leaderboard.  This may include more specific details not availble in the bulk-get or fetch operation.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <returns>ApiResponse of Leaderboard</returns>
        public Elements.Client.ApiResponse<Leaderboard> GetLeaderboardWithHttpInfo(string nameOrId)
        {
            // verify the required parameter 'nameOrId' is set
            if (nameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'nameOrId' when calling DefaultApi->GetLeaderboard");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("nameOrId", Elements.Client.ClientUtils.ParameterToString(nameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Leaderboard>("/leaderboard/{nameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLeaderboard", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get an Leaderboard Gets the metadata for a single leaderboard.  This may include more specific details not availble in the bulk-get or fetch operation.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Leaderboard</returns>
        public async System.Threading.Tasks.Task<Leaderboard> GetLeaderboardAsync(string nameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetLeaderboardWithHttpInfoAsync(nameOrId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Leaderboard> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Leaderboard> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get an Leaderboard Gets the metadata for a single leaderboard.  This may include more specific details not availble in the bulk-get or fetch operation.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Leaderboard)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Leaderboard>> GetLeaderboardWithHttpInfoAsync(string nameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'nameOrId' is set
            if (nameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'nameOrId' when calling DefaultApi->GetLeaderboard");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("nameOrId", Elements.Client.ClientUtils.ParameterToString(nameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<Leaderboard>("/leaderboard/{nameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLeaderboard", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search Leaderboards Performs a full-text search of all leaderboards known to the server.  As with other full-text endpoints this allows for pagination and offset.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationLeaderboard</returns>
        public PaginationLeaderboard GetLeaderboards(int? offset = default(int?), int? count = default(int?), string search = default(string))
        {
            Elements.Client.ApiResponse<PaginationLeaderboard> localVarResponse = GetLeaderboardsWithHttpInfo(offset, count, search);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search Leaderboards Performs a full-text search of all leaderboards known to the server.  As with other full-text endpoints this allows for pagination and offset.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationLeaderboard</returns>
        public Elements.Client.ApiResponse<PaginationLeaderboard> GetLeaderboardsWithHttpInfo(int? offset = default(int?), int? count = default(int?), string search = default(string))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationLeaderboard>("/leaderboard", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLeaderboards", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search Leaderboards Performs a full-text search of all leaderboards known to the server.  As with other full-text endpoints this allows for pagination and offset.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationLeaderboard</returns>
        public async System.Threading.Tasks.Task<PaginationLeaderboard> GetLeaderboardsAsync(int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetLeaderboardsWithHttpInfoAsync(offset, count, search, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationLeaderboard> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationLeaderboard> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search Leaderboards Performs a full-text search of all leaderboards known to the server.  As with other full-text endpoints this allows for pagination and offset.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationLeaderboard)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationLeaderboard>> GetLeaderboardsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationLeaderboard>("/leaderboard", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLeaderboards", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a Specific Match Gets a specific match given the match&#39;s unique ID.  Additionally, it is possible to instruct the API to wait for a period of time before sending the response.  The request will intentionally hang until the requested Match with ID has been updated in the database.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchId"></param>
        /// <param name="socialEngineLongPollTimeout">The maximum amount time the server will wait until a request returns a default set of data for long polling.  Specifying a zero will request that the server wait indefinitely until responding.  Though, the server may enforce a practical upper limit on the amount of time it takes to return.  Omitting this header will prompt the server to treat the request as a normal request. (optional)</param>
        /// <returns>Match</returns>
        public Match GetMatch(string matchId, long? socialEngineLongPollTimeout = default(long?))
        {
            Elements.Client.ApiResponse<Match> localVarResponse = GetMatchWithHttpInfo(matchId, socialEngineLongPollTimeout);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a Specific Match Gets a specific match given the match&#39;s unique ID.  Additionally, it is possible to instruct the API to wait for a period of time before sending the response.  The request will intentionally hang until the requested Match with ID has been updated in the database.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchId"></param>
        /// <param name="socialEngineLongPollTimeout">The maximum amount time the server will wait until a request returns a default set of data for long polling.  Specifying a zero will request that the server wait indefinitely until responding.  Though, the server may enforce a practical upper limit on the amount of time it takes to return.  Omitting this header will prompt the server to treat the request as a normal request. (optional)</param>
        /// <returns>ApiResponse of Match</returns>
        public Elements.Client.ApiResponse<Match> GetMatchWithHttpInfo(string matchId, long? socialEngineLongPollTimeout = default(long?))
        {
            // verify the required parameter 'matchId' is set
            if (matchId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'matchId' when calling DefaultApi->GetMatch");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("matchId", Elements.Client.ClientUtils.ParameterToString(matchId)); // path parameter
            if (socialEngineLongPollTimeout != null)
            {
                localVarRequestOptions.HeaderParameters.Add("SocialEngine-LongPoll-Timeout", Elements.Client.ClientUtils.ParameterToString(socialEngineLongPollTimeout)); // header parameter
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Match>("/match/{matchId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMatch", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a Specific Match Gets a specific match given the match&#39;s unique ID.  Additionally, it is possible to instruct the API to wait for a period of time before sending the response.  The request will intentionally hang until the requested Match with ID has been updated in the database.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchId"></param>
        /// <param name="socialEngineLongPollTimeout">The maximum amount time the server will wait until a request returns a default set of data for long polling.  Specifying a zero will request that the server wait indefinitely until responding.  Though, the server may enforce a practical upper limit on the amount of time it takes to return.  Omitting this header will prompt the server to treat the request as a normal request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Match</returns>
        public async System.Threading.Tasks.Task<Match> GetMatchAsync(string matchId, long? socialEngineLongPollTimeout = default(long?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetMatchWithHttpInfoAsync(matchId, socialEngineLongPollTimeout, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Match> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Match> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a Specific Match Gets a specific match given the match&#39;s unique ID.  Additionally, it is possible to instruct the API to wait for a period of time before sending the response.  The request will intentionally hang until the requested Match with ID has been updated in the database.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchId"></param>
        /// <param name="socialEngineLongPollTimeout">The maximum amount time the server will wait until a request returns a default set of data for long polling.  Specifying a zero will request that the server wait indefinitely until responding.  Though, the server may enforce a practical upper limit on the amount of time it takes to return.  Omitting this header will prompt the server to treat the request as a normal request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Match)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Match>> GetMatchWithHttpInfoAsync(string matchId, long? socialEngineLongPollTimeout = default(long?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'matchId' is set
            if (matchId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'matchId' when calling DefaultApi->GetMatch");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("matchId", Elements.Client.ClientUtils.ParameterToString(matchId)); // path parameter
            if (socialEngineLongPollTimeout != null)
            {
                localVarRequestOptions.HeaderParameters.Add("SocialEngine-LongPoll-Timeout", Elements.Client.ClientUtils.ParameterToString(socialEngineLongPollTimeout)); // header parameter
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<Match>("/match/{matchId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMatch", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Match normalized phone numbers with requested list Both phones from request and from DB are normalized and compared.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="inviteViaPhonesRequest"> (optional)</param>
        /// <returns>InviteViaPhonesResponse</returns>
        public InviteViaPhonesResponse GetMatchedUserProfilesWithPhoneNumbers(int? offset = default(int?), int? count = default(int?), InviteViaPhonesRequest inviteViaPhonesRequest = default(InviteViaPhonesRequest))
        {
            Elements.Client.ApiResponse<InviteViaPhonesResponse> localVarResponse = GetMatchedUserProfilesWithPhoneNumbersWithHttpInfo(offset, count, inviteViaPhonesRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Match normalized phone numbers with requested list Both phones from request and from DB are normalized and compared.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="inviteViaPhonesRequest"> (optional)</param>
        /// <returns>ApiResponse of InviteViaPhonesResponse</returns>
        public Elements.Client.ApiResponse<InviteViaPhonesResponse> GetMatchedUserProfilesWithPhoneNumbersWithHttpInfo(int? offset = default(int?), int? count = default(int?), InviteViaPhonesRequest inviteViaPhonesRequest = default(InviteViaPhonesRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            localVarRequestOptions.Data = inviteViaPhonesRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<InviteViaPhonesResponse>("/invite", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMatchedUserProfilesWithPhoneNumbers", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Match normalized phone numbers with requested list Both phones from request and from DB are normalized and compared.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="inviteViaPhonesRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InviteViaPhonesResponse</returns>
        public async System.Threading.Tasks.Task<InviteViaPhonesResponse> GetMatchedUserProfilesWithPhoneNumbersAsync(int? offset = default(int?), int? count = default(int?), InviteViaPhonesRequest inviteViaPhonesRequest = default(InviteViaPhonesRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetMatchedUserProfilesWithPhoneNumbersWithHttpInfoAsync(offset, count, inviteViaPhonesRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<InviteViaPhonesResponse> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<InviteViaPhonesResponse> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Match normalized phone numbers with requested list Both phones from request and from DB are normalized and compared.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="inviteViaPhonesRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InviteViaPhonesResponse)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<InviteViaPhonesResponse>> GetMatchedUserProfilesWithPhoneNumbersWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), InviteViaPhonesRequest inviteViaPhonesRequest = default(InviteViaPhonesRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            localVarRequestOptions.Data = inviteViaPhonesRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<InviteViaPhonesResponse>("/invite", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMatchedUserProfilesWithPhoneNumbers", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Matches Lists all matches available.  Under most circumstances, this will requires that a profile be made available to the request.  The server may choose to return an error if no suitable profile can be determined.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationMatch</returns>
        public PaginationMatch GetMatches(int? offset = default(int?), int? count = default(int?), string search = default(string))
        {
            Elements.Client.ApiResponse<PaginationMatch> localVarResponse = GetMatchesWithHttpInfo(offset, count, search);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Matches Lists all matches available.  Under most circumstances, this will requires that a profile be made available to the request.  The server may choose to return an error if no suitable profile can be determined.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationMatch</returns>
        public Elements.Client.ApiResponse<PaginationMatch> GetMatchesWithHttpInfo(int? offset = default(int?), int? count = default(int?), string search = default(string))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationMatch>("/match", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMatches", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Matches Lists all matches available.  Under most circumstances, this will requires that a profile be made available to the request.  The server may choose to return an error if no suitable profile can be determined.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationMatch</returns>
        public async System.Threading.Tasks.Task<PaginationMatch> GetMatchesAsync(int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetMatchesWithHttpInfoAsync(offset, count, search, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationMatch> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationMatch> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Matches Lists all matches available.  Under most circumstances, this will requires that a profile be made available to the request.  The server may choose to return an error if no suitable profile can be determined.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationMatch)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationMatch>> GetMatchesWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationMatch>("/match", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMatches", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a iOS Application Configuration Gets a single iOS application based on unique name or ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>MatchmakingApplicationConfiguration</returns>
        public MatchmakingApplicationConfiguration GetMatchmakingApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId)
        {
            Elements.Client.ApiResponse<MatchmakingApplicationConfiguration> localVarResponse = GetMatchmakingApplicationConfigurationWithHttpInfo(applicationNameOrId, applicationConfigurationNameOrId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a iOS Application Configuration Gets a single iOS application based on unique name or ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>ApiResponse of MatchmakingApplicationConfiguration</returns>
        public Elements.Client.ApiResponse<MatchmakingApplicationConfiguration> GetMatchmakingApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId)
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->GetMatchmakingApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->GetMatchmakingApplicationConfiguration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<MatchmakingApplicationConfiguration>("/application/{applicationNameOrId}/configuration/matchmaking/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMatchmakingApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a iOS Application Configuration Gets a single iOS application based on unique name or ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MatchmakingApplicationConfiguration</returns>
        public async System.Threading.Tasks.Task<MatchmakingApplicationConfiguration> GetMatchmakingApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetMatchmakingApplicationConfigurationWithHttpInfoAsync(applicationNameOrId, applicationConfigurationNameOrId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<MatchmakingApplicationConfiguration> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<MatchmakingApplicationConfiguration> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a iOS Application Configuration Gets a single iOS application based on unique name or ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MatchmakingApplicationConfiguration)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<MatchmakingApplicationConfiguration>> GetMatchmakingApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->GetMatchmakingApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->GetMatchmakingApplicationConfiguration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<MatchmakingApplicationConfiguration>("/application/{applicationNameOrId}/configuration/matchmaking/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMatchmakingApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a specific Metadata object Gets a specific metadata object by name or id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>Metadata</returns>
        public Metadata GetMetadataObject(string id)
        {
            Elements.Client.ApiResponse<Metadata> localVarResponse = GetMetadataObjectWithHttpInfo(id);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a specific Metadata object Gets a specific metadata object by name or id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>ApiResponse of Metadata</returns>
        public Elements.Client.ApiResponse<Metadata> GetMetadataObjectWithHttpInfo(string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'id' when calling DefaultApi->GetMetadataObject");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Elements.Client.ClientUtils.ParameterToString(id)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Metadata>("/metadata/{id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMetadataObject", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a specific Metadata object Gets a specific metadata object by name or id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Metadata</returns>
        public async System.Threading.Tasks.Task<Metadata> GetMetadataObjectAsync(string id, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetMetadataObjectWithHttpInfoAsync(id, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Metadata> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Metadata> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a specific Metadata object Gets a specific metadata object by name or id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Metadata)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Metadata>> GetMetadataObjectWithHttpInfoAsync(string id, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'id' when calling DefaultApi->GetMetadataObject");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Elements.Client.ClientUtils.ParameterToString(id)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<Metadata>("/metadata/{id}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMetadataObject", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search Metadata Searches all metadata in the system and returning all matches against the given search filter.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationMetadata</returns>
        public PaginationMetadata GetMetadataObjects(int? offset = default(int?), int? count = default(int?), string search = default(string))
        {
            Elements.Client.ApiResponse<PaginationMetadata> localVarResponse = GetMetadataObjectsWithHttpInfo(offset, count, search);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search Metadata Searches all metadata in the system and returning all matches against the given search filter.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationMetadata</returns>
        public Elements.Client.ApiResponse<PaginationMetadata> GetMetadataObjectsWithHttpInfo(int? offset = default(int?), int? count = default(int?), string search = default(string))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationMetadata>("/metadata", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMetadataObjects", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search Metadata Searches all metadata in the system and returning all matches against the given search filter.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationMetadata</returns>
        public async System.Threading.Tasks.Task<PaginationMetadata> GetMetadataObjectsAsync(int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetMetadataObjectsWithHttpInfoAsync(offset, count, search, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationMetadata> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationMetadata> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search Metadata Searches all metadata in the system and returning all matches against the given search filter.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationMetadata)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationMetadata>> GetMetadataObjectsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationMetadata>("/metadata", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMetadataObjects", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a specific Metadata Spec Gets a specific MetadataSpec by name or Id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecNameOrId"></param>
        /// <returns>MetadataSpec</returns>
        public MetadataSpec GetMetadataSpec(string metadataSpecNameOrId)
        {
            Elements.Client.ApiResponse<MetadataSpec> localVarResponse = GetMetadataSpecWithHttpInfo(metadataSpecNameOrId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a specific Metadata Spec Gets a specific MetadataSpec by name or Id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecNameOrId"></param>
        /// <returns>ApiResponse of MetadataSpec</returns>
        public Elements.Client.ApiResponse<MetadataSpec> GetMetadataSpecWithHttpInfo(string metadataSpecNameOrId)
        {
            // verify the required parameter 'metadataSpecNameOrId' is set
            if (metadataSpecNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'metadataSpecNameOrId' when calling DefaultApi->GetMetadataSpec");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("metadataSpecNameOrId", Elements.Client.ClientUtils.ParameterToString(metadataSpecNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<MetadataSpec>("/metadata_spec/{metadataSpecNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMetadataSpec", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a specific Metadata Spec Gets a specific MetadataSpec by name or Id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MetadataSpec</returns>
        public async System.Threading.Tasks.Task<MetadataSpec> GetMetadataSpecAsync(string metadataSpecNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetMetadataSpecWithHttpInfoAsync(metadataSpecNameOrId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<MetadataSpec> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<MetadataSpec> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a specific Metadata Spec Gets a specific MetadataSpec by name or Id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MetadataSpec)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<MetadataSpec>> GetMetadataSpecWithHttpInfoAsync(string metadataSpecNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'metadataSpecNameOrId' is set
            if (metadataSpecNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'metadataSpecNameOrId' when calling DefaultApi->GetMetadataSpec");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("metadataSpecNameOrId", Elements.Client.ClientUtils.ParameterToString(metadataSpecNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<MetadataSpec>("/metadata_spec/{metadataSpecNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMetadataSpec", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Metadata Specs Gets a pagination of Metadata Specs for the given query.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <returns>PaginationMetadataSpec</returns>
        public PaginationMetadataSpec GetMetadataSpecs(int? offset = default(int?), int? count = default(int?))
        {
            Elements.Client.ApiResponse<PaginationMetadataSpec> localVarResponse = GetMetadataSpecsWithHttpInfo(offset, count);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Metadata Specs Gets a pagination of Metadata Specs for the given query.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <returns>ApiResponse of PaginationMetadataSpec</returns>
        public Elements.Client.ApiResponse<PaginationMetadataSpec> GetMetadataSpecsWithHttpInfo(int? offset = default(int?), int? count = default(int?))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationMetadataSpec>("/metadata_spec", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMetadataSpecs", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Metadata Specs Gets a pagination of Metadata Specs for the given query.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationMetadataSpec</returns>
        public async System.Threading.Tasks.Task<PaginationMetadataSpec> GetMetadataSpecsAsync(int? offset = default(int?), int? count = default(int?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetMetadataSpecsWithHttpInfoAsync(offset, count, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationMetadataSpec> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationMetadataSpec> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Metadata Specs Gets a pagination of Metadata Specs for the given query.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationMetadataSpec)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationMetadataSpec>> GetMetadataSpecsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationMetadataSpec>("/metadata_spec", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMetadataSpecs", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieves a single Mission by id or by name Looks up a mission by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="missionNameOrId"></param>
        /// <returns>Mission</returns>
        public Mission GetMissionByNameOrId(string missionNameOrId)
        {
            Elements.Client.ApiResponse<Mission> localVarResponse = GetMissionByNameOrIdWithHttpInfo(missionNameOrId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieves a single Mission by id or by name Looks up a mission by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="missionNameOrId"></param>
        /// <returns>ApiResponse of Mission</returns>
        public Elements.Client.ApiResponse<Mission> GetMissionByNameOrIdWithHttpInfo(string missionNameOrId)
        {
            // verify the required parameter 'missionNameOrId' is set
            if (missionNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'missionNameOrId' when calling DefaultApi->GetMissionByNameOrId");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("missionNameOrId", Elements.Client.ClientUtils.ParameterToString(missionNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Mission>("/mission/{missionNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMissionByNameOrId", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieves a single Mission by id or by name Looks up a mission by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="missionNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Mission</returns>
        public async System.Threading.Tasks.Task<Mission> GetMissionByNameOrIdAsync(string missionNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetMissionByNameOrIdWithHttpInfoAsync(missionNameOrId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Mission> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Mission> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieves a single Mission by id or by name Looks up a mission by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="missionNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Mission)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Mission>> GetMissionByNameOrIdWithHttpInfoAsync(string missionNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'missionNameOrId' is set
            if (missionNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'missionNameOrId' when calling DefaultApi->GetMissionByNameOrId");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("missionNameOrId", Elements.Client.ClientUtils.ParameterToString(missionNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<Mission>("/mission/{missionNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMissionByNameOrId", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search Missions Searches all missions in the system and returning a number of matches against the given search filter, delimited by the offset and count.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationMission</returns>
        public PaginationMission GetMissions(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string search = default(string))
        {
            Elements.Client.ApiResponse<PaginationMission> localVarResponse = GetMissionsWithHttpInfo(offset, count, tags, search);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search Missions Searches all missions in the system and returning a number of matches against the given search filter, delimited by the offset and count.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationMission</returns>
        public Elements.Client.ApiResponse<PaginationMission> GetMissionsWithHttpInfo(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string search = default(string))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (tags != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("multi", "tags", tags));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationMission>("/mission", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMissions", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search Missions Searches all missions in the system and returning a number of matches against the given search filter, delimited by the offset and count.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationMission</returns>
        public async System.Threading.Tasks.Task<PaginationMission> GetMissionsAsync(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetMissionsWithHttpInfoAsync(offset, count, tags, search, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationMission> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationMission> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search Missions Searches all missions in the system and returning a number of matches against the given search filter, delimited by the offset and count.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationMission)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationMission>> GetMissionsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (tags != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("multi", "tags", tags));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationMission>("/mission", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMissions", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a PSN Application Configuration Gets a single PSN application based on unique name or ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>PSNApplicationConfiguration</returns>
        public PSNApplicationConfiguration GetPSNApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId)
        {
            Elements.Client.ApiResponse<PSNApplicationConfiguration> localVarResponse = GetPSNApplicationConfigurationWithHttpInfo(applicationNameOrId, applicationConfigurationNameOrId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a PSN Application Configuration Gets a single PSN application based on unique name or ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <returns>ApiResponse of PSNApplicationConfiguration</returns>
        public Elements.Client.ApiResponse<PSNApplicationConfiguration> GetPSNApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId)
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->GetPSNApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->GetPSNApplicationConfiguration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PSNApplicationConfiguration>("/application/{applicationNameOrId}/configuration/psn/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPSNApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a PSN Application Configuration Gets a single PSN application based on unique name or ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PSNApplicationConfiguration</returns>
        public async System.Threading.Tasks.Task<PSNApplicationConfiguration> GetPSNApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetPSNApplicationConfigurationWithHttpInfoAsync(applicationNameOrId, applicationConfigurationNameOrId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PSNApplicationConfiguration> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PSNApplicationConfiguration> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a PSN Application Configuration Gets a single PSN application based on unique name or ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PSNApplicationConfiguration)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PSNApplicationConfiguration>> GetPSNApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->GetPSNApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->GetPSNApplicationConfiguration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PSNApplicationConfiguration>("/application/{applicationNameOrId}/configuration/psn/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPSNApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets all index plans. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <returns>PaginationIndexPlanObject</returns>
        public PaginationIndexPlanObject GetPlans(int? offset = default(int?), int? count = default(int?))
        {
            Elements.Client.ApiResponse<PaginationIndexPlanObject> localVarResponse = GetPlansWithHttpInfo(offset, count);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets all index plans. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <returns>ApiResponse of PaginationIndexPlanObject</returns>
        public Elements.Client.ApiResponse<PaginationIndexPlanObject> GetPlansWithHttpInfo(int? offset = default(int?), int? count = default(int?))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationIndexPlanObject>("/index/plan", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPlans", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets all index plans. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationIndexPlanObject</returns>
        public async System.Threading.Tasks.Task<PaginationIndexPlanObject> GetPlansAsync(int? offset = default(int?), int? count = default(int?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetPlansWithHttpInfoAsync(offset, count, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationIndexPlanObject> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationIndexPlanObject> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets all index plans. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationIndexPlanObject)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationIndexPlanObject>> GetPlansWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationIndexPlanObject>("/index/plan", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPlans", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a Specific Profile Gets a specific profile by profile ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <returns>Profile</returns>
        public Profile GetProfile(string name)
        {
            Elements.Client.ApiResponse<Profile> localVarResponse = GetProfileWithHttpInfo(name);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a Specific Profile Gets a specific profile by profile ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <returns>ApiResponse of Profile</returns>
        public Elements.Client.ApiResponse<Profile> GetProfileWithHttpInfo(string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'name' when calling DefaultApi->GetProfile");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("name", Elements.Client.ClientUtils.ParameterToString(name)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Profile>("/profile/{name}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProfile", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a Specific Profile Gets a specific profile by profile ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Profile</returns>
        public async System.Threading.Tasks.Task<Profile> GetProfileAsync(string name, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetProfileWithHttpInfoAsync(name, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Profile> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Profile> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a Specific Profile Gets a specific profile by profile ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Profile)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Profile>> GetProfileWithHttpInfoAsync(string name, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'name' when calling DefaultApi->GetProfile");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("name", Elements.Client.ClientUtils.ParameterToString(name)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<Profile>("/profile/{name}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProfile", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get save data document. Gets a single save data document based on Profile ID and slot. This is a convenience method whichallows the client to fetch a save data based on slot an profile id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="slot"></param>
        /// <returns>SaveDataDocument</returns>
        public SaveDataDocument GetProfileSaveDataDocumentBySlot(string profileId, int slot)
        {
            Elements.Client.ApiResponse<SaveDataDocument> localVarResponse = GetProfileSaveDataDocumentBySlotWithHttpInfo(profileId, slot);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get save data document. Gets a single save data document based on Profile ID and slot. This is a convenience method whichallows the client to fetch a save data based on slot an profile id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="slot"></param>
        /// <returns>ApiResponse of SaveDataDocument</returns>
        public Elements.Client.ApiResponse<SaveDataDocument> GetProfileSaveDataDocumentBySlotWithHttpInfo(string profileId, int slot)
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'profileId' when calling DefaultApi->GetProfileSaveDataDocumentBySlot");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("profileId", Elements.Client.ClientUtils.ParameterToString(profileId)); // path parameter
            localVarRequestOptions.PathParameters.Add("slot", Elements.Client.ClientUtils.ParameterToString(slot)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<SaveDataDocument>("/save_data/profile/{profileId}/{slot}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProfileSaveDataDocumentBySlot", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get save data document. Gets a single save data document based on Profile ID and slot. This is a convenience method whichallows the client to fetch a save data based on slot an profile id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="slot"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SaveDataDocument</returns>
        public async System.Threading.Tasks.Task<SaveDataDocument> GetProfileSaveDataDocumentBySlotAsync(string profileId, int slot, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetProfileSaveDataDocumentBySlotWithHttpInfoAsync(profileId, slot, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<SaveDataDocument> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<SaveDataDocument> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get save data document. Gets a single save data document based on Profile ID and slot. This is a convenience method whichallows the client to fetch a save data based on slot an profile id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="slot"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SaveDataDocument)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<SaveDataDocument>> GetProfileSaveDataDocumentBySlotWithHttpInfoAsync(string profileId, int slot, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'profileId' when calling DefaultApi->GetProfileSaveDataDocumentBySlot");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("profileId", Elements.Client.ClientUtils.ParameterToString(profileId)); // path parameter
            localVarRequestOptions.PathParameters.Add("slot", Elements.Client.ClientUtils.ParameterToString(slot)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<SaveDataDocument>("/save_data/profile/{profileId}/{slot}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProfileSaveDataDocumentBySlot", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search Profiles Searches all users in the system and returning the metadata for all matches against the given search filter. Optionally provide &#x60;before&#x60; and &#x60;after&#x60; params to specify a time range [&#x60;after&#x60;, &#x60;before&#x60;] for last-logged-in profiles matching in that range (inclusive). If &#x60;before&#x60; is not specified (or a negative number is provided) but &#x60;after&#x60; is valid, the query will return all records successive to the given &#x60;after&#x60; timestamp. Similarly, if &#x60;after&#x60; is not specified (or a negative number is provided) but &#x60;before&#x60; is valid, the query will return all records preceding the given &#x60;before&#x60; timestamp. Note that search and time range parameters currently cannot be combined in the same query.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="before"> (optional)</param>
        /// <param name="after"> (optional)</param>
        /// <param name="application"> (optional)</param>
        /// <param name="user"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationProfile</returns>
        public PaginationProfile GetProfiles(int? offset = default(int?), int? count = default(int?), long? before = default(long?), long? after = default(long?), string application = default(string), string user = default(string), string search = default(string))
        {
            Elements.Client.ApiResponse<PaginationProfile> localVarResponse = GetProfilesWithHttpInfo(offset, count, before, after, application, user, search);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search Profiles Searches all users in the system and returning the metadata for all matches against the given search filter. Optionally provide &#x60;before&#x60; and &#x60;after&#x60; params to specify a time range [&#x60;after&#x60;, &#x60;before&#x60;] for last-logged-in profiles matching in that range (inclusive). If &#x60;before&#x60; is not specified (or a negative number is provided) but &#x60;after&#x60; is valid, the query will return all records successive to the given &#x60;after&#x60; timestamp. Similarly, if &#x60;after&#x60; is not specified (or a negative number is provided) but &#x60;before&#x60; is valid, the query will return all records preceding the given &#x60;before&#x60; timestamp. Note that search and time range parameters currently cannot be combined in the same query.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="before"> (optional)</param>
        /// <param name="after"> (optional)</param>
        /// <param name="application"> (optional)</param>
        /// <param name="user"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationProfile</returns>
        public Elements.Client.ApiResponse<PaginationProfile> GetProfilesWithHttpInfo(int? offset = default(int?), int? count = default(int?), long? before = default(long?), long? after = default(long?), string application = default(string), string user = default(string), string search = default(string))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (after != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "after", after));
            }
            if (application != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "application", application));
            }
            if (user != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "user", user));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationProfile>("/profile", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProfiles", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search Profiles Searches all users in the system and returning the metadata for all matches against the given search filter. Optionally provide &#x60;before&#x60; and &#x60;after&#x60; params to specify a time range [&#x60;after&#x60;, &#x60;before&#x60;] for last-logged-in profiles matching in that range (inclusive). If &#x60;before&#x60; is not specified (or a negative number is provided) but &#x60;after&#x60; is valid, the query will return all records successive to the given &#x60;after&#x60; timestamp. Similarly, if &#x60;after&#x60; is not specified (or a negative number is provided) but &#x60;before&#x60; is valid, the query will return all records preceding the given &#x60;before&#x60; timestamp. Note that search and time range parameters currently cannot be combined in the same query.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="before"> (optional)</param>
        /// <param name="after"> (optional)</param>
        /// <param name="application"> (optional)</param>
        /// <param name="user"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationProfile</returns>
        public async System.Threading.Tasks.Task<PaginationProfile> GetProfilesAsync(int? offset = default(int?), int? count = default(int?), long? before = default(long?), long? after = default(long?), string application = default(string), string user = default(string), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetProfilesWithHttpInfoAsync(offset, count, before, after, application, user, search, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationProfile> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationProfile> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search Profiles Searches all users in the system and returning the metadata for all matches against the given search filter. Optionally provide &#x60;before&#x60; and &#x60;after&#x60; params to specify a time range [&#x60;after&#x60;, &#x60;before&#x60;] for last-logged-in profiles matching in that range (inclusive). If &#x60;before&#x60; is not specified (or a negative number is provided) but &#x60;after&#x60; is valid, the query will return all records successive to the given &#x60;after&#x60; timestamp. Similarly, if &#x60;after&#x60; is not specified (or a negative number is provided) but &#x60;before&#x60; is valid, the query will return all records preceding the given &#x60;before&#x60; timestamp. Note that search and time range parameters currently cannot be combined in the same query.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="before"> (optional)</param>
        /// <param name="after"> (optional)</param>
        /// <param name="application"> (optional)</param>
        /// <param name="user"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationProfile)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationProfile>> GetProfilesWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), long? before = default(long?), long? after = default(long?), string application = default(string), string user = default(string), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (after != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "after", after));
            }
            if (application != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "application", application));
            }
            if (user != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "user", user));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationProfile>("/profile", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProfiles", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieves a single Progress by id Looks up a progress by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progressId"></param>
        /// <returns>Progress</returns>
        public Progress GetProgressByNameOrId(string progressId)
        {
            Elements.Client.ApiResponse<Progress> localVarResponse = GetProgressByNameOrIdWithHttpInfo(progressId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieves a single Progress by id Looks up a progress by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progressId"></param>
        /// <returns>ApiResponse of Progress</returns>
        public Elements.Client.ApiResponse<Progress> GetProgressByNameOrIdWithHttpInfo(string progressId)
        {
            // verify the required parameter 'progressId' is set
            if (progressId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'progressId' when calling DefaultApi->GetProgressByNameOrId");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("progressId", Elements.Client.ClientUtils.ParameterToString(progressId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Progress>("/progress/{progressId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProgressByNameOrId", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieves a single Progress by id Looks up a progress by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progressId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Progress</returns>
        public async System.Threading.Tasks.Task<Progress> GetProgressByNameOrIdAsync(string progressId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetProgressByNameOrIdWithHttpInfoAsync(progressId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Progress> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Progress> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieves a single Progress by id Looks up a progress by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progressId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Progress)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Progress>> GetProgressByNameOrIdWithHttpInfoAsync(string progressId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'progressId' is set
            if (progressId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'progressId' when calling DefaultApi->GetProgressByNameOrId");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("progressId", Elements.Client.ClientUtils.ParameterToString(progressId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<Progress>("/progress/{progressId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProgressByNameOrId", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets Rank Among all Players Gets the current Profile&#39;s rank among all players for the particular leaderboard.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>TabulationProgressRow</returns>
        public TabulationProgressRow GetProgressTabular()
        {
            Elements.Client.ApiResponse<TabulationProgressRow> localVarResponse = GetProgressTabularWithHttpInfo();
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets Rank Among all Players Gets the current Profile&#39;s rank among all players for the particular leaderboard.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of TabulationProgressRow</returns>
        public Elements.Client.ApiResponse<TabulationProgressRow> GetProgressTabularWithHttpInfo()
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/csv",
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<TabulationProgressRow>("/progress", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProgressTabular", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets Rank Among all Players Gets the current Profile&#39;s rank among all players for the particular leaderboard.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TabulationProgressRow</returns>
        public async System.Threading.Tasks.Task<TabulationProgressRow> GetProgressTabularAsync(System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetProgressTabularWithHttpInfoAsync(cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<TabulationProgressRow> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<TabulationProgressRow> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets Rank Among all Players Gets the current Profile&#39;s rank among all players for the particular leaderboard.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TabulationProgressRow)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<TabulationProgressRow>> GetProgressTabularWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/csv",
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<TabulationProgressRow>("/progress", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProgressTabular", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets Rank among Friends Gets the current Profile&#39;s rank among friends for the particular leaderboard.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">Specifies the leaderboard name or ID.</param>
        /// <param name="offset">May be negative to place the requested player in the middle of the page. (optional)</param>
        /// <param name="count">The number of results to return in the page. (optional)</param>
        /// <param name="relative">Indicates whether or not to fetch results in a relative fashion. (optional)</param>
        /// <param name="leaderboardEpoch">Specifies the epoch for the leaderboard. If no value is provided, the current epoch will befetched. (optional)</param>
        /// <returns>PaginationRank</returns>
        public PaginationRank GetRankAmongFriends(string leaderboardNameOrId, int? offset = default(int?), int? count = default(int?), bool? relative = default(bool?), long? leaderboardEpoch = default(long?))
        {
            Elements.Client.ApiResponse<PaginationRank> localVarResponse = GetRankAmongFriendsWithHttpInfo(leaderboardNameOrId, offset, count, relative, leaderboardEpoch);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets Rank among Friends Gets the current Profile&#39;s rank among friends for the particular leaderboard.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">Specifies the leaderboard name or ID.</param>
        /// <param name="offset">May be negative to place the requested player in the middle of the page. (optional)</param>
        /// <param name="count">The number of results to return in the page. (optional)</param>
        /// <param name="relative">Indicates whether or not to fetch results in a relative fashion. (optional)</param>
        /// <param name="leaderboardEpoch">Specifies the epoch for the leaderboard. If no value is provided, the current epoch will befetched. (optional)</param>
        /// <returns>ApiResponse of PaginationRank</returns>
        public Elements.Client.ApiResponse<PaginationRank> GetRankAmongFriendsWithHttpInfo(string leaderboardNameOrId, int? offset = default(int?), int? count = default(int?), bool? relative = default(bool?), long? leaderboardEpoch = default(long?))
        {
            // verify the required parameter 'leaderboardNameOrId' is set
            if (leaderboardNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'leaderboardNameOrId' when calling DefaultApi->GetRankAmongFriends");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("leaderboardNameOrId", Elements.Client.ClientUtils.ParameterToString(leaderboardNameOrId)); // path parameter
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (relative != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "relative", relative));
            }
            if (leaderboardEpoch != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "leaderboardEpoch", leaderboardEpoch));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationRank>("/rank/friends/{leaderboardNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRankAmongFriends", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets Rank among Friends Gets the current Profile&#39;s rank among friends for the particular leaderboard.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">Specifies the leaderboard name or ID.</param>
        /// <param name="offset">May be negative to place the requested player in the middle of the page. (optional)</param>
        /// <param name="count">The number of results to return in the page. (optional)</param>
        /// <param name="relative">Indicates whether or not to fetch results in a relative fashion. (optional)</param>
        /// <param name="leaderboardEpoch">Specifies the epoch for the leaderboard. If no value is provided, the current epoch will befetched. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationRank</returns>
        public async System.Threading.Tasks.Task<PaginationRank> GetRankAmongFriendsAsync(string leaderboardNameOrId, int? offset = default(int?), int? count = default(int?), bool? relative = default(bool?), long? leaderboardEpoch = default(long?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetRankAmongFriendsWithHttpInfoAsync(leaderboardNameOrId, offset, count, relative, leaderboardEpoch, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationRank> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationRank> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets Rank among Friends Gets the current Profile&#39;s rank among friends for the particular leaderboard.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">Specifies the leaderboard name or ID.</param>
        /// <param name="offset">May be negative to place the requested player in the middle of the page. (optional)</param>
        /// <param name="count">The number of results to return in the page. (optional)</param>
        /// <param name="relative">Indicates whether or not to fetch results in a relative fashion. (optional)</param>
        /// <param name="leaderboardEpoch">Specifies the epoch for the leaderboard. If no value is provided, the current epoch will befetched. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationRank)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationRank>> GetRankAmongFriendsWithHttpInfoAsync(string leaderboardNameOrId, int? offset = default(int?), int? count = default(int?), bool? relative = default(bool?), long? leaderboardEpoch = default(long?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'leaderboardNameOrId' is set
            if (leaderboardNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'leaderboardNameOrId' when calling DefaultApi->GetRankAmongFriends");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("leaderboardNameOrId", Elements.Client.ClientUtils.ParameterToString(leaderboardNameOrId)); // path parameter
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (relative != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "relative", relative));
            }
            if (leaderboardEpoch != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "leaderboardEpoch", leaderboardEpoch));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationRank>("/rank/friends/{leaderboardNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRankAmongFriends", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets Rank among Mutual Followers Gets the current Profile&#39;s rank among mutual followers for the particular leaderboard.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">Specifies the leaderboard name or ID.</param>
        /// <param name="offset">May be negative to place the requested player in the middle of the page. (optional)</param>
        /// <param name="count">The number of results to return in the page. (optional)</param>
        /// <param name="relative">Indicates whether or not to fetch results in a relative fashion. (optional)</param>
        /// <param name="leaderboardEpoch">Specifies the epoch for the leaderboard. If no value is provided, the current epoch will befetched. (optional)</param>
        /// <returns>PaginationRank</returns>
        public PaginationRank GetRankAmongMutualFollowers(string leaderboardNameOrId, int? offset = default(int?), int? count = default(int?), bool? relative = default(bool?), long? leaderboardEpoch = default(long?))
        {
            Elements.Client.ApiResponse<PaginationRank> localVarResponse = GetRankAmongMutualFollowersWithHttpInfo(leaderboardNameOrId, offset, count, relative, leaderboardEpoch);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets Rank among Mutual Followers Gets the current Profile&#39;s rank among mutual followers for the particular leaderboard.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">Specifies the leaderboard name or ID.</param>
        /// <param name="offset">May be negative to place the requested player in the middle of the page. (optional)</param>
        /// <param name="count">The number of results to return in the page. (optional)</param>
        /// <param name="relative">Indicates whether or not to fetch results in a relative fashion. (optional)</param>
        /// <param name="leaderboardEpoch">Specifies the epoch for the leaderboard. If no value is provided, the current epoch will befetched. (optional)</param>
        /// <returns>ApiResponse of PaginationRank</returns>
        public Elements.Client.ApiResponse<PaginationRank> GetRankAmongMutualFollowersWithHttpInfo(string leaderboardNameOrId, int? offset = default(int?), int? count = default(int?), bool? relative = default(bool?), long? leaderboardEpoch = default(long?))
        {
            // verify the required parameter 'leaderboardNameOrId' is set
            if (leaderboardNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'leaderboardNameOrId' when calling DefaultApi->GetRankAmongMutualFollowers");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("leaderboardNameOrId", Elements.Client.ClientUtils.ParameterToString(leaderboardNameOrId)); // path parameter
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (relative != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "relative", relative));
            }
            if (leaderboardEpoch != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "leaderboardEpoch", leaderboardEpoch));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationRank>("/rank/mutual_followers/{leaderboardNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRankAmongMutualFollowers", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets Rank among Mutual Followers Gets the current Profile&#39;s rank among mutual followers for the particular leaderboard.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">Specifies the leaderboard name or ID.</param>
        /// <param name="offset">May be negative to place the requested player in the middle of the page. (optional)</param>
        /// <param name="count">The number of results to return in the page. (optional)</param>
        /// <param name="relative">Indicates whether or not to fetch results in a relative fashion. (optional)</param>
        /// <param name="leaderboardEpoch">Specifies the epoch for the leaderboard. If no value is provided, the current epoch will befetched. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationRank</returns>
        public async System.Threading.Tasks.Task<PaginationRank> GetRankAmongMutualFollowersAsync(string leaderboardNameOrId, int? offset = default(int?), int? count = default(int?), bool? relative = default(bool?), long? leaderboardEpoch = default(long?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetRankAmongMutualFollowersWithHttpInfoAsync(leaderboardNameOrId, offset, count, relative, leaderboardEpoch, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationRank> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationRank> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets Rank among Mutual Followers Gets the current Profile&#39;s rank among mutual followers for the particular leaderboard.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="leaderboardNameOrId">Specifies the leaderboard name or ID.</param>
        /// <param name="offset">May be negative to place the requested player in the middle of the page. (optional)</param>
        /// <param name="count">The number of results to return in the page. (optional)</param>
        /// <param name="relative">Indicates whether or not to fetch results in a relative fashion. (optional)</param>
        /// <param name="leaderboardEpoch">Specifies the epoch for the leaderboard. If no value is provided, the current epoch will befetched. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationRank)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationRank>> GetRankAmongMutualFollowersWithHttpInfoAsync(string leaderboardNameOrId, int? offset = default(int?), int? count = default(int?), bool? relative = default(bool?), long? leaderboardEpoch = default(long?), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'leaderboardNameOrId' is set
            if (leaderboardNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'leaderboardNameOrId' when calling DefaultApi->GetRankAmongMutualFollowers");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("leaderboardNameOrId", Elements.Client.ClientUtils.ParameterToString(leaderboardNameOrId)); // path parameter
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (relative != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "relative", relative));
            }
            if (leaderboardEpoch != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "leaderboardEpoch", leaderboardEpoch));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationRank>("/rank/mutual_followers/{leaderboardNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRankAmongMutualFollowers", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieves a single RewardIssuance by id. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rewardIssuanceId"></param>
        /// <returns>RewardIssuance</returns>
        public RewardIssuance GetRewardIssuance(string rewardIssuanceId)
        {
            Elements.Client.ApiResponse<RewardIssuance> localVarResponse = GetRewardIssuanceWithHttpInfo(rewardIssuanceId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieves a single RewardIssuance by id. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rewardIssuanceId"></param>
        /// <returns>ApiResponse of RewardIssuance</returns>
        public Elements.Client.ApiResponse<RewardIssuance> GetRewardIssuanceWithHttpInfo(string rewardIssuanceId)
        {
            // verify the required parameter 'rewardIssuanceId' is set
            if (rewardIssuanceId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'rewardIssuanceId' when calling DefaultApi->GetRewardIssuance");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("rewardIssuanceId", Elements.Client.ClientUtils.ParameterToString(rewardIssuanceId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<RewardIssuance>("/reward_issuance/{rewardIssuanceId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRewardIssuance", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieves a single RewardIssuance by id. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rewardIssuanceId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of RewardIssuance</returns>
        public async System.Threading.Tasks.Task<RewardIssuance> GetRewardIssuanceAsync(string rewardIssuanceId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetRewardIssuanceWithHttpInfoAsync(rewardIssuanceId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<RewardIssuance> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<RewardIssuance> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieves a single RewardIssuance by id. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rewardIssuanceId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (RewardIssuance)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<RewardIssuance>> GetRewardIssuanceWithHttpInfoAsync(string rewardIssuanceId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'rewardIssuanceId' is set
            if (rewardIssuanceId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'rewardIssuanceId' when calling DefaultApi->GetRewardIssuance");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("rewardIssuanceId", Elements.Client.ClientUtils.ParameterToString(rewardIssuanceId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<RewardIssuance>("/reward_issuance/{rewardIssuanceId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRewardIssuance", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieves the current user&#39;s reward issuances, optionally filtered by the given state. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="states"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <returns>PaginationRewardIssuance</returns>
        public PaginationRewardIssuance GetRewardIssuances(int? offset = default(int?), int? count = default(int?), List<string> states = default(List<string>), List<string> tags = default(List<string>))
        {
            Elements.Client.ApiResponse<PaginationRewardIssuance> localVarResponse = GetRewardIssuancesWithHttpInfo(offset, count, states, tags);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieves the current user&#39;s reward issuances, optionally filtered by the given state. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="states"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <returns>ApiResponse of PaginationRewardIssuance</returns>
        public Elements.Client.ApiResponse<PaginationRewardIssuance> GetRewardIssuancesWithHttpInfo(int? offset = default(int?), int? count = default(int?), List<string> states = default(List<string>), List<string> tags = default(List<string>))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (states != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("multi", "states", states));
            }
            if (tags != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("multi", "tags", tags));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationRewardIssuance>("/reward_issuance", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRewardIssuances", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieves the current user&#39;s reward issuances, optionally filtered by the given state. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="states"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationRewardIssuance</returns>
        public async System.Threading.Tasks.Task<PaginationRewardIssuance> GetRewardIssuancesAsync(int? offset = default(int?), int? count = default(int?), List<string> states = default(List<string>), List<string> tags = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetRewardIssuancesWithHttpInfoAsync(offset, count, states, tags, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationRewardIssuance> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationRewardIssuance> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieves the current user&#39;s reward issuances, optionally filtered by the given state. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="states"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationRewardIssuance)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationRewardIssuance>> GetRewardIssuancesWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), List<string> states = default(List<string>), List<string> tags = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (states != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("multi", "states", states));
            }
            if (tags != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("multi", "tags", tags));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationRewardIssuance>("/reward_issuance", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRewardIssuances", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get save data document. Gets a single save data document
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>SaveDataDocument</returns>
        public SaveDataDocument GetSaveDataDocument(string id)
        {
            Elements.Client.ApiResponse<SaveDataDocument> localVarResponse = GetSaveDataDocumentWithHttpInfo(id);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get save data document. Gets a single save data document
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>ApiResponse of SaveDataDocument</returns>
        public Elements.Client.ApiResponse<SaveDataDocument> GetSaveDataDocumentWithHttpInfo(string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'id' when calling DefaultApi->GetSaveDataDocument");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Elements.Client.ClientUtils.ParameterToString(id)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<SaveDataDocument>("/save_data/{id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSaveDataDocument", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get save data document. Gets a single save data document
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SaveDataDocument</returns>
        public async System.Threading.Tasks.Task<SaveDataDocument> GetSaveDataDocumentAsync(string id, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetSaveDataDocumentWithHttpInfoAsync(id, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<SaveDataDocument> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<SaveDataDocument> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get save data document. Gets a single save data document
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SaveDataDocument)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<SaveDataDocument>> GetSaveDataDocumentWithHttpInfoAsync(string id, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'id' when calling DefaultApi->GetSaveDataDocument");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Elements.Client.ClientUtils.ParameterToString(id)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<SaveDataDocument>("/save_data/{id}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSaveDataDocument", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search Save Data Documents Gets all save data documents available to the user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="profileId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationSaveDataDocument</returns>
        public PaginationSaveDataDocument GetSaveDataDocuments(int? offset = default(int?), int? count = default(int?), string userId = default(string), string profileId = default(string), string search = default(string))
        {
            Elements.Client.ApiResponse<PaginationSaveDataDocument> localVarResponse = GetSaveDataDocumentsWithHttpInfo(offset, count, userId, profileId, search);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search Save Data Documents Gets all save data documents available to the user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="profileId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationSaveDataDocument</returns>
        public Elements.Client.ApiResponse<PaginationSaveDataDocument> GetSaveDataDocumentsWithHttpInfo(int? offset = default(int?), int? count = default(int?), string userId = default(string), string profileId = default(string), string search = default(string))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (userId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "userId", userId));
            }
            if (profileId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationSaveDataDocument>("/save_data", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSaveDataDocuments", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search Save Data Documents Gets all save data documents available to the user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="profileId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationSaveDataDocument</returns>
        public async System.Threading.Tasks.Task<PaginationSaveDataDocument> GetSaveDataDocumentsAsync(int? offset = default(int?), int? count = default(int?), string userId = default(string), string profileId = default(string), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetSaveDataDocumentsWithHttpInfoAsync(offset, count, userId, profileId, search, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationSaveDataDocument> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationSaveDataDocument> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search Save Data Documents Gets all save data documents available to the user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="profileId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationSaveDataDocument)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationSaveDataDocument>> GetSaveDataDocumentsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), string userId = default(string), string profileId = default(string), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (userId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "userId", userId));
            }
            if (profileId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationSaveDataDocument>("/save_data", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSaveDataDocuments", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieves a single Schedule by id or by name Looks up a schedule by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <returns>Schedule</returns>
        public Schedule GetScheduleByNameOrId(string scheduleNameOrId)
        {
            Elements.Client.ApiResponse<Schedule> localVarResponse = GetScheduleByNameOrIdWithHttpInfo(scheduleNameOrId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieves a single Schedule by id or by name Looks up a schedule by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <returns>ApiResponse of Schedule</returns>
        public Elements.Client.ApiResponse<Schedule> GetScheduleByNameOrIdWithHttpInfo(string scheduleNameOrId)
        {
            // verify the required parameter 'scheduleNameOrId' is set
            if (scheduleNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'scheduleNameOrId' when calling DefaultApi->GetScheduleByNameOrId");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("scheduleNameOrId", Elements.Client.ClientUtils.ParameterToString(scheduleNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Schedule>("/schedule/{scheduleNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetScheduleByNameOrId", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieves a single Schedule by id or by name Looks up a schedule by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Schedule</returns>
        public async System.Threading.Tasks.Task<Schedule> GetScheduleByNameOrIdAsync(string scheduleNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetScheduleByNameOrIdWithHttpInfoAsync(scheduleNameOrId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Schedule> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Schedule> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieves a single Schedule by id or by name Looks up a schedule by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Schedule)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Schedule>> GetScheduleByNameOrIdWithHttpInfoAsync(string scheduleNameOrId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'scheduleNameOrId' is set
            if (scheduleNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'scheduleNameOrId' when calling DefaultApi->GetScheduleByNameOrId");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("scheduleNameOrId", Elements.Client.ClientUtils.ParameterToString(scheduleNameOrId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<Schedule>("/schedule/{scheduleNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetScheduleByNameOrId", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieves a single ScheduleEvent by id or by name Looks up a schedule by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="scheduleEventId"></param>
        /// <returns>ScheduleEvent</returns>
        public ScheduleEvent GetScheduleEventByNameOrId(string scheduleNameOrId, string scheduleEventId)
        {
            Elements.Client.ApiResponse<ScheduleEvent> localVarResponse = GetScheduleEventByNameOrIdWithHttpInfo(scheduleNameOrId, scheduleEventId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieves a single ScheduleEvent by id or by name Looks up a schedule by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="scheduleEventId"></param>
        /// <returns>ApiResponse of ScheduleEvent</returns>
        public Elements.Client.ApiResponse<ScheduleEvent> GetScheduleEventByNameOrIdWithHttpInfo(string scheduleNameOrId, string scheduleEventId)
        {
            // verify the required parameter 'scheduleNameOrId' is set
            if (scheduleNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'scheduleNameOrId' when calling DefaultApi->GetScheduleEventByNameOrId");

            // verify the required parameter 'scheduleEventId' is set
            if (scheduleEventId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'scheduleEventId' when calling DefaultApi->GetScheduleEventByNameOrId");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("scheduleNameOrId", Elements.Client.ClientUtils.ParameterToString(scheduleNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("scheduleEventId", Elements.Client.ClientUtils.ParameterToString(scheduleEventId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ScheduleEvent>("/schedule/{scheduleNameOrId}/event/{scheduleEventId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetScheduleEventByNameOrId", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieves a single ScheduleEvent by id or by name Looks up a schedule by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="scheduleEventId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ScheduleEvent</returns>
        public async System.Threading.Tasks.Task<ScheduleEvent> GetScheduleEventByNameOrIdAsync(string scheduleNameOrId, string scheduleEventId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetScheduleEventByNameOrIdWithHttpInfoAsync(scheduleNameOrId, scheduleEventId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<ScheduleEvent> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<ScheduleEvent> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieves a single ScheduleEvent by id or by name Looks up a schedule by the passed in identifier
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="scheduleEventId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ScheduleEvent)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<ScheduleEvent>> GetScheduleEventByNameOrIdWithHttpInfoAsync(string scheduleNameOrId, string scheduleEventId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'scheduleNameOrId' is set
            if (scheduleNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'scheduleNameOrId' when calling DefaultApi->GetScheduleEventByNameOrId");

            // verify the required parameter 'scheduleEventId' is set
            if (scheduleEventId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'scheduleEventId' when calling DefaultApi->GetScheduleEventByNameOrId");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("scheduleNameOrId", Elements.Client.ClientUtils.ParameterToString(scheduleNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("scheduleEventId", Elements.Client.ClientUtils.ParameterToString(scheduleEventId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<ScheduleEvent>("/schedule/{scheduleNameOrId}/event/{scheduleEventId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetScheduleEventByNameOrId", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search ScheduleEvents Searches all schedules in the system and returning a number of matches against the given search filter, delimited by the offset and count.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationScheduleEvent</returns>
        public PaginationScheduleEvent GetScheduleEvents(string scheduleNameOrId, int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string search = default(string))
        {
            Elements.Client.ApiResponse<PaginationScheduleEvent> localVarResponse = GetScheduleEventsWithHttpInfo(scheduleNameOrId, offset, count, tags, search);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search ScheduleEvents Searches all schedules in the system and returning a number of matches against the given search filter, delimited by the offset and count.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationScheduleEvent</returns>
        public Elements.Client.ApiResponse<PaginationScheduleEvent> GetScheduleEventsWithHttpInfo(string scheduleNameOrId, int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string search = default(string))
        {
            // verify the required parameter 'scheduleNameOrId' is set
            if (scheduleNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'scheduleNameOrId' when calling DefaultApi->GetScheduleEvents");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("scheduleNameOrId", Elements.Client.ClientUtils.ParameterToString(scheduleNameOrId)); // path parameter
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (tags != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("multi", "tags", tags));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationScheduleEvent>("/schedule/{scheduleNameOrId}/event", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetScheduleEvents", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search ScheduleEvents Searches all schedules in the system and returning a number of matches against the given search filter, delimited by the offset and count.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationScheduleEvent</returns>
        public async System.Threading.Tasks.Task<PaginationScheduleEvent> GetScheduleEventsAsync(string scheduleNameOrId, int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetScheduleEventsWithHttpInfoAsync(scheduleNameOrId, offset, count, tags, search, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationScheduleEvent> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationScheduleEvent> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search ScheduleEvents Searches all schedules in the system and returning a number of matches against the given search filter, delimited by the offset and count.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationScheduleEvent)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationScheduleEvent>> GetScheduleEventsWithHttpInfoAsync(string scheduleNameOrId, int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'scheduleNameOrId' is set
            if (scheduleNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'scheduleNameOrId' when calling DefaultApi->GetScheduleEvents");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("scheduleNameOrId", Elements.Client.ClientUtils.ParameterToString(scheduleNameOrId)); // path parameter
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (tags != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("multi", "tags", tags));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationScheduleEvent>("/schedule/{scheduleNameOrId}/event", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetScheduleEvents", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets all Progresses assigned via this schedule Fetches all current assignments to the currently logged-in profile.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <returns>PaginationProgress</returns>
        public PaginationProgress GetScheduleProgresses(string scheduleNameOrId, int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>))
        {
            Elements.Client.ApiResponse<PaginationProgress> localVarResponse = GetScheduleProgressesWithHttpInfo(scheduleNameOrId, offset, count, tags);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets all Progresses assigned via this schedule Fetches all current assignments to the currently logged-in profile.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <returns>ApiResponse of PaginationProgress</returns>
        public Elements.Client.ApiResponse<PaginationProgress> GetScheduleProgressesWithHttpInfo(string scheduleNameOrId, int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>))
        {
            // verify the required parameter 'scheduleNameOrId' is set
            if (scheduleNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'scheduleNameOrId' when calling DefaultApi->GetScheduleProgresses");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("scheduleNameOrId", Elements.Client.ClientUtils.ParameterToString(scheduleNameOrId)); // path parameter
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (tags != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("multi", "tags", tags));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationProgress>("/schedule/{scheduleNameOrId}/progress", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetScheduleProgresses", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets all Progresses assigned via this schedule Fetches all current assignments to the currently logged-in profile.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationProgress</returns>
        public async System.Threading.Tasks.Task<PaginationProgress> GetScheduleProgressesAsync(string scheduleNameOrId, int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetScheduleProgressesWithHttpInfoAsync(scheduleNameOrId, offset, count, tags, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationProgress> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationProgress> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets all Progresses assigned via this schedule Fetches all current assignments to the currently logged-in profile.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationProgress)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationProgress>> GetScheduleProgressesWithHttpInfoAsync(string scheduleNameOrId, int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'scheduleNameOrId' is set
            if (scheduleNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'scheduleNameOrId' when calling DefaultApi->GetScheduleProgresses");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("scheduleNameOrId", Elements.Client.ClientUtils.ParameterToString(scheduleNameOrId)); // path parameter
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (tags != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("multi", "tags", tags));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationProgress>("/schedule/{scheduleNameOrId}/progress", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetScheduleProgresses", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search Schedules Searches all schedules in the system and returning a number of matches against the given search filter, delimited by the offset and count.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationSchedule</returns>
        public PaginationSchedule GetSchedules(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string search = default(string))
        {
            Elements.Client.ApiResponse<PaginationSchedule> localVarResponse = GetSchedulesWithHttpInfo(offset, count, tags, search);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search Schedules Searches all schedules in the system and returning a number of matches against the given search filter, delimited by the offset and count.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationSchedule</returns>
        public Elements.Client.ApiResponse<PaginationSchedule> GetSchedulesWithHttpInfo(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string search = default(string))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (tags != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("multi", "tags", tags));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationSchedule>("/schedule", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSchedules", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search Schedules Searches all schedules in the system and returning a number of matches against the given search filter, delimited by the offset and count.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationSchedule</returns>
        public async System.Threading.Tasks.Task<PaginationSchedule> GetSchedulesAsync(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetSchedulesWithHttpInfoAsync(offset, count, tags, search, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationSchedule> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationSchedule> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search Schedules Searches all schedules in the system and returning a number of matches against the given search filter, delimited by the offset and count.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationSchedule)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationSchedule>> GetSchedulesWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), List<string> tags = default(List<string>), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (tags != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("multi", "tags", tags));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationSchedule>("/schedule", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSchedules", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Performs the health check. Performs the health check for the server. What this actually does is deployment and implementation specific. However, any successful response code should indicate that the service is capable of servicing requests. Any unsuccessful error codes should indicate that the instance has internal issues and should be taken offline.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>HealthStatus</returns>
        public HealthStatus GetServerHealth()
        {
            Elements.Client.ApiResponse<HealthStatus> localVarResponse = GetServerHealthWithHttpInfo();
            return localVarResponse.Data;
        }

        /// <summary>
        /// Performs the health check. Performs the health check for the server. What this actually does is deployment and implementation specific. However, any successful response code should indicate that the service is capable of servicing requests. Any unsuccessful error codes should indicate that the instance has internal issues and should be taken offline.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of HealthStatus</returns>
        public Elements.Client.ApiResponse<HealthStatus> GetServerHealthWithHttpInfo()
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<HealthStatus>("/health", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetServerHealth", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Performs the health check. Performs the health check for the server. What this actually does is deployment and implementation specific. However, any successful response code should indicate that the service is capable of servicing requests. Any unsuccessful error codes should indicate that the instance has internal issues and should be taken offline.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of HealthStatus</returns>
        public async System.Threading.Tasks.Task<HealthStatus> GetServerHealthAsync(System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetServerHealthWithHttpInfoAsync(cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<HealthStatus> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<HealthStatus> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Performs the health check. Performs the health check for the server. What this actually does is deployment and implementation specific. However, any successful response code should indicate that the service is capable of servicing requests. Any unsuccessful error codes should indicate that the instance has internal issues and should be taken offline.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (HealthStatus)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<HealthStatus>> GetServerHealthWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<HealthStatus>("/health", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetServerHealth", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets inventory item for the specified item Gets the first (primary) inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <returns>InventoryItem</returns>
        public InventoryItem GetSimpleInventoryItem(string inventoryItemId)
        {
            Elements.Client.ApiResponse<InventoryItem> localVarResponse = GetSimpleInventoryItemWithHttpInfo(inventoryItemId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets inventory item for the specified item Gets the first (primary) inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <returns>ApiResponse of InventoryItem</returns>
        public Elements.Client.ApiResponse<InventoryItem> GetSimpleInventoryItemWithHttpInfo(string inventoryItemId)
        {
            // verify the required parameter 'inventoryItemId' is set
            if (inventoryItemId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'inventoryItemId' when calling DefaultApi->GetSimpleInventoryItem");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("inventoryItemId", Elements.Client.ClientUtils.ParameterToString(inventoryItemId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<InventoryItem>("/inventory/simple/{inventoryItemId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSimpleInventoryItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets inventory item for the specified item Gets the first (primary) inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InventoryItem</returns>
        public async System.Threading.Tasks.Task<InventoryItem> GetSimpleInventoryItemAsync(string inventoryItemId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetSimpleInventoryItemWithHttpInfoAsync(inventoryItemId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<InventoryItem> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<InventoryItem> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets inventory item for the specified item Gets the first (primary) inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InventoryItem)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<InventoryItem>> GetSimpleInventoryItemWithHttpInfoAsync(string inventoryItemId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'inventoryItemId' is set
            if (inventoryItemId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'inventoryItemId' when calling DefaultApi->GetSimpleInventoryItem");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("inventoryItemId", Elements.Client.ClientUtils.ParameterToString(inventoryItemId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<InventoryItem>("/inventory/simple/{inventoryItemId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSimpleInventoryItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search inventory items Searches all inventory items in the system and returns the metadata for all matches against the given search filter.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationInventoryItem</returns>
        public PaginationInventoryItem GetSimpleInventoryItems(int? offset = default(int?), int? count = default(int?), string userId = default(string), string search = default(string))
        {
            Elements.Client.ApiResponse<PaginationInventoryItem> localVarResponse = GetSimpleInventoryItemsWithHttpInfo(offset, count, userId, search);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search inventory items Searches all inventory items in the system and returns the metadata for all matches against the given search filter.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationInventoryItem</returns>
        public Elements.Client.ApiResponse<PaginationInventoryItem> GetSimpleInventoryItemsWithHttpInfo(int? offset = default(int?), int? count = default(int?), string userId = default(string), string search = default(string))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (userId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "userId", userId));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationInventoryItem>("/inventory/simple", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSimpleInventoryItems", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search inventory items Searches all inventory items in the system and returns the metadata for all matches against the given search filter.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationInventoryItem</returns>
        public async System.Threading.Tasks.Task<PaginationInventoryItem> GetSimpleInventoryItemsAsync(int? offset = default(int?), int? count = default(int?), string userId = default(string), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetSimpleInventoryItemsWithHttpInfoAsync(offset, count, userId, search, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationInventoryItem> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationInventoryItem> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search inventory items Searches all inventory items in the system and returns the metadata for all matches against the given search filter.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationInventoryItem)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationInventoryItem>> GetSimpleInventoryItemsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), string userId = default(string), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (userId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "userId", userId));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationInventoryItem>("/inventory/simple", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSimpleInventoryItems", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a specific  Smart Contract Gets a specific  Smart Contract by contractId.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractId"></param>
        /// <returns>SmartContract</returns>
        public SmartContract GetSmartContract(string contractId)
        {
            Elements.Client.ApiResponse<SmartContract> localVarResponse = GetSmartContractWithHttpInfo(contractId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a specific  Smart Contract Gets a specific  Smart Contract by contractId.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractId"></param>
        /// <returns>ApiResponse of SmartContract</returns>
        public Elements.Client.ApiResponse<SmartContract> GetSmartContractWithHttpInfo(string contractId)
        {
            // verify the required parameter 'contractId' is set
            if (contractId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'contractId' when calling DefaultApi->GetSmartContract");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("contractId", Elements.Client.ClientUtils.ParameterToString(contractId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<SmartContract>("/blockchain/omni/smart_contract/{contractId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSmartContract", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a specific  Smart Contract Gets a specific  Smart Contract by contractId.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SmartContract</returns>
        public async System.Threading.Tasks.Task<SmartContract> GetSmartContractAsync(string contractId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetSmartContractWithHttpInfoAsync(contractId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<SmartContract> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<SmartContract> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a specific  Smart Contract Gets a specific  Smart Contract by contractId.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SmartContract)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<SmartContract>> GetSmartContractWithHttpInfoAsync(string contractId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'contractId' is set
            if (contractId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'contractId' when calling DefaultApi->GetSmartContract");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("contractId", Elements.Client.ClientUtils.ParameterToString(contractId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<SmartContract>("/blockchain/omni/smart_contract/{contractId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSmartContract", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets  contracts. Gets a pagination of  SmartContracts.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="api"> (optional)</param>
        /// <param name="network"> (optional)</param>
        /// <returns>PaginationSmartContract</returns>
        public PaginationSmartContract GetSmartContracts(int? offset = default(int?), int? count = default(int?), string api = default(string), List<string> network = default(List<string>))
        {
            Elements.Client.ApiResponse<PaginationSmartContract> localVarResponse = GetSmartContractsWithHttpInfo(offset, count, api, network);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets  contracts. Gets a pagination of  SmartContracts.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="api"> (optional)</param>
        /// <param name="network"> (optional)</param>
        /// <returns>ApiResponse of PaginationSmartContract</returns>
        public Elements.Client.ApiResponse<PaginationSmartContract> GetSmartContractsWithHttpInfo(int? offset = default(int?), int? count = default(int?), string api = default(string), List<string> network = default(List<string>))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (api != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "api", api));
            }
            if (network != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("multi", "network", network));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationSmartContract>("/blockchain/omni/smart_contract", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSmartContracts", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets  contracts. Gets a pagination of  SmartContracts.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="api"> (optional)</param>
        /// <param name="network"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationSmartContract</returns>
        public async System.Threading.Tasks.Task<PaginationSmartContract> GetSmartContractsAsync(int? offset = default(int?), int? count = default(int?), string api = default(string), List<string> network = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetSmartContractsWithHttpInfoAsync(offset, count, api, network, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationSmartContract> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationSmartContract> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets  contracts. Gets a pagination of  SmartContracts.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="api"> (optional)</param>
        /// <param name="network"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationSmartContract)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationSmartContract>> GetSmartContractsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), string api = default(string), List<string> network = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (api != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "api", api));
            }
            if (network != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("multi", "network", network));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationSmartContract>("/blockchain/omni/smart_contract", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSmartContracts", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a Specific User Gets a specific user by name, email, or unique user ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <returns>User</returns>
        public User GetUser(string name)
        {
            Elements.Client.ApiResponse<User> localVarResponse = GetUserWithHttpInfo(name);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a Specific User Gets a specific user by name, email, or unique user ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <returns>ApiResponse of User</returns>
        public Elements.Client.ApiResponse<User> GetUserWithHttpInfo(string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'name' when calling DefaultApi->GetUser");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("name", Elements.Client.ClientUtils.ParameterToString(name)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<User>("/user/{name}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetUser", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a Specific User Gets a specific user by name, email, or unique user ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of User</returns>
        public async System.Threading.Tasks.Task<User> GetUserAsync(string name, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetUserWithHttpInfoAsync(name, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<User> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<User> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a Specific User Gets a specific user by name, email, or unique user ID.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (User)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<User>> GetUserWithHttpInfoAsync(string name, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'name' when calling DefaultApi->GetUser");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("name", Elements.Client.ClientUtils.ParameterToString(name)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<User>("/user/{name}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetUser", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get save data document. Gets a single save data document based on UserID and slot. This is a convenience method whichallows the client to fetch a save data based on slot an user id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="slot"></param>
        /// <returns>SaveDataDocument</returns>
        public SaveDataDocument GetUserSaveDataDocumentBySlot(string userId, int slot)
        {
            Elements.Client.ApiResponse<SaveDataDocument> localVarResponse = GetUserSaveDataDocumentBySlotWithHttpInfo(userId, slot);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get save data document. Gets a single save data document based on UserID and slot. This is a convenience method whichallows the client to fetch a save data based on slot an user id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="slot"></param>
        /// <returns>ApiResponse of SaveDataDocument</returns>
        public Elements.Client.ApiResponse<SaveDataDocument> GetUserSaveDataDocumentBySlotWithHttpInfo(string userId, int slot)
        {
            // verify the required parameter 'userId' is set
            if (userId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'userId' when calling DefaultApi->GetUserSaveDataDocumentBySlot");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("userId", Elements.Client.ClientUtils.ParameterToString(userId)); // path parameter
            localVarRequestOptions.PathParameters.Add("slot", Elements.Client.ClientUtils.ParameterToString(slot)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<SaveDataDocument>("/save_data/user/{userId}/{slot}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetUserSaveDataDocumentBySlot", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get save data document. Gets a single save data document based on UserID and slot. This is a convenience method whichallows the client to fetch a save data based on slot an user id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="slot"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SaveDataDocument</returns>
        public async System.Threading.Tasks.Task<SaveDataDocument> GetUserSaveDataDocumentBySlotAsync(string userId, int slot, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetUserSaveDataDocumentBySlotWithHttpInfoAsync(userId, slot, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<SaveDataDocument> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<SaveDataDocument> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get save data document. Gets a single save data document based on UserID and slot. This is a convenience method whichallows the client to fetch a save data based on slot an user id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="slot"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SaveDataDocument)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<SaveDataDocument>> GetUserSaveDataDocumentBySlotWithHttpInfoAsync(string userId, int slot, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'userId' is set
            if (userId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'userId' when calling DefaultApi->GetUserSaveDataDocumentBySlot");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("userId", Elements.Client.ClientUtils.ParameterToString(userId)); // path parameter
            localVarRequestOptions.PathParameters.Add("slot", Elements.Client.ClientUtils.ParameterToString(slot)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<SaveDataDocument>("/save_data/user/{userId}/{slot}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetUserSaveDataDocumentBySlot", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search Users Searches all users in the system and returning the metadata for all matches against the given search filter.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>PaginationUser</returns>
        public PaginationUser GetUsers(int? offset = default(int?), int? count = default(int?), string search = default(string))
        {
            Elements.Client.ApiResponse<PaginationUser> localVarResponse = GetUsersWithHttpInfo(offset, count, search);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search Users Searches all users in the system and returning the metadata for all matches against the given search filter.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <returns>ApiResponse of PaginationUser</returns>
        public Elements.Client.ApiResponse<PaginationUser> GetUsersWithHttpInfo(int? offset = default(int?), int? count = default(int?), string search = default(string))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationUser>("/user", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetUsers", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search Users Searches all users in the system and returning the metadata for all matches against the given search filter.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationUser</returns>
        public async System.Threading.Tasks.Task<PaginationUser> GetUsersAsync(int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetUsersWithHttpInfoAsync(offset, count, search, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationUser> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationUser> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search Users Searches all users in the system and returning the metadata for all matches against the given search filter.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="search"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationUser)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationUser>> GetUsersWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), string search = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationUser>("/user", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetUsers", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a specific  Vault Gets a specific  Vault by Id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <returns>Vault</returns>
        public Vault GetVault(string vaultId)
        {
            Elements.Client.ApiResponse<Vault> localVarResponse = GetVaultWithHttpInfo(vaultId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a specific  Vault Gets a specific  Vault by Id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <returns>ApiResponse of Vault</returns>
        public Elements.Client.ApiResponse<Vault> GetVaultWithHttpInfo(string vaultId)
        {
            // verify the required parameter 'vaultId' is set
            if (vaultId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'vaultId' when calling DefaultApi->GetVault");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("vaultId", Elements.Client.ClientUtils.ParameterToString(vaultId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Vault>("/blockchain/omni/vault/{vaultId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetVault", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a specific  Vault Gets a specific  Vault by Id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Vault</returns>
        public async System.Threading.Tasks.Task<Vault> GetVaultAsync(string vaultId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetVaultWithHttpInfoAsync(vaultId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Vault> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Vault> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a specific  Vault Gets a specific  Vault by Id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Vault)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Vault>> GetVaultWithHttpInfoAsync(string vaultId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'vaultId' is set
            if (vaultId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'vaultId' when calling DefaultApi->GetVault");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("vaultId", Elements.Client.ClientUtils.ParameterToString(vaultId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<Vault>("/blockchain/omni/vault/{vaultId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetVault", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets  vaults. Optionally filtered for a specific user Gets a pagination of  Wallets. Optionally a user Id can be specified to filter for a given user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <returns>PaginationVault</returns>
        public PaginationVault GetVaults(int? offset = default(int?), int? count = default(int?), string userId = default(string))
        {
            Elements.Client.ApiResponse<PaginationVault> localVarResponse = GetVaultsWithHttpInfo(offset, count, userId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets  vaults. Optionally filtered for a specific user Gets a pagination of  Wallets. Optionally a user Id can be specified to filter for a given user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <returns>ApiResponse of PaginationVault</returns>
        public Elements.Client.ApiResponse<PaginationVault> GetVaultsWithHttpInfo(int? offset = default(int?), int? count = default(int?), string userId = default(string))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (userId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "userId", userId));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationVault>("/blockchain/omni/vault", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetVaults", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets  vaults. Optionally filtered for a specific user Gets a pagination of  Wallets. Optionally a user Id can be specified to filter for a given user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationVault</returns>
        public async System.Threading.Tasks.Task<PaginationVault> GetVaultsAsync(int? offset = default(int?), int? count = default(int?), string userId = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetVaultsWithHttpInfoAsync(offset, count, userId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationVault> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationVault> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets  vaults. Optionally filtered for a specific user Gets a pagination of  Wallets. Optionally a user Id can be specified to filter for a given user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationVault)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationVault>> GetVaultsWithHttpInfoAsync(int? offset = default(int?), int? count = default(int?), string userId = default(string), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (userId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "userId", userId));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationVault>("/blockchain/omni/vault", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetVaults", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Show Server Version Information Returns information about the current server version.  This should always return theversion metadata.  This information is only known in packaged releases.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ModelVersion</returns>
        public ModelVersion GetVersion()
        {
            Elements.Client.ApiResponse<ModelVersion> localVarResponse = GetVersionWithHttpInfo();
            return localVarResponse.Data;
        }

        /// <summary>
        /// Show Server Version Information Returns information about the current server version.  This should always return theversion metadata.  This information is only known in packaged releases.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of ModelVersion</returns>
        public Elements.Client.ApiResponse<ModelVersion> GetVersionWithHttpInfo()
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ModelVersion>("/version", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetVersion", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Show Server Version Information Returns information about the current server version.  This should always return theversion metadata.  This information is only known in packaged releases.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ModelVersion</returns>
        public async System.Threading.Tasks.Task<ModelVersion> GetVersionAsync(System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetVersionWithHttpInfoAsync(cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<ModelVersion> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<ModelVersion> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Show Server Version Information Returns information about the current server version.  This should always return theversion metadata.  This information is only known in packaged releases.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ModelVersion)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<ModelVersion>> GetVersionWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<ModelVersion>("/version", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetVersion", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a specific  Wallet Gets a specific  Wallet by Id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="walletId"></param>
        /// <returns>Wallet</returns>
        public Wallet GetWallet(string vaultId, string walletId)
        {
            Elements.Client.ApiResponse<Wallet> localVarResponse = GetWalletWithHttpInfo(vaultId, walletId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a specific  Wallet Gets a specific  Wallet by Id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="walletId"></param>
        /// <returns>ApiResponse of Wallet</returns>
        public Elements.Client.ApiResponse<Wallet> GetWalletWithHttpInfo(string vaultId, string walletId)
        {
            // verify the required parameter 'vaultId' is set
            if (vaultId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'vaultId' when calling DefaultApi->GetWallet");

            // verify the required parameter 'walletId' is set
            if (walletId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'walletId' when calling DefaultApi->GetWallet");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("vaultId", Elements.Client.ClientUtils.ParameterToString(vaultId)); // path parameter
            localVarRequestOptions.PathParameters.Add("walletId", Elements.Client.ClientUtils.ParameterToString(walletId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Wallet>("/blockchain/omni/vault/{vaultId}/wallet/{walletId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetWallet", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a specific  Wallet Gets a specific  Wallet by Id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="walletId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Wallet</returns>
        public async System.Threading.Tasks.Task<Wallet> GetWalletAsync(string vaultId, string walletId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetWalletWithHttpInfoAsync(vaultId, walletId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Wallet> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Wallet> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a specific  Wallet Gets a specific  Wallet by Id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="walletId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Wallet)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Wallet>> GetWalletWithHttpInfoAsync(string vaultId, string walletId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'vaultId' is set
            if (vaultId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'vaultId' when calling DefaultApi->GetWallet");

            // verify the required parameter 'walletId' is set
            if (walletId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'walletId' when calling DefaultApi->GetWallet");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("vaultId", Elements.Client.ClientUtils.ParameterToString(vaultId)); // path parameter
            localVarRequestOptions.PathParameters.Add("walletId", Elements.Client.ClientUtils.ParameterToString(walletId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<Wallet>("/blockchain/omni/vault/{vaultId}/wallet/{walletId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetWallet", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a specific  Wallet Gets a specific  Wallet by Id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="walletId"></param>
        /// <returns>Wallet</returns>
        public Wallet GetWallet1(string walletId)
        {
            Elements.Client.ApiResponse<Wallet> localVarResponse = GetWallet1WithHttpInfo(walletId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a specific  Wallet Gets a specific  Wallet by Id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="walletId"></param>
        /// <returns>ApiResponse of Wallet</returns>
        public Elements.Client.ApiResponse<Wallet> GetWallet1WithHttpInfo(string walletId)
        {
            // verify the required parameter 'walletId' is set
            if (walletId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'walletId' when calling DefaultApi->GetWallet1");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("walletId", Elements.Client.ClientUtils.ParameterToString(walletId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Wallet>("/blockchain/omni/wallet/{walletId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetWallet1", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets a specific  Wallet Gets a specific  Wallet by Id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="walletId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Wallet</returns>
        public async System.Threading.Tasks.Task<Wallet> GetWallet1Async(string walletId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetWallet1WithHttpInfoAsync(walletId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Wallet> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Wallet> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a specific  Wallet Gets a specific  Wallet by Id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="walletId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Wallet)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Wallet>> GetWallet1WithHttpInfoAsync(string walletId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'walletId' is set
            if (walletId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'walletId' when calling DefaultApi->GetWallet1");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("walletId", Elements.Client.ClientUtils.ParameterToString(walletId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<Wallet>("/blockchain/omni/wallet/{walletId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetWallet1", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets  wallets. Optionally filtered for a specific user Gets a pagination of  Wallets. Optionally a user Id can be specified to filter for a given user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="api"> (optional)</param>
        /// <param name="network"> (optional)</param>
        /// <returns>PaginationWallet</returns>
        public PaginationWallet GetWallets(string vaultId, int? offset = default(int?), int? count = default(int?), string userId = default(string), string api = default(string), List<string> network = default(List<string>))
        {
            Elements.Client.ApiResponse<PaginationWallet> localVarResponse = GetWalletsWithHttpInfo(vaultId, offset, count, userId, api, network);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets  wallets. Optionally filtered for a specific user Gets a pagination of  Wallets. Optionally a user Id can be specified to filter for a given user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="api"> (optional)</param>
        /// <param name="network"> (optional)</param>
        /// <returns>ApiResponse of PaginationWallet</returns>
        public Elements.Client.ApiResponse<PaginationWallet> GetWalletsWithHttpInfo(string vaultId, int? offset = default(int?), int? count = default(int?), string userId = default(string), string api = default(string), List<string> network = default(List<string>))
        {
            // verify the required parameter 'vaultId' is set
            if (vaultId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'vaultId' when calling DefaultApi->GetWallets");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("vaultId", Elements.Client.ClientUtils.ParameterToString(vaultId)); // path parameter
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (userId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "userId", userId));
            }
            if (api != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "api", api));
            }
            if (network != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("multi", "network", network));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PaginationWallet>("/blockchain/omni/vault/{vaultId}/wallet", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetWallets", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets  wallets. Optionally filtered for a specific user Gets a pagination of  Wallets. Optionally a user Id can be specified to filter for a given user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="api"> (optional)</param>
        /// <param name="network"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PaginationWallet</returns>
        public async System.Threading.Tasks.Task<PaginationWallet> GetWalletsAsync(string vaultId, int? offset = default(int?), int? count = default(int?), string userId = default(string), string api = default(string), List<string> network = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = GetWalletsWithHttpInfoAsync(vaultId, offset, count, userId, api, network, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PaginationWallet> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PaginationWallet> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets  wallets. Optionally filtered for a specific user Gets a pagination of  Wallets. Optionally a user Id can be specified to filter for a given user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="offset"> (optional)</param>
        /// <param name="count"> (optional)</param>
        /// <param name="userId"> (optional)</param>
        /// <param name="api"> (optional)</param>
        /// <param name="network"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PaginationWallet)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PaginationWallet>> GetWalletsWithHttpInfoAsync(string vaultId, int? offset = default(int?), int? count = default(int?), string userId = default(string), string api = default(string), List<string> network = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'vaultId' is set
            if (vaultId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'vaultId' when calling DefaultApi->GetWallets");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("vaultId", Elements.Client.ClientUtils.ParameterToString(vaultId)); // path parameter
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (userId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "userId", userId));
            }
            if (api != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("", "api", api));
            }
            if (network != null)
            {
                localVarRequestOptions.QueryParameters.Add(Elements.Client.ClientUtils.ParameterToMultiMap("multi", "network", network));
            }

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.GetAsync<PaginationWallet>("/blockchain/omni/vault/{vaultId}/wallet", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetWallets", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Redeems the RewardIssuance. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rewardIssuanceId"></param>
        /// <returns>RewardIssuanceRedemptionResult</returns>
        public RewardIssuanceRedemptionResult RedeemRewardIssuance(string rewardIssuanceId)
        {
            Elements.Client.ApiResponse<RewardIssuanceRedemptionResult> localVarResponse = RedeemRewardIssuanceWithHttpInfo(rewardIssuanceId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Redeems the RewardIssuance. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rewardIssuanceId"></param>
        /// <returns>ApiResponse of RewardIssuanceRedemptionResult</returns>
        public Elements.Client.ApiResponse<RewardIssuanceRedemptionResult> RedeemRewardIssuanceWithHttpInfo(string rewardIssuanceId)
        {
            // verify the required parameter 'rewardIssuanceId' is set
            if (rewardIssuanceId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'rewardIssuanceId' when calling DefaultApi->RedeemRewardIssuance");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("rewardIssuanceId", Elements.Client.ClientUtils.ParameterToString(rewardIssuanceId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<RewardIssuanceRedemptionResult>("/reward_issuance/{rewardIssuanceId}/redeem", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RedeemRewardIssuance", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Redeems the RewardIssuance. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rewardIssuanceId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of RewardIssuanceRedemptionResult</returns>
        public async System.Threading.Tasks.Task<RewardIssuanceRedemptionResult> RedeemRewardIssuanceAsync(string rewardIssuanceId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = RedeemRewardIssuanceWithHttpInfoAsync(rewardIssuanceId, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<RewardIssuanceRedemptionResult> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<RewardIssuanceRedemptionResult> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Redeems the RewardIssuance. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rewardIssuanceId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (RewardIssuanceRedemptionResult)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<RewardIssuanceRedemptionResult>> RedeemRewardIssuanceWithHttpInfoAsync(string rewardIssuanceId, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'rewardIssuanceId' is set
            if (rewardIssuanceId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'rewardIssuanceId' when calling DefaultApi->RedeemRewardIssuance");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("rewardIssuanceId", Elements.Client.ClientUtils.ParameterToString(rewardIssuanceId)); // path parameter

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<RewardIssuanceRedemptionResult>("/reward_issuance/{rewardIssuanceId}/redeem", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RedeemRewardIssuance", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Redeems the given list of RewardIssuances. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>List&lt;RewardIssuanceRedemptionResult&gt;</returns>
        public List<RewardIssuanceRedemptionResult> RedeemRewardIssuances(List<string> requestBody = default(List<string>))
        {
            Elements.Client.ApiResponse<List<RewardIssuanceRedemptionResult>> localVarResponse = RedeemRewardIssuancesWithHttpInfo(requestBody);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Redeems the given list of RewardIssuances. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestBody"> (optional)</param>
        /// <returns>ApiResponse of List&lt;RewardIssuanceRedemptionResult&gt;</returns>
        public Elements.Client.ApiResponse<List<RewardIssuanceRedemptionResult>> RedeemRewardIssuancesWithHttpInfo(List<string> requestBody = default(List<string>))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = requestBody;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<List<RewardIssuanceRedemptionResult>>("/reward_issuance/redeem", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RedeemRewardIssuances", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Redeems the given list of RewardIssuances. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;RewardIssuanceRedemptionResult&gt;</returns>
        public async System.Threading.Tasks.Task<List<RewardIssuanceRedemptionResult>> RedeemRewardIssuancesAsync(List<string> requestBody = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = RedeemRewardIssuancesWithHttpInfoAsync(requestBody, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<List<RewardIssuanceRedemptionResult>> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<List<RewardIssuanceRedemptionResult>> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Redeems the given list of RewardIssuances. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;RewardIssuanceRedemptionResult&gt;)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<List<RewardIssuanceRedemptionResult>>> RedeemRewardIssuancesWithHttpInfoAsync(List<string> requestBody = default(List<string>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = requestBody;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<List<RewardIssuanceRedemptionResult>>("/reward_issuance/redeem", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RedeemRewardIssuances", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Sign Up a User Supplying the user create request object, this will create a new user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userCreateRequest"> (optional)</param>
        /// <returns>UserCreateResponse</returns>
        public UserCreateResponse SignUpUser(UserCreateRequest userCreateRequest = default(UserCreateRequest))
        {
            Elements.Client.ApiResponse<UserCreateResponse> localVarResponse = SignUpUserWithHttpInfo(userCreateRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Sign Up a User Supplying the user create request object, this will create a new user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userCreateRequest"> (optional)</param>
        /// <returns>ApiResponse of UserCreateResponse</returns>
        public Elements.Client.ApiResponse<UserCreateResponse> SignUpUserWithHttpInfo(UserCreateRequest userCreateRequest = default(UserCreateRequest))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = userCreateRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<UserCreateResponse>("/signup", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignUpUser", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Sign Up a User Supplying the user create request object, this will create a new user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userCreateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UserCreateResponse</returns>
        public async System.Threading.Tasks.Task<UserCreateResponse> SignUpUserAsync(UserCreateRequest userCreateRequest = default(UserCreateRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = SignUpUserWithHttpInfoAsync(userCreateRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<UserCreateResponse> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<UserCreateResponse> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Sign Up a User Supplying the user create request object, this will create a new user.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userCreateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UserCreateResponse)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<UserCreateResponse>> SignUpUserWithHttpInfoAsync(UserCreateRequest userCreateRequest = default(UserCreateRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = userCreateRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<UserCreateResponse>("/signup", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignUpUser", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates an Application Performs an update to an existing application known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="updateApplicationRequest"> (optional)</param>
        /// <returns>Application</returns>
        public Application UpdateApplication(string nameOrId, UpdateApplicationRequest updateApplicationRequest = default(UpdateApplicationRequest))
        {
            Elements.Client.ApiResponse<Application> localVarResponse = UpdateApplicationWithHttpInfo(nameOrId, updateApplicationRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates an Application Performs an update to an existing application known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="updateApplicationRequest"> (optional)</param>
        /// <returns>ApiResponse of Application</returns>
        public Elements.Client.ApiResponse<Application> UpdateApplicationWithHttpInfo(string nameOrId, UpdateApplicationRequest updateApplicationRequest = default(UpdateApplicationRequest))
        {
            // verify the required parameter 'nameOrId' is set
            if (nameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'nameOrId' when calling DefaultApi->UpdateApplication");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("nameOrId", Elements.Client.ClientUtils.ParameterToString(nameOrId)); // path parameter
            localVarRequestOptions.Data = updateApplicationRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<Application>("/application/{nameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApplication", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates an Application Performs an update to an existing application known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="updateApplicationRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Application</returns>
        public async System.Threading.Tasks.Task<Application> UpdateApplicationAsync(string nameOrId, UpdateApplicationRequest updateApplicationRequest = default(UpdateApplicationRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateApplicationWithHttpInfoAsync(nameOrId, updateApplicationRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Application> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Application> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates an Application Performs an update to an existing application known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="updateApplicationRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Application)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Application>> UpdateApplicationWithHttpInfoAsync(string nameOrId, UpdateApplicationRequest updateApplicationRequest = default(UpdateApplicationRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'nameOrId' is set
            if (nameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'nameOrId' when calling DefaultApi->UpdateApplication");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("nameOrId", Elements.Client.ClientUtils.ParameterToString(nameOrId)); // path parameter
            localVarRequestOptions.Data = updateApplicationRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<Application>("/application/{nameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApplication", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates an Auth Scheme Updates an Auth Scheme with the specified data in the auth scheme request.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSchemeId"></param>
        /// <param name="updateAuthSchemeRequest"> (optional)</param>
        /// <returns>UpdateAuthSchemeResponse</returns>
        public UpdateAuthSchemeResponse UpdateAuthScheme(string authSchemeId, UpdateAuthSchemeRequest updateAuthSchemeRequest = default(UpdateAuthSchemeRequest))
        {
            Elements.Client.ApiResponse<UpdateAuthSchemeResponse> localVarResponse = UpdateAuthSchemeWithHttpInfo(authSchemeId, updateAuthSchemeRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates an Auth Scheme Updates an Auth Scheme with the specified data in the auth scheme request.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSchemeId"></param>
        /// <param name="updateAuthSchemeRequest"> (optional)</param>
        /// <returns>ApiResponse of UpdateAuthSchemeResponse</returns>
        public Elements.Client.ApiResponse<UpdateAuthSchemeResponse> UpdateAuthSchemeWithHttpInfo(string authSchemeId, UpdateAuthSchemeRequest updateAuthSchemeRequest = default(UpdateAuthSchemeRequest))
        {
            // verify the required parameter 'authSchemeId' is set
            if (authSchemeId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'authSchemeId' when calling DefaultApi->UpdateAuthScheme");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("authSchemeId", Elements.Client.ClientUtils.ParameterToString(authSchemeId)); // path parameter
            localVarRequestOptions.Data = updateAuthSchemeRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<UpdateAuthSchemeResponse>("/auth_scheme/custom/{authSchemeId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAuthScheme", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates an Auth Scheme Updates an Auth Scheme with the specified data in the auth scheme request.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSchemeId"></param>
        /// <param name="updateAuthSchemeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UpdateAuthSchemeResponse</returns>
        public async System.Threading.Tasks.Task<UpdateAuthSchemeResponse> UpdateAuthSchemeAsync(string authSchemeId, UpdateAuthSchemeRequest updateAuthSchemeRequest = default(UpdateAuthSchemeRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateAuthSchemeWithHttpInfoAsync(authSchemeId, updateAuthSchemeRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<UpdateAuthSchemeResponse> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<UpdateAuthSchemeResponse> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates an Auth Scheme Updates an Auth Scheme with the specified data in the auth scheme request.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSchemeId"></param>
        /// <param name="updateAuthSchemeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UpdateAuthSchemeResponse)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<UpdateAuthSchemeResponse>> UpdateAuthSchemeWithHttpInfoAsync(string authSchemeId, UpdateAuthSchemeRequest updateAuthSchemeRequest = default(UpdateAuthSchemeRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'authSchemeId' is set
            if (authSchemeId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'authSchemeId' when calling DefaultApi->UpdateAuthScheme");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("authSchemeId", Elements.Client.ClientUtils.ParameterToString(authSchemeId)); // path parameter
            localVarRequestOptions.Data = updateAuthSchemeRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<UpdateAuthSchemeResponse>("/auth_scheme/custom/{authSchemeId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAuthScheme", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates an Auth Scheme Updates an Auth Scheme with the specified data in the auth scheme request.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2AuthSchemeId"></param>
        /// <param name="createOrUpdateOAuth2AuthSchemeRequest"> (optional)</param>
        /// <returns>CreateOrUpdateOAuth2AuthSchemeResponse</returns>
        public CreateOrUpdateOAuth2AuthSchemeResponse UpdateAuthScheme1(string oAuth2AuthSchemeId, CreateOrUpdateOAuth2AuthSchemeRequest createOrUpdateOAuth2AuthSchemeRequest = default(CreateOrUpdateOAuth2AuthSchemeRequest))
        {
            Elements.Client.ApiResponse<CreateOrUpdateOAuth2AuthSchemeResponse> localVarResponse = UpdateAuthScheme1WithHttpInfo(oAuth2AuthSchemeId, createOrUpdateOAuth2AuthSchemeRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates an Auth Scheme Updates an Auth Scheme with the specified data in the auth scheme request.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2AuthSchemeId"></param>
        /// <param name="createOrUpdateOAuth2AuthSchemeRequest"> (optional)</param>
        /// <returns>ApiResponse of CreateOrUpdateOAuth2AuthSchemeResponse</returns>
        public Elements.Client.ApiResponse<CreateOrUpdateOAuth2AuthSchemeResponse> UpdateAuthScheme1WithHttpInfo(string oAuth2AuthSchemeId, CreateOrUpdateOAuth2AuthSchemeRequest createOrUpdateOAuth2AuthSchemeRequest = default(CreateOrUpdateOAuth2AuthSchemeRequest))
        {
            // verify the required parameter 'oAuth2AuthSchemeId' is set
            if (oAuth2AuthSchemeId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'oAuth2AuthSchemeId' when calling DefaultApi->UpdateAuthScheme1");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("oAuth2AuthSchemeId", Elements.Client.ClientUtils.ParameterToString(oAuth2AuthSchemeId)); // path parameter
            localVarRequestOptions.Data = createOrUpdateOAuth2AuthSchemeRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<CreateOrUpdateOAuth2AuthSchemeResponse>("/auth_scheme/oauth2/{oAuth2AuthSchemeId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAuthScheme1", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates an Auth Scheme Updates an Auth Scheme with the specified data in the auth scheme request.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2AuthSchemeId"></param>
        /// <param name="createOrUpdateOAuth2AuthSchemeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CreateOrUpdateOAuth2AuthSchemeResponse</returns>
        public async System.Threading.Tasks.Task<CreateOrUpdateOAuth2AuthSchemeResponse> UpdateAuthScheme1Async(string oAuth2AuthSchemeId, CreateOrUpdateOAuth2AuthSchemeRequest createOrUpdateOAuth2AuthSchemeRequest = default(CreateOrUpdateOAuth2AuthSchemeRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateAuthScheme1WithHttpInfoAsync(oAuth2AuthSchemeId, createOrUpdateOAuth2AuthSchemeRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<CreateOrUpdateOAuth2AuthSchemeResponse> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<CreateOrUpdateOAuth2AuthSchemeResponse> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates an Auth Scheme Updates an Auth Scheme with the specified data in the auth scheme request.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oAuth2AuthSchemeId"></param>
        /// <param name="createOrUpdateOAuth2AuthSchemeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CreateOrUpdateOAuth2AuthSchemeResponse)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<CreateOrUpdateOAuth2AuthSchemeResponse>> UpdateAuthScheme1WithHttpInfoAsync(string oAuth2AuthSchemeId, CreateOrUpdateOAuth2AuthSchemeRequest createOrUpdateOAuth2AuthSchemeRequest = default(CreateOrUpdateOAuth2AuthSchemeRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'oAuth2AuthSchemeId' is set
            if (oAuth2AuthSchemeId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'oAuth2AuthSchemeId' when calling DefaultApi->UpdateAuthScheme1");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("oAuth2AuthSchemeId", Elements.Client.ClientUtils.ParameterToString(oAuth2AuthSchemeId)); // path parameter
            localVarRequestOptions.Data = createOrUpdateOAuth2AuthSchemeRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<CreateOrUpdateOAuth2AuthSchemeResponse>("/auth_scheme/oauth2/{oAuth2AuthSchemeId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAuthScheme1", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates an Auth Scheme Updates an Auth Scheme with the specified data in the auth scheme request.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcAuthSchemeId"></param>
        /// <param name="createOrUpdateOidcAuthSchemeRequest"> (optional)</param>
        /// <returns>CreateOrUpdateOidcAuthSchemeResponse</returns>
        public CreateOrUpdateOidcAuthSchemeResponse UpdateAuthScheme2(string oidcAuthSchemeId, CreateOrUpdateOidcAuthSchemeRequest createOrUpdateOidcAuthSchemeRequest = default(CreateOrUpdateOidcAuthSchemeRequest))
        {
            Elements.Client.ApiResponse<CreateOrUpdateOidcAuthSchemeResponse> localVarResponse = UpdateAuthScheme2WithHttpInfo(oidcAuthSchemeId, createOrUpdateOidcAuthSchemeRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates an Auth Scheme Updates an Auth Scheme with the specified data in the auth scheme request.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcAuthSchemeId"></param>
        /// <param name="createOrUpdateOidcAuthSchemeRequest"> (optional)</param>
        /// <returns>ApiResponse of CreateOrUpdateOidcAuthSchemeResponse</returns>
        public Elements.Client.ApiResponse<CreateOrUpdateOidcAuthSchemeResponse> UpdateAuthScheme2WithHttpInfo(string oidcAuthSchemeId, CreateOrUpdateOidcAuthSchemeRequest createOrUpdateOidcAuthSchemeRequest = default(CreateOrUpdateOidcAuthSchemeRequest))
        {
            // verify the required parameter 'oidcAuthSchemeId' is set
            if (oidcAuthSchemeId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'oidcAuthSchemeId' when calling DefaultApi->UpdateAuthScheme2");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("oidcAuthSchemeId", Elements.Client.ClientUtils.ParameterToString(oidcAuthSchemeId)); // path parameter
            localVarRequestOptions.Data = createOrUpdateOidcAuthSchemeRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<CreateOrUpdateOidcAuthSchemeResponse>("/auth_scheme/oidc/{oidcAuthSchemeId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAuthScheme2", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates an Auth Scheme Updates an Auth Scheme with the specified data in the auth scheme request.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcAuthSchemeId"></param>
        /// <param name="createOrUpdateOidcAuthSchemeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CreateOrUpdateOidcAuthSchemeResponse</returns>
        public async System.Threading.Tasks.Task<CreateOrUpdateOidcAuthSchemeResponse> UpdateAuthScheme2Async(string oidcAuthSchemeId, CreateOrUpdateOidcAuthSchemeRequest createOrUpdateOidcAuthSchemeRequest = default(CreateOrUpdateOidcAuthSchemeRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateAuthScheme2WithHttpInfoAsync(oidcAuthSchemeId, createOrUpdateOidcAuthSchemeRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<CreateOrUpdateOidcAuthSchemeResponse> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<CreateOrUpdateOidcAuthSchemeResponse> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates an Auth Scheme Updates an Auth Scheme with the specified data in the auth scheme request.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcAuthSchemeId"></param>
        /// <param name="createOrUpdateOidcAuthSchemeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CreateOrUpdateOidcAuthSchemeResponse)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<CreateOrUpdateOidcAuthSchemeResponse>> UpdateAuthScheme2WithHttpInfoAsync(string oidcAuthSchemeId, CreateOrUpdateOidcAuthSchemeRequest createOrUpdateOidcAuthSchemeRequest = default(CreateOrUpdateOidcAuthSchemeRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'oidcAuthSchemeId' is set
            if (oidcAuthSchemeId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'oidcAuthSchemeId' when calling DefaultApi->UpdateAuthScheme2");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("oidcAuthSchemeId", Elements.Client.ClientUtils.ParameterToString(oidcAuthSchemeId)); // path parameter
            localVarRequestOptions.Data = createOrUpdateOidcAuthSchemeRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<CreateOrUpdateOidcAuthSchemeResponse>("/auth_scheme/oidc/{oidcAuthSchemeId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAuthScheme2", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="version"></param>
        /// <param name="updateDeploymentRequest"> (optional)</param>
        /// <returns>Deployment</returns>
        public Deployment UpdateDeployment(string applicationId, string version, UpdateDeploymentRequest updateDeploymentRequest = default(UpdateDeploymentRequest))
        {
            Elements.Client.ApiResponse<Deployment> localVarResponse = UpdateDeploymentWithHttpInfo(applicationId, version, updateDeploymentRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="version"></param>
        /// <param name="updateDeploymentRequest"> (optional)</param>
        /// <returns>ApiResponse of Deployment</returns>
        public Elements.Client.ApiResponse<Deployment> UpdateDeploymentWithHttpInfo(string applicationId, string version, UpdateDeploymentRequest updateDeploymentRequest = default(UpdateDeploymentRequest))
        {
            // verify the required parameter 'applicationId' is set
            if (applicationId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationId' when calling DefaultApi->UpdateDeployment");

            // verify the required parameter 'version' is set
            if (version == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'version' when calling DefaultApi->UpdateDeployment");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationId", Elements.Client.ClientUtils.ParameterToString(applicationId)); // path parameter
            localVarRequestOptions.PathParameters.Add("version", Elements.Client.ClientUtils.ParameterToString(version)); // path parameter
            localVarRequestOptions.Data = updateDeploymentRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<Deployment>("/deployment/{applicationId}/{version}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateDeployment", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="version"></param>
        /// <param name="updateDeploymentRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Deployment</returns>
        public async System.Threading.Tasks.Task<Deployment> UpdateDeploymentAsync(string applicationId, string version, UpdateDeploymentRequest updateDeploymentRequest = default(UpdateDeploymentRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateDeploymentWithHttpInfoAsync(applicationId, version, updateDeploymentRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Deployment> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Deployment> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationId"></param>
        /// <param name="version"></param>
        /// <param name="updateDeploymentRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Deployment)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Deployment>> UpdateDeploymentWithHttpInfoAsync(string applicationId, string version, UpdateDeploymentRequest updateDeploymentRequest = default(UpdateDeploymentRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationId' is set
            if (applicationId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationId' when calling DefaultApi->UpdateDeployment");

            // verify the required parameter 'version' is set
            if (version == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'version' when calling DefaultApi->UpdateDeployment");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationId", Elements.Client.ClientUtils.ParameterToString(applicationId)); // path parameter
            localVarRequestOptions.PathParameters.Add("version", Elements.Client.ClientUtils.ParameterToString(version)); // path parameter
            localVarRequestOptions.Data = updateDeploymentRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<Deployment>("/deployment/{applicationId}/{version}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateDeployment", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates an inventory item for the specified item Updates an inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="distinctInventoryItemId"></param>
        /// <param name="updateDistinctInventoryItemRequest"> (optional)</param>
        /// <returns>DistinctInventoryItem</returns>
        public DistinctInventoryItem UpdateDistinctInventoryItem(string distinctInventoryItemId, UpdateDistinctInventoryItemRequest updateDistinctInventoryItemRequest = default(UpdateDistinctInventoryItemRequest))
        {
            Elements.Client.ApiResponse<DistinctInventoryItem> localVarResponse = UpdateDistinctInventoryItemWithHttpInfo(distinctInventoryItemId, updateDistinctInventoryItemRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates an inventory item for the specified item Updates an inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="distinctInventoryItemId"></param>
        /// <param name="updateDistinctInventoryItemRequest"> (optional)</param>
        /// <returns>ApiResponse of DistinctInventoryItem</returns>
        public Elements.Client.ApiResponse<DistinctInventoryItem> UpdateDistinctInventoryItemWithHttpInfo(string distinctInventoryItemId, UpdateDistinctInventoryItemRequest updateDistinctInventoryItemRequest = default(UpdateDistinctInventoryItemRequest))
        {
            // verify the required parameter 'distinctInventoryItemId' is set
            if (distinctInventoryItemId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'distinctInventoryItemId' when calling DefaultApi->UpdateDistinctInventoryItem");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("distinctInventoryItemId", Elements.Client.ClientUtils.ParameterToString(distinctInventoryItemId)); // path parameter
            localVarRequestOptions.Data = updateDistinctInventoryItemRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<DistinctInventoryItem>("/inventory/distinct/{distinctInventoryItemId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateDistinctInventoryItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates an inventory item for the specified item Updates an inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="distinctInventoryItemId"></param>
        /// <param name="updateDistinctInventoryItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of DistinctInventoryItem</returns>
        public async System.Threading.Tasks.Task<DistinctInventoryItem> UpdateDistinctInventoryItemAsync(string distinctInventoryItemId, UpdateDistinctInventoryItemRequest updateDistinctInventoryItemRequest = default(UpdateDistinctInventoryItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateDistinctInventoryItemWithHttpInfoAsync(distinctInventoryItemId, updateDistinctInventoryItemRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<DistinctInventoryItem> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<DistinctInventoryItem> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates an inventory item for the specified item Updates an inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="distinctInventoryItemId"></param>
        /// <param name="updateDistinctInventoryItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (DistinctInventoryItem)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<DistinctInventoryItem>> UpdateDistinctInventoryItemWithHttpInfoAsync(string distinctInventoryItemId, UpdateDistinctInventoryItemRequest updateDistinctInventoryItemRequest = default(UpdateDistinctInventoryItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'distinctInventoryItemId' is set
            if (distinctInventoryItemId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'distinctInventoryItemId' when calling DefaultApi->UpdateDistinctInventoryItem");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("distinctInventoryItemId", Elements.Client.ClientUtils.ParameterToString(distinctInventoryItemId)); // path parameter
            localVarRequestOptions.Data = updateDistinctInventoryItemRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<DistinctInventoryItem>("/inventory/distinct/{distinctInventoryItemId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateDistinctInventoryItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a Facebook ApplicationConfiguration Updates an existing Facebook Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="facebookApplicationConfiguration"> (optional)</param>
        /// <returns>FacebookApplicationConfiguration</returns>
        public FacebookApplicationConfiguration UpdateFacebookApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId, FacebookApplicationConfiguration facebookApplicationConfiguration = default(FacebookApplicationConfiguration))
        {
            Elements.Client.ApiResponse<FacebookApplicationConfiguration> localVarResponse = UpdateFacebookApplicationConfigurationWithHttpInfo(applicationNameOrId, applicationConfigurationNameOrId, facebookApplicationConfiguration);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a Facebook ApplicationConfiguration Updates an existing Facebook Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="facebookApplicationConfiguration"> (optional)</param>
        /// <returns>ApiResponse of FacebookApplicationConfiguration</returns>
        public Elements.Client.ApiResponse<FacebookApplicationConfiguration> UpdateFacebookApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId, FacebookApplicationConfiguration facebookApplicationConfiguration = default(FacebookApplicationConfiguration))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->UpdateFacebookApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->UpdateFacebookApplicationConfiguration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter
            localVarRequestOptions.Data = facebookApplicationConfiguration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<FacebookApplicationConfiguration>("/application/{applicationNameOrId}/configuration/facebook/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateFacebookApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a Facebook ApplicationConfiguration Updates an existing Facebook Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="facebookApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FacebookApplicationConfiguration</returns>
        public async System.Threading.Tasks.Task<FacebookApplicationConfiguration> UpdateFacebookApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, FacebookApplicationConfiguration facebookApplicationConfiguration = default(FacebookApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateFacebookApplicationConfigurationWithHttpInfoAsync(applicationNameOrId, applicationConfigurationNameOrId, facebookApplicationConfiguration, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<FacebookApplicationConfiguration> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<FacebookApplicationConfiguration> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a Facebook ApplicationConfiguration Updates an existing Facebook Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="facebookApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FacebookApplicationConfiguration)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<FacebookApplicationConfiguration>> UpdateFacebookApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, FacebookApplicationConfiguration facebookApplicationConfiguration = default(FacebookApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->UpdateFacebookApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->UpdateFacebookApplicationConfiguration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter
            localVarRequestOptions.Data = facebookApplicationConfiguration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<FacebookApplicationConfiguration>("/application/{applicationNameOrId}/configuration/facebook/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateFacebookApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a Firebase ApplicationConfiguration Updates an existing Firebase Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="firebaseApplicationConfiguration"> (optional)</param>
        /// <returns>FirebaseApplicationConfiguration</returns>
        public FirebaseApplicationConfiguration UpdateFirebaseApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId, FirebaseApplicationConfiguration firebaseApplicationConfiguration = default(FirebaseApplicationConfiguration))
        {
            Elements.Client.ApiResponse<FirebaseApplicationConfiguration> localVarResponse = UpdateFirebaseApplicationConfigurationWithHttpInfo(applicationNameOrId, applicationConfigurationNameOrId, firebaseApplicationConfiguration);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a Firebase ApplicationConfiguration Updates an existing Firebase Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="firebaseApplicationConfiguration"> (optional)</param>
        /// <returns>ApiResponse of FirebaseApplicationConfiguration</returns>
        public Elements.Client.ApiResponse<FirebaseApplicationConfiguration> UpdateFirebaseApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId, FirebaseApplicationConfiguration firebaseApplicationConfiguration = default(FirebaseApplicationConfiguration))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->UpdateFirebaseApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->UpdateFirebaseApplicationConfiguration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter
            localVarRequestOptions.Data = firebaseApplicationConfiguration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<FirebaseApplicationConfiguration>("/application/{applicationNameOrId}/configuration/firebase/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateFirebaseApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a Firebase ApplicationConfiguration Updates an existing Firebase Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="firebaseApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FirebaseApplicationConfiguration</returns>
        public async System.Threading.Tasks.Task<FirebaseApplicationConfiguration> UpdateFirebaseApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, FirebaseApplicationConfiguration firebaseApplicationConfiguration = default(FirebaseApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateFirebaseApplicationConfigurationWithHttpInfoAsync(applicationNameOrId, applicationConfigurationNameOrId, firebaseApplicationConfiguration, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<FirebaseApplicationConfiguration> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<FirebaseApplicationConfiguration> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a Firebase ApplicationConfiguration Updates an existing Firebase Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="firebaseApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FirebaseApplicationConfiguration)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<FirebaseApplicationConfiguration>> UpdateFirebaseApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, FirebaseApplicationConfiguration firebaseApplicationConfiguration = default(FirebaseApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->UpdateFirebaseApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->UpdateFirebaseApplicationConfiguration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter
            localVarRequestOptions.Data = firebaseApplicationConfiguration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<FirebaseApplicationConfiguration>("/application/{applicationNameOrId}/configuration/firebase/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateFirebaseApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a Google Play ApplicationConfiguration Updates an existing Google Play Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="googlePlayApplicationConfiguration"> (optional)</param>
        /// <returns>GooglePlayApplicationConfiguration</returns>
        public GooglePlayApplicationConfiguration UpdateGooglePlayApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId, GooglePlayApplicationConfiguration googlePlayApplicationConfiguration = default(GooglePlayApplicationConfiguration))
        {
            Elements.Client.ApiResponse<GooglePlayApplicationConfiguration> localVarResponse = UpdateGooglePlayApplicationConfigurationWithHttpInfo(applicationNameOrId, applicationConfigurationNameOrId, googlePlayApplicationConfiguration);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a Google Play ApplicationConfiguration Updates an existing Google Play Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="googlePlayApplicationConfiguration"> (optional)</param>
        /// <returns>ApiResponse of GooglePlayApplicationConfiguration</returns>
        public Elements.Client.ApiResponse<GooglePlayApplicationConfiguration> UpdateGooglePlayApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId, GooglePlayApplicationConfiguration googlePlayApplicationConfiguration = default(GooglePlayApplicationConfiguration))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->UpdateGooglePlayApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->UpdateGooglePlayApplicationConfiguration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter
            localVarRequestOptions.Data = googlePlayApplicationConfiguration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<GooglePlayApplicationConfiguration>("/application/{applicationNameOrId}/configuration/google_play/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGooglePlayApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a Google Play ApplicationConfiguration Updates an existing Google Play Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="googlePlayApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GooglePlayApplicationConfiguration</returns>
        public async System.Threading.Tasks.Task<GooglePlayApplicationConfiguration> UpdateGooglePlayApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, GooglePlayApplicationConfiguration googlePlayApplicationConfiguration = default(GooglePlayApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateGooglePlayApplicationConfigurationWithHttpInfoAsync(applicationNameOrId, applicationConfigurationNameOrId, googlePlayApplicationConfiguration, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<GooglePlayApplicationConfiguration> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<GooglePlayApplicationConfiguration> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a Google Play ApplicationConfiguration Updates an existing Google Play Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="googlePlayApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GooglePlayApplicationConfiguration)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<GooglePlayApplicationConfiguration>> UpdateGooglePlayApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, GooglePlayApplicationConfiguration googlePlayApplicationConfiguration = default(GooglePlayApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->UpdateGooglePlayApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->UpdateGooglePlayApplicationConfiguration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter
            localVarRequestOptions.Data = googlePlayApplicationConfiguration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<GooglePlayApplicationConfiguration>("/application/{applicationNameOrId}/configuration/google_play/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGooglePlayApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a iOS ApplicationConfiguration Updates an existing iOS Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="iosApplicationConfiguration"> (optional)</param>
        /// <returns>IosApplicationConfiguration</returns>
        public IosApplicationConfiguration UpdateIosApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId, IosApplicationConfiguration iosApplicationConfiguration = default(IosApplicationConfiguration))
        {
            Elements.Client.ApiResponse<IosApplicationConfiguration> localVarResponse = UpdateIosApplicationConfigurationWithHttpInfo(applicationNameOrId, applicationConfigurationNameOrId, iosApplicationConfiguration);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a iOS ApplicationConfiguration Updates an existing iOS Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="iosApplicationConfiguration"> (optional)</param>
        /// <returns>ApiResponse of IosApplicationConfiguration</returns>
        public Elements.Client.ApiResponse<IosApplicationConfiguration> UpdateIosApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId, IosApplicationConfiguration iosApplicationConfiguration = default(IosApplicationConfiguration))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->UpdateIosApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->UpdateIosApplicationConfiguration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter
            localVarRequestOptions.Data = iosApplicationConfiguration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<IosApplicationConfiguration>("/application/{applicationNameOrId}/configuration/ios/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateIosApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a iOS ApplicationConfiguration Updates an existing iOS Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="iosApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IosApplicationConfiguration</returns>
        public async System.Threading.Tasks.Task<IosApplicationConfiguration> UpdateIosApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, IosApplicationConfiguration iosApplicationConfiguration = default(IosApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateIosApplicationConfigurationWithHttpInfoAsync(applicationNameOrId, applicationConfigurationNameOrId, iosApplicationConfiguration, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<IosApplicationConfiguration> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<IosApplicationConfiguration> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a iOS ApplicationConfiguration Updates an existing iOS Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="iosApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IosApplicationConfiguration)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<IosApplicationConfiguration>> UpdateIosApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, IosApplicationConfiguration iosApplicationConfiguration = default(IosApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->UpdateIosApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->UpdateIosApplicationConfiguration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter
            localVarRequestOptions.Data = iosApplicationConfiguration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<IosApplicationConfiguration>("/application/{applicationNameOrId}/configuration/ios/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateIosApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a single Item Supplying an item, this will update the Item identified by the identifier in the path with contents from the passed in request body. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="identifier"></param>
        /// <param name="updateItemRequest"> (optional)</param>
        /// <returns>Item</returns>
        public Item UpdateItem(string identifier, UpdateItemRequest updateItemRequest = default(UpdateItemRequest))
        {
            Elements.Client.ApiResponse<Item> localVarResponse = UpdateItemWithHttpInfo(identifier, updateItemRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a single Item Supplying an item, this will update the Item identified by the identifier in the path with contents from the passed in request body. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="identifier"></param>
        /// <param name="updateItemRequest"> (optional)</param>
        /// <returns>ApiResponse of Item</returns>
        public Elements.Client.ApiResponse<Item> UpdateItemWithHttpInfo(string identifier, UpdateItemRequest updateItemRequest = default(UpdateItemRequest))
        {
            // verify the required parameter 'identifier' is set
            if (identifier == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'identifier' when calling DefaultApi->UpdateItem");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("identifier", Elements.Client.ClientUtils.ParameterToString(identifier)); // path parameter
            localVarRequestOptions.Data = updateItemRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<Item>("/item/{identifier}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a single Item Supplying an item, this will update the Item identified by the identifier in the path with contents from the passed in request body. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="identifier"></param>
        /// <param name="updateItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Item</returns>
        public async System.Threading.Tasks.Task<Item> UpdateItemAsync(string identifier, UpdateItemRequest updateItemRequest = default(UpdateItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateItemWithHttpInfoAsync(identifier, updateItemRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Item> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Item> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a single Item Supplying an item, this will update the Item identified by the identifier in the path with contents from the passed in request body. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="identifier"></param>
        /// <param name="updateItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Item)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Item>> UpdateItemWithHttpInfoAsync(string identifier, UpdateItemRequest updateItemRequest = default(UpdateItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'identifier' is set
            if (identifier == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'identifier' when calling DefaultApi->UpdateItem");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("identifier", Elements.Client.ClientUtils.ParameterToString(identifier)); // path parameter
            localVarRequestOptions.Data = updateItemRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<Item>("/item/{identifier}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a LargeObject 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <param name="updateLargeObjectRequest"> (optional)</param>
        /// <returns>LargeObject</returns>
        public LargeObject UpdateLargeObject(string largeObjectId, UpdateLargeObjectRequest updateLargeObjectRequest = default(UpdateLargeObjectRequest))
        {
            Elements.Client.ApiResponse<LargeObject> localVarResponse = UpdateLargeObjectWithHttpInfo(largeObjectId, updateLargeObjectRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a LargeObject 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <param name="updateLargeObjectRequest"> (optional)</param>
        /// <returns>ApiResponse of LargeObject</returns>
        public Elements.Client.ApiResponse<LargeObject> UpdateLargeObjectWithHttpInfo(string largeObjectId, UpdateLargeObjectRequest updateLargeObjectRequest = default(UpdateLargeObjectRequest))
        {
            // verify the required parameter 'largeObjectId' is set
            if (largeObjectId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'largeObjectId' when calling DefaultApi->UpdateLargeObject");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("largeObjectId", Elements.Client.ClientUtils.ParameterToString(largeObjectId)); // path parameter
            localVarRequestOptions.Data = updateLargeObjectRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<LargeObject>("/large_object/{largeObjectId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLargeObject", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a LargeObject 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <param name="updateLargeObjectRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LargeObject</returns>
        public async System.Threading.Tasks.Task<LargeObject> UpdateLargeObjectAsync(string largeObjectId, UpdateLargeObjectRequest updateLargeObjectRequest = default(UpdateLargeObjectRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateLargeObjectWithHttpInfoAsync(largeObjectId, updateLargeObjectRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<LargeObject> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<LargeObject> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a LargeObject 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <param name="updateLargeObjectRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LargeObject)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<LargeObject>> UpdateLargeObjectWithHttpInfoAsync(string largeObjectId, UpdateLargeObjectRequest updateLargeObjectRequest = default(UpdateLargeObjectRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'largeObjectId' is set
            if (largeObjectId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'largeObjectId' when calling DefaultApi->UpdateLargeObject");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("largeObjectId", Elements.Client.ClientUtils.ParameterToString(largeObjectId)); // path parameter
            localVarRequestOptions.Data = updateLargeObjectRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<LargeObject>("/large_object/{largeObjectId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLargeObject", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a LargeObject content 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <param name="body"> (optional)</param>
        /// <returns>LargeObject</returns>
        public LargeObject UpdateLargeObjectContents(string largeObjectId, Object body = default(Object))
        {
            Elements.Client.ApiResponse<LargeObject> localVarResponse = UpdateLargeObjectContentsWithHttpInfo(largeObjectId, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a LargeObject content 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of LargeObject</returns>
        public Elements.Client.ApiResponse<LargeObject> UpdateLargeObjectContentsWithHttpInfo(string largeObjectId, Object body = default(Object))
        {
            // verify the required parameter 'largeObjectId' is set
            if (largeObjectId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'largeObjectId' when calling DefaultApi->UpdateLargeObjectContents");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("largeObjectId", Elements.Client.ClientUtils.ParameterToString(largeObjectId)); // path parameter
            localVarRequestOptions.Data = body;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<LargeObject>("/large_object/{largeObjectId}/content", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLargeObjectContents", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a LargeObject content 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LargeObject</returns>
        public async System.Threading.Tasks.Task<LargeObject> UpdateLargeObjectContentsAsync(string largeObjectId, Object body = default(Object), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateLargeObjectContentsWithHttpInfoAsync(largeObjectId, body, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<LargeObject> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<LargeObject> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a LargeObject content 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="largeObjectId"></param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LargeObject)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<LargeObject>> UpdateLargeObjectContentsWithHttpInfoAsync(string largeObjectId, Object body = default(Object), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'largeObjectId' is set
            if (largeObjectId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'largeObjectId' when calling DefaultApi->UpdateLargeObjectContents");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("largeObjectId", Elements.Client.ClientUtils.ParameterToString(largeObjectId)); // path parameter
            localVarRequestOptions.Data = body;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<LargeObject>("/large_object/{largeObjectId}/content", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLargeObjectContents", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates an Leaderboard Performs an update to an existing leaderboard known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="leaderboard"> (optional)</param>
        /// <returns>Leaderboard</returns>
        public Leaderboard UpdateLeaderboard(string nameOrId, Leaderboard leaderboard = default(Leaderboard))
        {
            Elements.Client.ApiResponse<Leaderboard> localVarResponse = UpdateLeaderboardWithHttpInfo(nameOrId, leaderboard);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates an Leaderboard Performs an update to an existing leaderboard known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="leaderboard"> (optional)</param>
        /// <returns>ApiResponse of Leaderboard</returns>
        public Elements.Client.ApiResponse<Leaderboard> UpdateLeaderboardWithHttpInfo(string nameOrId, Leaderboard leaderboard = default(Leaderboard))
        {
            // verify the required parameter 'nameOrId' is set
            if (nameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'nameOrId' when calling DefaultApi->UpdateLeaderboard");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("nameOrId", Elements.Client.ClientUtils.ParameterToString(nameOrId)); // path parameter
            localVarRequestOptions.Data = leaderboard;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<Leaderboard>("/leaderboard/{nameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLeaderboard", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates an Leaderboard Performs an update to an existing leaderboard known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="leaderboard"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Leaderboard</returns>
        public async System.Threading.Tasks.Task<Leaderboard> UpdateLeaderboardAsync(string nameOrId, Leaderboard leaderboard = default(Leaderboard), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateLeaderboardWithHttpInfoAsync(nameOrId, leaderboard, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Leaderboard> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Leaderboard> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates an Leaderboard Performs an update to an existing leaderboard known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nameOrId"></param>
        /// <param name="leaderboard"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Leaderboard)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Leaderboard>> UpdateLeaderboardWithHttpInfoAsync(string nameOrId, Leaderboard leaderboard = default(Leaderboard), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'nameOrId' is set
            if (nameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'nameOrId' when calling DefaultApi->UpdateLeaderboard");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("nameOrId", Elements.Client.ClientUtils.ParameterToString(nameOrId)); // path parameter
            localVarRequestOptions.Data = leaderboard;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<Leaderboard>("/leaderboard/{nameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLeaderboard", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a iOS ApplicationConfiguration Updates an existing iOS Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="matchmakingApplicationConfiguration"> (optional)</param>
        /// <returns>MatchmakingApplicationConfiguration</returns>
        public MatchmakingApplicationConfiguration UpdateMatchmakingApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId, MatchmakingApplicationConfiguration matchmakingApplicationConfiguration = default(MatchmakingApplicationConfiguration))
        {
            Elements.Client.ApiResponse<MatchmakingApplicationConfiguration> localVarResponse = UpdateMatchmakingApplicationConfigurationWithHttpInfo(applicationNameOrId, applicationConfigurationNameOrId, matchmakingApplicationConfiguration);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a iOS ApplicationConfiguration Updates an existing iOS Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="matchmakingApplicationConfiguration"> (optional)</param>
        /// <returns>ApiResponse of MatchmakingApplicationConfiguration</returns>
        public Elements.Client.ApiResponse<MatchmakingApplicationConfiguration> UpdateMatchmakingApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId, MatchmakingApplicationConfiguration matchmakingApplicationConfiguration = default(MatchmakingApplicationConfiguration))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->UpdateMatchmakingApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->UpdateMatchmakingApplicationConfiguration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter
            localVarRequestOptions.Data = matchmakingApplicationConfiguration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<MatchmakingApplicationConfiguration>("/application/{applicationNameOrId}/configuration/matchmaking/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateMatchmakingApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a iOS ApplicationConfiguration Updates an existing iOS Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="matchmakingApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MatchmakingApplicationConfiguration</returns>
        public async System.Threading.Tasks.Task<MatchmakingApplicationConfiguration> UpdateMatchmakingApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, MatchmakingApplicationConfiguration matchmakingApplicationConfiguration = default(MatchmakingApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateMatchmakingApplicationConfigurationWithHttpInfoAsync(applicationNameOrId, applicationConfigurationNameOrId, matchmakingApplicationConfiguration, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<MatchmakingApplicationConfiguration> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<MatchmakingApplicationConfiguration> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a iOS ApplicationConfiguration Updates an existing iOS Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="matchmakingApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MatchmakingApplicationConfiguration)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<MatchmakingApplicationConfiguration>> UpdateMatchmakingApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, MatchmakingApplicationConfiguration matchmakingApplicationConfiguration = default(MatchmakingApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->UpdateMatchmakingApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->UpdateMatchmakingApplicationConfiguration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter
            localVarRequestOptions.Data = matchmakingApplicationConfiguration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<MatchmakingApplicationConfiguration>("/application/{applicationNameOrId}/configuration/matchmaking/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateMatchmakingApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a specific Metadata object Updates a specific metadata object by name or id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="updateMetadataRequest"> (optional)</param>
        /// <returns>Metadata</returns>
        public Metadata UpdateMetadata(string id, UpdateMetadataRequest updateMetadataRequest = default(UpdateMetadataRequest))
        {
            Elements.Client.ApiResponse<Metadata> localVarResponse = UpdateMetadataWithHttpInfo(id, updateMetadataRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a specific Metadata object Updates a specific metadata object by name or id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="updateMetadataRequest"> (optional)</param>
        /// <returns>ApiResponse of Metadata</returns>
        public Elements.Client.ApiResponse<Metadata> UpdateMetadataWithHttpInfo(string id, UpdateMetadataRequest updateMetadataRequest = default(UpdateMetadataRequest))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'id' when calling DefaultApi->UpdateMetadata");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Elements.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = updateMetadataRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<Metadata>("/metadata/{id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateMetadata", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a specific Metadata object Updates a specific metadata object by name or id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="updateMetadataRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Metadata</returns>
        public async System.Threading.Tasks.Task<Metadata> UpdateMetadataAsync(string id, UpdateMetadataRequest updateMetadataRequest = default(UpdateMetadataRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateMetadataWithHttpInfoAsync(id, updateMetadataRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Metadata> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Metadata> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a specific Metadata object Updates a specific metadata object by name or id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="updateMetadataRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Metadata)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Metadata>> UpdateMetadataWithHttpInfoAsync(string id, UpdateMetadataRequest updateMetadataRequest = default(UpdateMetadataRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'id' when calling DefaultApi->UpdateMetadata");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Elements.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = updateMetadataRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<Metadata>("/metadata/{id}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateMetadata", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a Metadata Spec Updates a MetadataSpec with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecId"></param>
        /// <param name="updateMetadataSpecRequest"> (optional)</param>
        /// <returns>MetadataSpec</returns>
        public MetadataSpec UpdateMetadataSpec(string metadataSpecId, UpdateMetadataSpecRequest updateMetadataSpecRequest = default(UpdateMetadataSpecRequest))
        {
            Elements.Client.ApiResponse<MetadataSpec> localVarResponse = UpdateMetadataSpecWithHttpInfo(metadataSpecId, updateMetadataSpecRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a Metadata Spec Updates a MetadataSpec with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecId"></param>
        /// <param name="updateMetadataSpecRequest"> (optional)</param>
        /// <returns>ApiResponse of MetadataSpec</returns>
        public Elements.Client.ApiResponse<MetadataSpec> UpdateMetadataSpecWithHttpInfo(string metadataSpecId, UpdateMetadataSpecRequest updateMetadataSpecRequest = default(UpdateMetadataSpecRequest))
        {
            // verify the required parameter 'metadataSpecId' is set
            if (metadataSpecId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'metadataSpecId' when calling DefaultApi->UpdateMetadataSpec");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("metadataSpecId", Elements.Client.ClientUtils.ParameterToString(metadataSpecId)); // path parameter
            localVarRequestOptions.Data = updateMetadataSpecRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<MetadataSpec>("/metadata_spec/{metadataSpecId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateMetadataSpec", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a Metadata Spec Updates a MetadataSpec with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecId"></param>
        /// <param name="updateMetadataSpecRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MetadataSpec</returns>
        public async System.Threading.Tasks.Task<MetadataSpec> UpdateMetadataSpecAsync(string metadataSpecId, UpdateMetadataSpecRequest updateMetadataSpecRequest = default(UpdateMetadataSpecRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateMetadataSpecWithHttpInfoAsync(metadataSpecId, updateMetadataSpecRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<MetadataSpec> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<MetadataSpec> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a Metadata Spec Updates a MetadataSpec with the specified id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="metadataSpecId"></param>
        /// <param name="updateMetadataSpecRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MetadataSpec)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<MetadataSpec>> UpdateMetadataSpecWithHttpInfoAsync(string metadataSpecId, UpdateMetadataSpecRequest updateMetadataSpecRequest = default(UpdateMetadataSpecRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'metadataSpecId' is set
            if (metadataSpecId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'metadataSpecId' when calling DefaultApi->UpdateMetadataSpec");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("metadataSpecId", Elements.Client.ClientUtils.ParameterToString(metadataSpecId)); // path parameter
            localVarRequestOptions.Data = updateMetadataSpecRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<MetadataSpec>("/metadata_spec/{metadataSpecId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateMetadataSpec", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates an entire single Mission Supplying a mission, this will update the Mission identified by the name or ID in the path with contents from the passed in request body. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="missionNameOrId"></param>
        /// <param name="mission"> (optional)</param>
        /// <returns>Mission</returns>
        public Mission UpdateMission(string missionNameOrId, Mission mission = default(Mission))
        {
            Elements.Client.ApiResponse<Mission> localVarResponse = UpdateMissionWithHttpInfo(missionNameOrId, mission);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates an entire single Mission Supplying a mission, this will update the Mission identified by the name or ID in the path with contents from the passed in request body. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="missionNameOrId"></param>
        /// <param name="mission"> (optional)</param>
        /// <returns>ApiResponse of Mission</returns>
        public Elements.Client.ApiResponse<Mission> UpdateMissionWithHttpInfo(string missionNameOrId, Mission mission = default(Mission))
        {
            // verify the required parameter 'missionNameOrId' is set
            if (missionNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'missionNameOrId' when calling DefaultApi->UpdateMission");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("missionNameOrId", Elements.Client.ClientUtils.ParameterToString(missionNameOrId)); // path parameter
            localVarRequestOptions.Data = mission;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<Mission>("/mission/{missionNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateMission", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates an entire single Mission Supplying a mission, this will update the Mission identified by the name or ID in the path with contents from the passed in request body. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="missionNameOrId"></param>
        /// <param name="mission"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Mission</returns>
        public async System.Threading.Tasks.Task<Mission> UpdateMissionAsync(string missionNameOrId, Mission mission = default(Mission), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateMissionWithHttpInfoAsync(missionNameOrId, mission, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Mission> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Mission> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates an entire single Mission Supplying a mission, this will update the Mission identified by the name or ID in the path with contents from the passed in request body. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="missionNameOrId"></param>
        /// <param name="mission"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Mission)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Mission>> UpdateMissionWithHttpInfoAsync(string missionNameOrId, Mission mission = default(Mission), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'missionNameOrId' is set
            if (missionNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'missionNameOrId' when calling DefaultApi->UpdateMission");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("missionNameOrId", Elements.Client.ClientUtils.ParameterToString(missionNameOrId)); // path parameter
            localVarRequestOptions.Data = mission;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<Mission>("/mission/{missionNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateMission", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a PSN ApplicationConfiguration Updates an existing PSN Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="pSNApplicationConfiguration"> (optional)</param>
        /// <returns>PSNApplicationConfiguration</returns>
        public PSNApplicationConfiguration UpdatePSNApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId, PSNApplicationConfiguration pSNApplicationConfiguration = default(PSNApplicationConfiguration))
        {
            Elements.Client.ApiResponse<PSNApplicationConfiguration> localVarResponse = UpdatePSNApplicationConfigurationWithHttpInfo(applicationNameOrId, applicationConfigurationNameOrId, pSNApplicationConfiguration);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a PSN ApplicationConfiguration Updates an existing PSN Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="pSNApplicationConfiguration"> (optional)</param>
        /// <returns>ApiResponse of PSNApplicationConfiguration</returns>
        public Elements.Client.ApiResponse<PSNApplicationConfiguration> UpdatePSNApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId, PSNApplicationConfiguration pSNApplicationConfiguration = default(PSNApplicationConfiguration))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->UpdatePSNApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->UpdatePSNApplicationConfiguration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter
            localVarRequestOptions.Data = pSNApplicationConfiguration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<PSNApplicationConfiguration>("/application/{applicationNameOrId}/configuration/psn/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePSNApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a PSN ApplicationConfiguration Updates an existing PSN Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="pSNApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PSNApplicationConfiguration</returns>
        public async System.Threading.Tasks.Task<PSNApplicationConfiguration> UpdatePSNApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, PSNApplicationConfiguration pSNApplicationConfiguration = default(PSNApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdatePSNApplicationConfigurationWithHttpInfoAsync(applicationNameOrId, applicationConfigurationNameOrId, pSNApplicationConfiguration, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<PSNApplicationConfiguration> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<PSNApplicationConfiguration> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a PSN ApplicationConfiguration Updates an existing PSN Application profile if it is known to the server.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="pSNApplicationConfiguration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PSNApplicationConfiguration)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<PSNApplicationConfiguration>> UpdatePSNApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, PSNApplicationConfiguration pSNApplicationConfiguration = default(PSNApplicationConfiguration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->UpdatePSNApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->UpdatePSNApplicationConfiguration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter
            localVarRequestOptions.Data = pSNApplicationConfiguration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<PSNApplicationConfiguration>("/application/{applicationNameOrId}/configuration/psn/{applicationConfigurationNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePSNApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates the ProductBundle Updates the ProductBundle for the given ApplicationConfiguration
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="productBundle"> (optional)</param>
        /// <returns>ApplicationConfiguration</returns>
        public ApplicationConfiguration UpdateProductBundleForApplicationConfiguration(string applicationNameOrId, string applicationConfigurationNameOrId, List<ProductBundle> productBundle = default(List<ProductBundle>))
        {
            Elements.Client.ApiResponse<ApplicationConfiguration> localVarResponse = UpdateProductBundleForApplicationConfigurationWithHttpInfo(applicationNameOrId, applicationConfigurationNameOrId, productBundle);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates the ProductBundle Updates the ProductBundle for the given ApplicationConfiguration
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="productBundle"> (optional)</param>
        /// <returns>ApiResponse of ApplicationConfiguration</returns>
        public Elements.Client.ApiResponse<ApplicationConfiguration> UpdateProductBundleForApplicationConfigurationWithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId, List<ProductBundle> productBundle = default(List<ProductBundle>))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->UpdateProductBundleForApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->UpdateProductBundleForApplicationConfiguration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter
            localVarRequestOptions.Data = productBundle;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<ApplicationConfiguration>("/application/{applicationNameOrId}/configuration/google_play/{applicationConfigurationNameOrId}/product_bundles", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateProductBundleForApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates the ProductBundle Updates the ProductBundle for the given ApplicationConfiguration
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="productBundle"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApplicationConfiguration</returns>
        public async System.Threading.Tasks.Task<ApplicationConfiguration> UpdateProductBundleForApplicationConfigurationAsync(string applicationNameOrId, string applicationConfigurationNameOrId, List<ProductBundle> productBundle = default(List<ProductBundle>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateProductBundleForApplicationConfigurationWithHttpInfoAsync(applicationNameOrId, applicationConfigurationNameOrId, productBundle, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<ApplicationConfiguration> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<ApplicationConfiguration> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates the ProductBundle Updates the ProductBundle for the given ApplicationConfiguration
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="productBundle"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ApplicationConfiguration)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<ApplicationConfiguration>> UpdateProductBundleForApplicationConfigurationWithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, List<ProductBundle> productBundle = default(List<ProductBundle>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->UpdateProductBundleForApplicationConfiguration");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->UpdateProductBundleForApplicationConfiguration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter
            localVarRequestOptions.Data = productBundle;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<ApplicationConfiguration>("/application/{applicationNameOrId}/configuration/google_play/{applicationConfigurationNameOrId}/product_bundles", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateProductBundleForApplicationConfiguration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates the ProductBundle Updates the ProductBundle for the given ApplicationConfiguration
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="productBundle"> (optional)</param>
        /// <returns>ApplicationConfiguration</returns>
        public ApplicationConfiguration UpdateProductBundleForApplicationConfiguration1(string applicationNameOrId, string applicationConfigurationNameOrId, List<ProductBundle> productBundle = default(List<ProductBundle>))
        {
            Elements.Client.ApiResponse<ApplicationConfiguration> localVarResponse = UpdateProductBundleForApplicationConfiguration1WithHttpInfo(applicationNameOrId, applicationConfigurationNameOrId, productBundle);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates the ProductBundle Updates the ProductBundle for the given ApplicationConfiguration
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="productBundle"> (optional)</param>
        /// <returns>ApiResponse of ApplicationConfiguration</returns>
        public Elements.Client.ApiResponse<ApplicationConfiguration> UpdateProductBundleForApplicationConfiguration1WithHttpInfo(string applicationNameOrId, string applicationConfigurationNameOrId, List<ProductBundle> productBundle = default(List<ProductBundle>))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->UpdateProductBundleForApplicationConfiguration1");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->UpdateProductBundleForApplicationConfiguration1");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter
            localVarRequestOptions.Data = productBundle;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<ApplicationConfiguration>("/application/{applicationNameOrId}/configuration/ios/{applicationConfigurationNameOrId}/product_bundles", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateProductBundleForApplicationConfiguration1", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates the ProductBundle Updates the ProductBundle for the given ApplicationConfiguration
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="productBundle"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApplicationConfiguration</returns>
        public async System.Threading.Tasks.Task<ApplicationConfiguration> UpdateProductBundleForApplicationConfiguration1Async(string applicationNameOrId, string applicationConfigurationNameOrId, List<ProductBundle> productBundle = default(List<ProductBundle>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateProductBundleForApplicationConfiguration1WithHttpInfoAsync(applicationNameOrId, applicationConfigurationNameOrId, productBundle, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<ApplicationConfiguration> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<ApplicationConfiguration> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates the ProductBundle Updates the ProductBundle for the given ApplicationConfiguration
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="applicationNameOrId"></param>
        /// <param name="applicationConfigurationNameOrId"></param>
        /// <param name="productBundle"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ApplicationConfiguration)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<ApplicationConfiguration>> UpdateProductBundleForApplicationConfiguration1WithHttpInfoAsync(string applicationNameOrId, string applicationConfigurationNameOrId, List<ProductBundle> productBundle = default(List<ProductBundle>), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'applicationNameOrId' is set
            if (applicationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationNameOrId' when calling DefaultApi->UpdateProductBundleForApplicationConfiguration1");

            // verify the required parameter 'applicationConfigurationNameOrId' is set
            if (applicationConfigurationNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'applicationConfigurationNameOrId' when calling DefaultApi->UpdateProductBundleForApplicationConfiguration1");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("applicationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("applicationConfigurationNameOrId", Elements.Client.ClientUtils.ParameterToString(applicationConfigurationNameOrId)); // path parameter
            localVarRequestOptions.Data = productBundle;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<ApplicationConfiguration>("/application/{applicationNameOrId}/configuration/ios/{applicationConfigurationNameOrId}/product_bundles", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateProductBundleForApplicationConfiguration1", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a Profile Supplying an update request will attempt to update the profile.  The call will return the profile as it was written to the database.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="updateProfileRequest"> (optional)</param>
        /// <returns>Profile</returns>
        public Profile UpdateProfile(string profileId, UpdateProfileRequest updateProfileRequest = default(UpdateProfileRequest))
        {
            Elements.Client.ApiResponse<Profile> localVarResponse = UpdateProfileWithHttpInfo(profileId, updateProfileRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a Profile Supplying an update request will attempt to update the profile.  The call will return the profile as it was written to the database.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="updateProfileRequest"> (optional)</param>
        /// <returns>ApiResponse of Profile</returns>
        public Elements.Client.ApiResponse<Profile> UpdateProfileWithHttpInfo(string profileId, UpdateProfileRequest updateProfileRequest = default(UpdateProfileRequest))
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'profileId' when calling DefaultApi->UpdateProfile");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("profileId", Elements.Client.ClientUtils.ParameterToString(profileId)); // path parameter
            localVarRequestOptions.Data = updateProfileRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<Profile>("/profile/{profileId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateProfile", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a Profile Supplying an update request will attempt to update the profile.  The call will return the profile as it was written to the database.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="updateProfileRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Profile</returns>
        public async System.Threading.Tasks.Task<Profile> UpdateProfileAsync(string profileId, UpdateProfileRequest updateProfileRequest = default(UpdateProfileRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateProfileWithHttpInfoAsync(profileId, updateProfileRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Profile> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Profile> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a Profile Supplying an update request will attempt to update the profile.  The call will return the profile as it was written to the database.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="updateProfileRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Profile)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Profile>> UpdateProfileWithHttpInfoAsync(string profileId, UpdateProfileRequest updateProfileRequest = default(UpdateProfileRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'profileId' when calling DefaultApi->UpdateProfile");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("profileId", Elements.Client.ClientUtils.ParameterToString(profileId)); // path parameter
            localVarRequestOptions.Data = updateProfileRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<Profile>("/profile/{profileId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateProfile", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a Profile image object 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="updateProfileImageRequest"> (optional)</param>
        /// <returns>Profile</returns>
        public Profile UpdateProfileImage(string profileId, UpdateProfileImageRequest updateProfileImageRequest = default(UpdateProfileImageRequest))
        {
            Elements.Client.ApiResponse<Profile> localVarResponse = UpdateProfileImageWithHttpInfo(profileId, updateProfileImageRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a Profile image object 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="updateProfileImageRequest"> (optional)</param>
        /// <returns>ApiResponse of Profile</returns>
        public Elements.Client.ApiResponse<Profile> UpdateProfileImageWithHttpInfo(string profileId, UpdateProfileImageRequest updateProfileImageRequest = default(UpdateProfileImageRequest))
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'profileId' when calling DefaultApi->UpdateProfileImage");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("profileId", Elements.Client.ClientUtils.ParameterToString(profileId)); // path parameter
            localVarRequestOptions.Data = updateProfileImageRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<Profile>("/profile/{profileId}/image", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateProfileImage", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a Profile image object 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="updateProfileImageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Profile</returns>
        public async System.Threading.Tasks.Task<Profile> UpdateProfileImageAsync(string profileId, UpdateProfileImageRequest updateProfileImageRequest = default(UpdateProfileImageRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateProfileImageWithHttpInfoAsync(profileId, updateProfileImageRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Profile> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Profile> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a Profile image object 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId"></param>
        /// <param name="updateProfileImageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Profile)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Profile>> UpdateProfileImageWithHttpInfoAsync(string profileId, UpdateProfileImageRequest updateProfileImageRequest = default(UpdateProfileImageRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'profileId' when calling DefaultApi->UpdateProfileImage");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("profileId", Elements.Client.ClientUtils.ParameterToString(profileId)); // path parameter
            localVarRequestOptions.Data = updateProfileImageRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<Profile>("/profile/{profileId}/image", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateProfileImage", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a single Progress Supplying a progress, this will update the Progress identified by the ID in the path with contents from the passed in request body. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progressId"></param>
        /// <param name="progress"> (optional)</param>
        /// <returns>Progress</returns>
        public Progress UpdateProgress(string progressId, Progress progress = default(Progress))
        {
            Elements.Client.ApiResponse<Progress> localVarResponse = UpdateProgressWithHttpInfo(progressId, progress);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a single Progress Supplying a progress, this will update the Progress identified by the ID in the path with contents from the passed in request body. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progressId"></param>
        /// <param name="progress"> (optional)</param>
        /// <returns>ApiResponse of Progress</returns>
        public Elements.Client.ApiResponse<Progress> UpdateProgressWithHttpInfo(string progressId, Progress progress = default(Progress))
        {
            // verify the required parameter 'progressId' is set
            if (progressId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'progressId' when calling DefaultApi->UpdateProgress");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("progressId", Elements.Client.ClientUtils.ParameterToString(progressId)); // path parameter
            localVarRequestOptions.Data = progress;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<Progress>("/progress/{progressId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateProgress", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a single Progress Supplying a progress, this will update the Progress identified by the ID in the path with contents from the passed in request body. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progressId"></param>
        /// <param name="progress"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Progress</returns>
        public async System.Threading.Tasks.Task<Progress> UpdateProgressAsync(string progressId, Progress progress = default(Progress), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateProgressWithHttpInfoAsync(progressId, progress, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Progress> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Progress> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a single Progress Supplying a progress, this will update the Progress identified by the ID in the path with contents from the passed in request body. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="progressId"></param>
        /// <param name="progress"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Progress)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Progress>> UpdateProgressWithHttpInfoAsync(string progressId, Progress progress = default(Progress), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'progressId' is set
            if (progressId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'progressId' when calling DefaultApi->UpdateProgress");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("progressId", Elements.Client.ClientUtils.ParameterToString(progressId)); // path parameter
            localVarRequestOptions.Data = progress;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<Progress>("/progress/{progressId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateProgress", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update an FCM Registration Token Supplying FCM registration token, this will update the token string with the supplied values.  Clients may update the same registration with a different token issued with Firebase if they wish to simply retain the association with the 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fcmRegistrationId"></param>
        /// <param name="fCMRegistration"> (optional)</param>
        /// <returns>FCMRegistration</returns>
        public FCMRegistration UpdateRegistration(string fcmRegistrationId, FCMRegistration fCMRegistration = default(FCMRegistration))
        {
            Elements.Client.ApiResponse<FCMRegistration> localVarResponse = UpdateRegistrationWithHttpInfo(fcmRegistrationId, fCMRegistration);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update an FCM Registration Token Supplying FCM registration token, this will update the token string with the supplied values.  Clients may update the same registration with a different token issued with Firebase if they wish to simply retain the association with the 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fcmRegistrationId"></param>
        /// <param name="fCMRegistration"> (optional)</param>
        /// <returns>ApiResponse of FCMRegistration</returns>
        public Elements.Client.ApiResponse<FCMRegistration> UpdateRegistrationWithHttpInfo(string fcmRegistrationId, FCMRegistration fCMRegistration = default(FCMRegistration))
        {
            // verify the required parameter 'fcmRegistrationId' is set
            if (fcmRegistrationId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'fcmRegistrationId' when calling DefaultApi->UpdateRegistration");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("fcmRegistrationId", Elements.Client.ClientUtils.ParameterToString(fcmRegistrationId)); // path parameter
            localVarRequestOptions.Data = fCMRegistration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<FCMRegistration>("/notification/fcm/{fcmRegistrationId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateRegistration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update an FCM Registration Token Supplying FCM registration token, this will update the token string with the supplied values.  Clients may update the same registration with a different token issued with Firebase if they wish to simply retain the association with the 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fcmRegistrationId"></param>
        /// <param name="fCMRegistration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FCMRegistration</returns>
        public async System.Threading.Tasks.Task<FCMRegistration> UpdateRegistrationAsync(string fcmRegistrationId, FCMRegistration fCMRegistration = default(FCMRegistration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateRegistrationWithHttpInfoAsync(fcmRegistrationId, fCMRegistration, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<FCMRegistration> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<FCMRegistration> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update an FCM Registration Token Supplying FCM registration token, this will update the token string with the supplied values.  Clients may update the same registration with a different token issued with Firebase if they wish to simply retain the association with the 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fcmRegistrationId"></param>
        /// <param name="fCMRegistration"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FCMRegistration)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<FCMRegistration>> UpdateRegistrationWithHttpInfoAsync(string fcmRegistrationId, FCMRegistration fCMRegistration = default(FCMRegistration), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'fcmRegistrationId' is set
            if (fcmRegistrationId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'fcmRegistrationId' when calling DefaultApi->UpdateRegistration");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("fcmRegistrationId", Elements.Client.ClientUtils.ParameterToString(fcmRegistrationId)); // path parameter
            localVarRequestOptions.Data = fCMRegistration;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<FCMRegistration>("/notification/fcm/{fcmRegistrationId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateRegistration", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a save data document. Gets a single save data document.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="saveDataDocumentId"></param>
        /// <param name="updateSaveDataDocumentRequest"> (optional)</param>
        /// <returns>SaveDataDocument</returns>
        public SaveDataDocument UpdateSaveDocument(string saveDataDocumentId, UpdateSaveDataDocumentRequest updateSaveDataDocumentRequest = default(UpdateSaveDataDocumentRequest))
        {
            Elements.Client.ApiResponse<SaveDataDocument> localVarResponse = UpdateSaveDocumentWithHttpInfo(saveDataDocumentId, updateSaveDataDocumentRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a save data document. Gets a single save data document.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="saveDataDocumentId"></param>
        /// <param name="updateSaveDataDocumentRequest"> (optional)</param>
        /// <returns>ApiResponse of SaveDataDocument</returns>
        public Elements.Client.ApiResponse<SaveDataDocument> UpdateSaveDocumentWithHttpInfo(string saveDataDocumentId, UpdateSaveDataDocumentRequest updateSaveDataDocumentRequest = default(UpdateSaveDataDocumentRequest))
        {
            // verify the required parameter 'saveDataDocumentId' is set
            if (saveDataDocumentId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'saveDataDocumentId' when calling DefaultApi->UpdateSaveDocument");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("saveDataDocumentId", Elements.Client.ClientUtils.ParameterToString(saveDataDocumentId)); // path parameter
            localVarRequestOptions.Data = updateSaveDataDocumentRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<SaveDataDocument>("/save_data/{saveDataDocumentId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSaveDocument", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Creates a save data document. Gets a single save data document.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="saveDataDocumentId"></param>
        /// <param name="updateSaveDataDocumentRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SaveDataDocument</returns>
        public async System.Threading.Tasks.Task<SaveDataDocument> UpdateSaveDocumentAsync(string saveDataDocumentId, UpdateSaveDataDocumentRequest updateSaveDataDocumentRequest = default(UpdateSaveDataDocumentRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateSaveDocumentWithHttpInfoAsync(saveDataDocumentId, updateSaveDataDocumentRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<SaveDataDocument> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<SaveDataDocument> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a save data document. Gets a single save data document.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="saveDataDocumentId"></param>
        /// <param name="updateSaveDataDocumentRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SaveDataDocument)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<SaveDataDocument>> UpdateSaveDocumentWithHttpInfoAsync(string saveDataDocumentId, UpdateSaveDataDocumentRequest updateSaveDataDocumentRequest = default(UpdateSaveDataDocumentRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'saveDataDocumentId' is set
            if (saveDataDocumentId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'saveDataDocumentId' when calling DefaultApi->UpdateSaveDocument");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("saveDataDocumentId", Elements.Client.ClientUtils.ParameterToString(saveDataDocumentId)); // path parameter
            localVarRequestOptions.Data = updateSaveDataDocumentRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<SaveDataDocument>("/save_data/{saveDataDocumentId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSaveDocument", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates an entire single Schedule Supplying a schedule, this will update the Schedule identified by the name or ID in the path with contents from the passed in request body. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="updateScheduleRequest"> (optional)</param>
        /// <returns>Schedule</returns>
        public Schedule UpdateSchedule(string scheduleNameOrId, UpdateScheduleRequest updateScheduleRequest = default(UpdateScheduleRequest))
        {
            Elements.Client.ApiResponse<Schedule> localVarResponse = UpdateScheduleWithHttpInfo(scheduleNameOrId, updateScheduleRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates an entire single Schedule Supplying a schedule, this will update the Schedule identified by the name or ID in the path with contents from the passed in request body. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="updateScheduleRequest"> (optional)</param>
        /// <returns>ApiResponse of Schedule</returns>
        public Elements.Client.ApiResponse<Schedule> UpdateScheduleWithHttpInfo(string scheduleNameOrId, UpdateScheduleRequest updateScheduleRequest = default(UpdateScheduleRequest))
        {
            // verify the required parameter 'scheduleNameOrId' is set
            if (scheduleNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'scheduleNameOrId' when calling DefaultApi->UpdateSchedule");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("scheduleNameOrId", Elements.Client.ClientUtils.ParameterToString(scheduleNameOrId)); // path parameter
            localVarRequestOptions.Data = updateScheduleRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<Schedule>("/schedule/{scheduleNameOrId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSchedule", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates an entire single Schedule Supplying a schedule, this will update the Schedule identified by the name or ID in the path with contents from the passed in request body. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="updateScheduleRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Schedule</returns>
        public async System.Threading.Tasks.Task<Schedule> UpdateScheduleAsync(string scheduleNameOrId, UpdateScheduleRequest updateScheduleRequest = default(UpdateScheduleRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateScheduleWithHttpInfoAsync(scheduleNameOrId, updateScheduleRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Schedule> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Schedule> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates an entire single Schedule Supplying a schedule, this will update the Schedule identified by the name or ID in the path with contents from the passed in request body. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="updateScheduleRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Schedule)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Schedule>> UpdateScheduleWithHttpInfoAsync(string scheduleNameOrId, UpdateScheduleRequest updateScheduleRequest = default(UpdateScheduleRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'scheduleNameOrId' is set
            if (scheduleNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'scheduleNameOrId' when calling DefaultApi->UpdateSchedule");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("scheduleNameOrId", Elements.Client.ClientUtils.ParameterToString(scheduleNameOrId)); // path parameter
            localVarRequestOptions.Data = updateScheduleRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<Schedule>("/schedule/{scheduleNameOrId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSchedule", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates an entire single ScheduleEvent Supplying a schedule, this will update the ScheduleEvent identified by the name or ID in the path with contents from the passed in request body. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="scheduleEventId"></param>
        /// <param name="updateScheduleEventRequest"> (optional)</param>
        /// <returns>ScheduleEvent</returns>
        public ScheduleEvent UpdateScheduleEvent(string scheduleNameOrId, string scheduleEventId, UpdateScheduleEventRequest updateScheduleEventRequest = default(UpdateScheduleEventRequest))
        {
            Elements.Client.ApiResponse<ScheduleEvent> localVarResponse = UpdateScheduleEventWithHttpInfo(scheduleNameOrId, scheduleEventId, updateScheduleEventRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates an entire single ScheduleEvent Supplying a schedule, this will update the ScheduleEvent identified by the name or ID in the path with contents from the passed in request body. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="scheduleEventId"></param>
        /// <param name="updateScheduleEventRequest"> (optional)</param>
        /// <returns>ApiResponse of ScheduleEvent</returns>
        public Elements.Client.ApiResponse<ScheduleEvent> UpdateScheduleEventWithHttpInfo(string scheduleNameOrId, string scheduleEventId, UpdateScheduleEventRequest updateScheduleEventRequest = default(UpdateScheduleEventRequest))
        {
            // verify the required parameter 'scheduleNameOrId' is set
            if (scheduleNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'scheduleNameOrId' when calling DefaultApi->UpdateScheduleEvent");

            // verify the required parameter 'scheduleEventId' is set
            if (scheduleEventId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'scheduleEventId' when calling DefaultApi->UpdateScheduleEvent");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("scheduleNameOrId", Elements.Client.ClientUtils.ParameterToString(scheduleNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("scheduleEventId", Elements.Client.ClientUtils.ParameterToString(scheduleEventId)); // path parameter
            localVarRequestOptions.Data = updateScheduleEventRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<ScheduleEvent>("/schedule/{scheduleNameOrId}/event/{scheduleEventId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateScheduleEvent", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates an entire single ScheduleEvent Supplying a schedule, this will update the ScheduleEvent identified by the name or ID in the path with contents from the passed in request body. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="scheduleEventId"></param>
        /// <param name="updateScheduleEventRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ScheduleEvent</returns>
        public async System.Threading.Tasks.Task<ScheduleEvent> UpdateScheduleEventAsync(string scheduleNameOrId, string scheduleEventId, UpdateScheduleEventRequest updateScheduleEventRequest = default(UpdateScheduleEventRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateScheduleEventWithHttpInfoAsync(scheduleNameOrId, scheduleEventId, updateScheduleEventRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<ScheduleEvent> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<ScheduleEvent> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates an entire single ScheduleEvent Supplying a schedule, this will update the ScheduleEvent identified by the name or ID in the path with contents from the passed in request body. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scheduleNameOrId"></param>
        /// <param name="scheduleEventId"></param>
        /// <param name="updateScheduleEventRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ScheduleEvent)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<ScheduleEvent>> UpdateScheduleEventWithHttpInfoAsync(string scheduleNameOrId, string scheduleEventId, UpdateScheduleEventRequest updateScheduleEventRequest = default(UpdateScheduleEventRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'scheduleNameOrId' is set
            if (scheduleNameOrId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'scheduleNameOrId' when calling DefaultApi->UpdateScheduleEvent");

            // verify the required parameter 'scheduleEventId' is set
            if (scheduleEventId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'scheduleEventId' when calling DefaultApi->UpdateScheduleEvent");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("scheduleNameOrId", Elements.Client.ClientUtils.ParameterToString(scheduleNameOrId)); // path parameter
            localVarRequestOptions.PathParameters.Add("scheduleEventId", Elements.Client.ClientUtils.ParameterToString(scheduleEventId)); // path parameter
            localVarRequestOptions.Data = updateScheduleEventRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<ScheduleEvent>("/schedule/{scheduleNameOrId}/event/{scheduleEventId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateScheduleEvent", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates an inventory item for the specified item Updates an inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="updateInventoryItemRequest"> (optional)</param>
        /// <returns>InventoryItem</returns>
        public InventoryItem UpdateSimpleInventoryItem(string inventoryItemId, UpdateInventoryItemRequest updateInventoryItemRequest = default(UpdateInventoryItemRequest))
        {
            Elements.Client.ApiResponse<InventoryItem> localVarResponse = UpdateSimpleInventoryItemWithHttpInfo(inventoryItemId, updateInventoryItemRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates an inventory item for the specified item Updates an inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="updateInventoryItemRequest"> (optional)</param>
        /// <returns>ApiResponse of InventoryItem</returns>
        public Elements.Client.ApiResponse<InventoryItem> UpdateSimpleInventoryItemWithHttpInfo(string inventoryItemId, UpdateInventoryItemRequest updateInventoryItemRequest = default(UpdateInventoryItemRequest))
        {
            // verify the required parameter 'inventoryItemId' is set
            if (inventoryItemId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'inventoryItemId' when calling DefaultApi->UpdateSimpleInventoryItem");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("inventoryItemId", Elements.Client.ClientUtils.ParameterToString(inventoryItemId)); // path parameter
            localVarRequestOptions.Data = updateInventoryItemRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<InventoryItem>("/inventory/advanced/{inventoryItemId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSimpleInventoryItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates an inventory item for the specified item Updates an inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="updateInventoryItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InventoryItem</returns>
        public async System.Threading.Tasks.Task<InventoryItem> UpdateSimpleInventoryItemAsync(string inventoryItemId, UpdateInventoryItemRequest updateInventoryItemRequest = default(UpdateInventoryItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateSimpleInventoryItemWithHttpInfoAsync(inventoryItemId, updateInventoryItemRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<InventoryItem> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<InventoryItem> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates an inventory item for the specified item Updates an inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="updateInventoryItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InventoryItem)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<InventoryItem>> UpdateSimpleInventoryItemWithHttpInfoAsync(string inventoryItemId, UpdateInventoryItemRequest updateInventoryItemRequest = default(UpdateInventoryItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'inventoryItemId' is set
            if (inventoryItemId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'inventoryItemId' when calling DefaultApi->UpdateSimpleInventoryItem");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("inventoryItemId", Elements.Client.ClientUtils.ParameterToString(inventoryItemId)); // path parameter
            localVarRequestOptions.Data = updateInventoryItemRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<InventoryItem>("/inventory/advanced/{inventoryItemId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSimpleInventoryItem", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates an inventory item for the specified item Updates an inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="updateInventoryItemRequest"> (optional)</param>
        /// <returns>InventoryItem</returns>
        public InventoryItem UpdateSimpleInventoryItem1(string inventoryItemId, UpdateInventoryItemRequest updateInventoryItemRequest = default(UpdateInventoryItemRequest))
        {
            Elements.Client.ApiResponse<InventoryItem> localVarResponse = UpdateSimpleInventoryItem1WithHttpInfo(inventoryItemId, updateInventoryItemRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates an inventory item for the specified item Updates an inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="updateInventoryItemRequest"> (optional)</param>
        /// <returns>ApiResponse of InventoryItem</returns>
        public Elements.Client.ApiResponse<InventoryItem> UpdateSimpleInventoryItem1WithHttpInfo(string inventoryItemId, UpdateInventoryItemRequest updateInventoryItemRequest = default(UpdateInventoryItemRequest))
        {
            // verify the required parameter 'inventoryItemId' is set
            if (inventoryItemId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'inventoryItemId' when calling DefaultApi->UpdateSimpleInventoryItem1");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("inventoryItemId", Elements.Client.ClientUtils.ParameterToString(inventoryItemId)); // path parameter
            localVarRequestOptions.Data = updateInventoryItemRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<InventoryItem>("/inventory/simple/{inventoryItemId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSimpleInventoryItem1", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates an inventory item for the specified item Updates an inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="updateInventoryItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InventoryItem</returns>
        public async System.Threading.Tasks.Task<InventoryItem> UpdateSimpleInventoryItem1Async(string inventoryItemId, UpdateInventoryItemRequest updateInventoryItemRequest = default(UpdateInventoryItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateSimpleInventoryItem1WithHttpInfoAsync(inventoryItemId, updateInventoryItemRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<InventoryItem> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<InventoryItem> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates an inventory item for the specified item Updates an inventory item for the specified item
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inventoryItemId"></param>
        /// <param name="updateInventoryItemRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InventoryItem)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<InventoryItem>> UpdateSimpleInventoryItem1WithHttpInfoAsync(string inventoryItemId, UpdateInventoryItemRequest updateInventoryItemRequest = default(UpdateInventoryItemRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'inventoryItemId' is set
            if (inventoryItemId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'inventoryItemId' when calling DefaultApi->UpdateSimpleInventoryItem1");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("inventoryItemId", Elements.Client.ClientUtils.ParameterToString(inventoryItemId)); // path parameter
            localVarRequestOptions.Data = updateInventoryItemRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<InventoryItem>("/inventory/simple/{inventoryItemId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSimpleInventoryItem1", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Patches a  Smart Contract Patches a  Smart Contract entry, associated with the specified deployed script hash.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractId"></param>
        /// <param name="updateSmartContractRequest"> (optional)</param>
        /// <returns>SmartContract</returns>
        public SmartContract UpdateSmartContract(string contractId, UpdateSmartContractRequest updateSmartContractRequest = default(UpdateSmartContractRequest))
        {
            Elements.Client.ApiResponse<SmartContract> localVarResponse = UpdateSmartContractWithHttpInfo(contractId, updateSmartContractRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Patches a  Smart Contract Patches a  Smart Contract entry, associated with the specified deployed script hash.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractId"></param>
        /// <param name="updateSmartContractRequest"> (optional)</param>
        /// <returns>ApiResponse of SmartContract</returns>
        public Elements.Client.ApiResponse<SmartContract> UpdateSmartContractWithHttpInfo(string contractId, UpdateSmartContractRequest updateSmartContractRequest = default(UpdateSmartContractRequest))
        {
            // verify the required parameter 'contractId' is set
            if (contractId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'contractId' when calling DefaultApi->UpdateSmartContract");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("contractId", Elements.Client.ClientUtils.ParameterToString(contractId)); // path parameter
            localVarRequestOptions.Data = updateSmartContractRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<SmartContract>("/blockchain/omni/smart_contract/{contractId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSmartContract", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Patches a  Smart Contract Patches a  Smart Contract entry, associated with the specified deployed script hash.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractId"></param>
        /// <param name="updateSmartContractRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SmartContract</returns>
        public async System.Threading.Tasks.Task<SmartContract> UpdateSmartContractAsync(string contractId, UpdateSmartContractRequest updateSmartContractRequest = default(UpdateSmartContractRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateSmartContractWithHttpInfoAsync(contractId, updateSmartContractRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<SmartContract> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<SmartContract> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Patches a  Smart Contract Patches a  Smart Contract entry, associated with the specified deployed script hash.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractId"></param>
        /// <param name="updateSmartContractRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SmartContract)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<SmartContract>> UpdateSmartContractWithHttpInfoAsync(string contractId, UpdateSmartContractRequest updateSmartContractRequest = default(UpdateSmartContractRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'contractId' is set
            if (contractId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'contractId' when calling DefaultApi->UpdateSmartContract");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("contractId", Elements.Client.ClientUtils.ParameterToString(contractId)); // path parameter
            localVarRequestOptions.Data = updateSmartContractRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<SmartContract>("/blockchain/omni/smart_contract/{contractId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSmartContract", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a User Supplying the user object, this will update the user with the new information supplied in the body of the request.  Optionally, the user&#39;s password may be provided in the User object.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="userUpdateRequest"> (optional)</param>
        /// <returns>User</returns>
        public User UpdateUser(string userId, UserUpdateRequest userUpdateRequest = default(UserUpdateRequest))
        {
            Elements.Client.ApiResponse<User> localVarResponse = UpdateUserWithHttpInfo(userId, userUpdateRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a User Supplying the user object, this will update the user with the new information supplied in the body of the request.  Optionally, the user&#39;s password may be provided in the User object.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="userUpdateRequest"> (optional)</param>
        /// <returns>ApiResponse of User</returns>
        public Elements.Client.ApiResponse<User> UpdateUserWithHttpInfo(string userId, UserUpdateRequest userUpdateRequest = default(UserUpdateRequest))
        {
            // verify the required parameter 'userId' is set
            if (userId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'userId' when calling DefaultApi->UpdateUser");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("userId", Elements.Client.ClientUtils.ParameterToString(userId)); // path parameter
            localVarRequestOptions.Data = userUpdateRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<User>("/user/{userId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateUser", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a User Supplying the user object, this will update the user with the new information supplied in the body of the request.  Optionally, the user&#39;s password may be provided in the User object.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="userUpdateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of User</returns>
        public async System.Threading.Tasks.Task<User> UpdateUserAsync(string userId, UserUpdateRequest userUpdateRequest = default(UserUpdateRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateUserWithHttpInfoAsync(userId, userUpdateRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<User> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<User> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a User Supplying the user object, this will update the user with the new information supplied in the body of the request.  Optionally, the user&#39;s password may be provided in the User object.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="userUpdateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (User)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<User>> UpdateUserWithHttpInfoAsync(string userId, UserUpdateRequest userUpdateRequest = default(UserUpdateRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'userId' is set
            if (userId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'userId' when calling DefaultApi->UpdateUser");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("userId", Elements.Client.ClientUtils.ParameterToString(userId)); // path parameter
            localVarRequestOptions.Data = userUpdateRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<User>("/user/{userId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateUser", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a User&#39;s Password Supplying the UserUpdatePasswordRequest, this will attempt to update the user&#39;s password only if they supply the correct existing password.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="userUpdatePasswordRequest"> (optional)</param>
        /// <returns>SessionCreation</returns>
        public SessionCreation UpdateUserPassword(string userId, UserUpdatePasswordRequest userUpdatePasswordRequest = default(UserUpdatePasswordRequest))
        {
            Elements.Client.ApiResponse<SessionCreation> localVarResponse = UpdateUserPasswordWithHttpInfo(userId, userUpdatePasswordRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a User&#39;s Password Supplying the UserUpdatePasswordRequest, this will attempt to update the user&#39;s password only if they supply the correct existing password.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="userUpdatePasswordRequest"> (optional)</param>
        /// <returns>ApiResponse of SessionCreation</returns>
        public Elements.Client.ApiResponse<SessionCreation> UpdateUserPasswordWithHttpInfo(string userId, UserUpdatePasswordRequest userUpdatePasswordRequest = default(UserUpdatePasswordRequest))
        {
            // verify the required parameter 'userId' is set
            if (userId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'userId' when calling DefaultApi->UpdateUserPassword");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("userId", Elements.Client.ClientUtils.ParameterToString(userId)); // path parameter
            localVarRequestOptions.Data = userUpdatePasswordRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<SessionCreation>("/user/{userId}/password", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateUserPassword", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a User&#39;s Password Supplying the UserUpdatePasswordRequest, this will attempt to update the user&#39;s password only if they supply the correct existing password.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="userUpdatePasswordRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SessionCreation</returns>
        public async System.Threading.Tasks.Task<SessionCreation> UpdateUserPasswordAsync(string userId, UserUpdatePasswordRequest userUpdatePasswordRequest = default(UserUpdatePasswordRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateUserPasswordWithHttpInfoAsync(userId, userUpdatePasswordRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<SessionCreation> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<SessionCreation> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a User&#39;s Password Supplying the UserUpdatePasswordRequest, this will attempt to update the user&#39;s password only if they supply the correct existing password.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="userUpdatePasswordRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SessionCreation)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<SessionCreation>> UpdateUserPasswordWithHttpInfoAsync(string userId, UserUpdatePasswordRequest userUpdatePasswordRequest = default(UserUpdatePasswordRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'userId' is set
            if (userId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'userId' when calling DefaultApi->UpdateUserPassword");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("userId", Elements.Client.ClientUtils.ParameterToString(userId)); // path parameter
            localVarRequestOptions.Data = userUpdatePasswordRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<SessionCreation>("/user/{userId}/password", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateUserPassword", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a  Vault Updates a  Vault with the specified name or id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="updateVaultRequest"> (optional)</param>
        /// <returns>Vault</returns>
        public Vault UpdateVault(string vaultId, UpdateVaultRequest updateVaultRequest = default(UpdateVaultRequest))
        {
            Elements.Client.ApiResponse<Vault> localVarResponse = UpdateVaultWithHttpInfo(vaultId, updateVaultRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a  Vault Updates a  Vault with the specified name or id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="updateVaultRequest"> (optional)</param>
        /// <returns>ApiResponse of Vault</returns>
        public Elements.Client.ApiResponse<Vault> UpdateVaultWithHttpInfo(string vaultId, UpdateVaultRequest updateVaultRequest = default(UpdateVaultRequest))
        {
            // verify the required parameter 'vaultId' is set
            if (vaultId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'vaultId' when calling DefaultApi->UpdateVault");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("vaultId", Elements.Client.ClientUtils.ParameterToString(vaultId)); // path parameter
            localVarRequestOptions.Data = updateVaultRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<Vault>("/blockchain/omni/vault/{vaultId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateVault", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a  Vault Updates a  Vault with the specified name or id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="updateVaultRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Vault</returns>
        public async System.Threading.Tasks.Task<Vault> UpdateVaultAsync(string vaultId, UpdateVaultRequest updateVaultRequest = default(UpdateVaultRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateVaultWithHttpInfoAsync(vaultId, updateVaultRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Vault> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Vault> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a  Vault Updates a  Vault with the specified name or id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="updateVaultRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Vault)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Vault>> UpdateVaultWithHttpInfoAsync(string vaultId, UpdateVaultRequest updateVaultRequest = default(UpdateVaultRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'vaultId' is set
            if (vaultId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'vaultId' when calling DefaultApi->UpdateVault");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("vaultId", Elements.Client.ClientUtils.ParameterToString(vaultId)); // path parameter
            localVarRequestOptions.Data = updateVaultRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<Vault>("/blockchain/omni/vault/{vaultId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateVault", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a  Wallet Updates a  Wallet with the specified name or id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="walletId"></param>
        /// <param name="updateWalletRequest"> (optional)</param>
        /// <returns>Wallet</returns>
        public Wallet UpdateWallet(string vaultId, string walletId, UpdateWalletRequest updateWalletRequest = default(UpdateWalletRequest))
        {
            Elements.Client.ApiResponse<Wallet> localVarResponse = UpdateWalletWithHttpInfo(vaultId, walletId, updateWalletRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a  Wallet Updates a  Wallet with the specified name or id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="walletId"></param>
        /// <param name="updateWalletRequest"> (optional)</param>
        /// <returns>ApiResponse of Wallet</returns>
        public Elements.Client.ApiResponse<Wallet> UpdateWalletWithHttpInfo(string vaultId, string walletId, UpdateWalletRequest updateWalletRequest = default(UpdateWalletRequest))
        {
            // verify the required parameter 'vaultId' is set
            if (vaultId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'vaultId' when calling DefaultApi->UpdateWallet");

            // verify the required parameter 'walletId' is set
            if (walletId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'walletId' when calling DefaultApi->UpdateWallet");

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("vaultId", Elements.Client.ClientUtils.ParameterToString(vaultId)); // path parameter
            localVarRequestOptions.PathParameters.Add("walletId", Elements.Client.ClientUtils.ParameterToString(walletId)); // path parameter
            localVarRequestOptions.Data = updateWalletRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<Wallet>("/blockchain/omni/vault/{vaultId}/wallet/{walletId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateWallet", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Updates a  Wallet Updates a  Wallet with the specified name or id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="walletId"></param>
        /// <param name="updateWalletRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Wallet</returns>
        public async System.Threading.Tasks.Task<Wallet> UpdateWalletAsync(string vaultId, string walletId, UpdateWalletRequest updateWalletRequest = default(UpdateWalletRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UpdateWalletWithHttpInfoAsync(vaultId, walletId, updateWalletRequest, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<Wallet> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<Wallet> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a  Wallet Updates a  Wallet with the specified name or id.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="vaultId"></param>
        /// <param name="walletId"></param>
        /// <param name="updateWalletRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Wallet)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<Wallet>> UpdateWalletWithHttpInfoAsync(string vaultId, string walletId, UpdateWalletRequest updateWalletRequest = default(UpdateWalletRequest), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'vaultId' is set
            if (vaultId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'vaultId' when calling DefaultApi->UpdateWallet");

            // verify the required parameter 'walletId' is set
            if (walletId == null)
                throw new Elements.Client.ApiException(400, "Missing required parameter 'walletId' when calling DefaultApi->UpdateWallet");


            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("vaultId", Elements.Client.ClientUtils.ParameterToString(vaultId)); // path parameter
            localVarRequestOptions.PathParameters.Add("walletId", Elements.Client.ClientUtils.ParameterToString(walletId)); // path parameter
            localVarRequestOptions.Data = updateWalletRequest;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PutAsync<Wallet>("/blockchain/omni/vault/{vaultId}/wallet/{walletId}", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateWallet", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Upload Apple IAP Receipt. Returns a list of RewardIssuances, which may contain already-redeemed issuances.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAppleIapReceipt"> (optional)</param>
        /// <returns>List&lt;RewardIssuance&gt;</returns>
        public List<RewardIssuance> UploadAppleIapReceipt(CreateAppleIapReceipt createAppleIapReceipt = default(CreateAppleIapReceipt))
        {
            Elements.Client.ApiResponse<List<RewardIssuance>> localVarResponse = UploadAppleIapReceiptWithHttpInfo(createAppleIapReceipt);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Upload Apple IAP Receipt. Returns a list of RewardIssuances, which may contain already-redeemed issuances.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAppleIapReceipt"> (optional)</param>
        /// <returns>ApiResponse of List&lt;RewardIssuance&gt;</returns>
        public Elements.Client.ApiResponse<List<RewardIssuance>> UploadAppleIapReceiptWithHttpInfo(CreateAppleIapReceipt createAppleIapReceipt = default(CreateAppleIapReceipt))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createAppleIapReceipt;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<List<RewardIssuance>>("/ios/receipt", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UploadAppleIapReceipt", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Upload Apple IAP Receipt. Returns a list of RewardIssuances, which may contain already-redeemed issuances.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAppleIapReceipt"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;RewardIssuance&gt;</returns>
        public async System.Threading.Tasks.Task<List<RewardIssuance>> UploadAppleIapReceiptAsync(CreateAppleIapReceipt createAppleIapReceipt = default(CreateAppleIapReceipt), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UploadAppleIapReceiptWithHttpInfoAsync(createAppleIapReceipt, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<List<RewardIssuance>> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<List<RewardIssuance>> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Upload Apple IAP Receipt. Returns a list of RewardIssuances, which may contain already-redeemed issuances.
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAppleIapReceipt"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;RewardIssuance&gt;)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<List<RewardIssuance>>> UploadAppleIapReceiptWithHttpInfoAsync(CreateAppleIapReceipt createAppleIapReceipt = default(CreateAppleIapReceipt), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createAppleIapReceipt;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<List<RewardIssuance>>("/ios/receipt", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UploadAppleIapReceipt", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Upload Google Play IAP Receipt data (package name, product id and Google Play-issued purchase token). Returns a list of RewardIssuances, some or all of which may be already redeemed. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createGooglePlayIapReceipt"> (optional)</param>
        /// <returns>List&lt;RewardIssuance&gt;</returns>
        public List<RewardIssuance> UploadGooglePlayIapPurchase(CreateGooglePlayIapReceipt createGooglePlayIapReceipt = default(CreateGooglePlayIapReceipt))
        {
            Elements.Client.ApiResponse<List<RewardIssuance>> localVarResponse = UploadGooglePlayIapPurchaseWithHttpInfo(createGooglePlayIapReceipt);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Upload Google Play IAP Receipt data (package name, product id and Google Play-issued purchase token). Returns a list of RewardIssuances, some or all of which may be already redeemed. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createGooglePlayIapReceipt"> (optional)</param>
        /// <returns>ApiResponse of List&lt;RewardIssuance&gt;</returns>
        public Elements.Client.ApiResponse<List<RewardIssuance>> UploadGooglePlayIapPurchaseWithHttpInfo(CreateGooglePlayIapReceipt createGooglePlayIapReceipt = default(CreateGooglePlayIapReceipt))
        {
            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createGooglePlayIapReceipt;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<List<RewardIssuance>>("/google/purchase", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UploadGooglePlayIapPurchase", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Upload Google Play IAP Receipt data (package name, product id and Google Play-issued purchase token). Returns a list of RewardIssuances, some or all of which may be already redeemed. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createGooglePlayIapReceipt"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;RewardIssuance&gt;</returns>
        public async System.Threading.Tasks.Task<List<RewardIssuance>> UploadGooglePlayIapPurchaseAsync(CreateGooglePlayIapReceipt createGooglePlayIapReceipt = default(CreateGooglePlayIapReceipt), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            var task = UploadGooglePlayIapPurchaseWithHttpInfoAsync(createGooglePlayIapReceipt, cancellationToken);
#if UNITY_EDITOR || !UNITY_WEBGL
            Elements.Client.ApiResponse<List<RewardIssuance>> localVarResponse = await task.ConfigureAwait(false);
#else
            Elements.Client.ApiResponse<List<RewardIssuance>> localVarResponse = await task;
#endif
            return localVarResponse.Data;
        }

        /// <summary>
        /// Upload Google Play IAP Receipt data (package name, product id and Google Play-issued purchase token). Returns a list of RewardIssuances, some or all of which may be already redeemed. 
        /// </summary>
        /// <exception cref="Elements.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createGooglePlayIapReceipt"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;RewardIssuance&gt;)</returns>
        public async System.Threading.Tasks.Task<Elements.Client.ApiResponse<List<RewardIssuance>>> UploadGooglePlayIapPurchaseWithHttpInfoAsync(CreateGooglePlayIapReceipt createGooglePlayIapReceipt = default(CreateGooglePlayIapReceipt), System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Elements.Client.RequestOptions localVarRequestOptions = new Elements.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Elements.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Elements.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = createGooglePlayIapReceipt;

            // authentication (auth_bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (session_secret) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret")))
            {
                localVarRequestOptions.HeaderParameters.Add("Elements-SessionSecret", this.Configuration.GetApiKeyWithPrefix("Elements-SessionSecret"));
            }

            // make the HTTP request

            var task = this.AsynchronousClient.PostAsync<List<RewardIssuance>>("/google/purchase", localVarRequestOptions, this.Configuration, cancellationToken);

#if UNITY_EDITOR || !UNITY_WEBGL
            var localVarResponse = await task.ConfigureAwait(false);
#else
            var localVarResponse = await task;
#endif

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UploadGooglePlayIapPurchase", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

    }
}
